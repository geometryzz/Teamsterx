rules_version = '2'; 
service cloud.firestore {
  match /databases/{database}/documents {

    // ============================
    // HELPER FUNCTIONS
    // ============================

    // Check if team document exists (reliability guard)
    function teamExists(teamId) {
      return exists(/databases/$(database)/documents/teams/$(teamId));
    }

    // Safely get team data (returns null-safe access)
    function getTeamData(teamId) {
      return get(/databases/$(database)/documents/teams/$(teamId)).data;
    }

    // Check if the authenticated user is a member of a team
    // With existence guard to prevent runtime errors
    function isMemberInTeam(teamId) {
      return request.auth != null
        && teamExists(teamId)
        && request.auth.uid in getTeamData(teamId).members;
    }

    // Check if the authenticated user will be a member when creating a team
    function willBeMember() {
      return request.auth != null
        && request.auth.uid in request.resource.data.members;
    }

    // Get this user's member role for a team (with safe defaults)
    function getMemberRole(teamId) {
      let teamData = getTeamData(teamId);
      return (request.auth.uid in teamData.members) 
        ? teamData.members[request.auth.uid].role 
        : 'none';
    }

    // Check if user is owner
    function isOwner(teamId) {
      return isMemberInTeam(teamId) && getMemberRole(teamId) == "owner";
    }

    // Check if user is admin or owner
    function isAdmin(teamId) {
      return isMemberInTeam(teamId) && getMemberRole(teamId) in ["admin", "owner"];
    }

    // CRITICAL: Check if members change is removal-only (no role escalation)
    // Returns true if newMap only removes keys from oldMap without modifying existing values
    function isRemovalOnly(oldMap, newMap) {
      // New keys must be subset of old keys
      let keysOk = newMap.keys().toSet().hasOnly(oldMap.keys());
      // All remaining keys must have identical values (deep equality)
      let valuesOk = newMap.diff(oldMap).affectedKeys().size() == 0;
      return keysOk && valuesOk;
    }

    // Validate visibility enum
    function isValidVisibility(visibility) {
      return visibility in ['team', 'admins', 'private'];
    }

    // Validate role enum
    function isValidRole(role) {
      return role in ['owner', 'admin', 'member'];
    }

    // Check if field is unchanged between existing and new resource
    function fieldUnchanged(field) {
      return request.resource.data[field] == resource.data[field];
    }

    // Validate join request schema (strict field enforcement)
    function isValidJoinRequest(requestData) {
      return requestData.keys().hasOnly(['name', 'email', 'photoURL', 'requestedAt', 'status'])
        && requestData.name is string
        && requestData.name.size() <= 100
        && requestData.email is string
        && requestData.email.size() <= 254
        && requestData.status == 'pending'
        && requestData.requestedAt == request.time;
    }

    // ============================
    // USERS (PRIVATE - OWNER ONLY)
    // ============================
    match /users/{userId} {
      // Only the owner can read their own profile
      allow read: if request.auth != null && request.auth.uid == userId;

      // Only the user themselves can create their own profile document
      allow create: if request.auth != null && request.auth.uid == userId;
      
      // User can update/delete their own profile
      allow update, delete: if request.auth != null && request.auth.uid == userId;
    }
    
    // Separate rule for user settings subcollection
    match /users/{userId}/settings/{settingId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // ============================
    // PUBLIC PROFILES (LIMITED FIELDS)
    // For teammate lookups, assignee dropdowns, etc.
    // SECURITY: Email removed to prevent cross-team scraping
    // NOTE: Readable by all authenticated users - consider team-scoped profiles in future
    // ============================
    match /publicProfiles/{userId} {
      // Any authenticated user can read public profiles
      // LIMITATION: This allows cross-team profile scraping (displayName, occupation, photoURL, avatarColor)
      // MITIGATION: Email removed; only non-sensitive fields exposed
      allow read: if request.auth != null;

      // Only the owner can create/update their own public profile
      // SECURITY: Email NOT allowed - use team members map for email in team context
      allow create: if request.auth != null 
        && request.auth.uid == userId
        && request.resource.data.keys().hasOnly(['displayName', 'photoURL', 'occupation', 'avatarColor', 'updatedAt'])
        && request.resource.data.displayName is string
        && request.resource.data.displayName.size() <= 100;
      
      allow update: if request.auth != null 
        && request.auth.uid == userId
        // SECURITY: Only validate CHANGED fields (affectedKeys), not entire doc
        // This allows updates when docs have legacy fields not in whitelist
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['displayName', 'photoURL', 'occupation', 'avatarColor', 'updatedAt'])
        && request.resource.data.displayName is string
        && request.resource.data.displayName.size() <= 100
        // Validate optional fields if present in final doc
        && (!('photoURL' in request.resource.data) || request.resource.data.photoURL is string)
        && (!('avatarColor' in request.resource.data) || request.resource.data.avatarColor is string)
        && (!('occupation' in request.resource.data) || 
            (request.resource.data.occupation is string && request.resource.data.occupation.size() <= 200));

      allow delete: if request.auth != null && request.auth.uid == userId;
    }

    // ============================
    // TEAMS
    // ============================
    match /teams/{teamId} {
      // Create team: the creator must be in the members map
      // SECURITY: Validate schema and limits
      allow create: if willBeMember()
        && request.resource.data.createdBy == request.auth.uid
        && request.resource.data.keys().hasOnly([
          'members', 'createdBy', 'createdAt', 'name', 'teamName', 'teamCode',
          'settings', 'pendingRequests', 'owner', 'updatedAt'
        ])
        && request.resource.data.members is map
        && request.resource.data.members.size() >= 1
        && request.resource.data.members.size() <= 200;

      // Read team: ONLY members can read full team data
      // For join flow, use teamJoinInfo collection instead
      allow read: if isMemberInTeam(teamId);

      // Update team:
      // NOTE: Join requests now use /teams/{teamId}/joinRequests/{userId} subcollection
      // The old pendingRequests map is DEPRECATED and locked down (DoS prevention)
      allow update: if request.auth != null && (
        // DEPRECATED: pendingRequests map-based join flow is DISABLED
        // This prevents DoS attacks via map growth hitting 1MB document limit
        // Join requests now go to /teams/{teamId}/joinRequests/{userId} subcollection
        // (false && <old condition removed>)
        
        // Existing member updates
        (
          request.auth.uid in resource.data.members && (
            (
              // Owners can update anything (including roles and member removal)
              // EXCEPTION: Cannot modify pendingRequests (deprecated, locked)
              resource.data.members[request.auth.uid].role == 'owner' &&
              !request.resource.data.diff(resource.data).affectedKeys().hasAny(['pendingRequests'])
            ) ||
            (
              // Admins can:
              // 1. Update non-member fields (EXCEPT owner and pendingRequests)
              // 2. Remove members (for leave request approval)
              // CRITICAL: Cannot change owner, roles, or any data for existing members
              resource.data.members[request.auth.uid].role in ['admin', 'owner'] &&
              // SECURITY: Admins cannot modify owner field (prevents team takeover)
              // SECURITY: Admins cannot modify pendingRequests (deprecated, locked)
              !request.resource.data.diff(resource.data).affectedKeys().hasAny(['owner', 'pendingRequests']) &&
              (
                // Either no members changes
                !request.resource.data.diff(resource.data).affectedKeys().hasAny(['members']) ||
                // Or members change is REMOVAL ONLY (no value modifications)
                (
                  'members' in resource.data &&
                  'members' in request.resource.data &&
                  isRemovalOnly(resource.data.members, request.resource.data.members)
                )
              )
            ) ||
            (
              // Regular members can update certain fields but not members/roles/settings/pendingRequests
              resource.data.members[request.auth.uid].role == 'member' &&
              !request.resource.data.diff(resource.data).affectedKeys().hasAny(['members', 'owner', 'settings', 'pendingRequests'])
            )
          )
        )
      );

      // Only owners can delete a team
      allow delete: if isOwner(teamId);

      // ==========================
      // PENDING LEAVE REQUESTS SUBCOLLECTION
      // Secure leave-team flow: members request, admins approve
      // ==========================
      match /pendingLeaveRequests/{requestId} {
        // Admins can read leave requests
        allow read: if isAdmin(teamId);
        
        // Members can create a request for themselves only
        allow create: if isMemberInTeam(teamId)
          && request.resource.data.userId == request.auth.uid
          && request.resource.data.status == 'pending';
        
        // Only admins can delete (approve/deny)
        allow delete: if isAdmin(teamId);
        
        // No updates allowed - delete and recreate if needed
        allow update: if false;
      }

      // ==========================
      // JOIN REQUESTS SUBCOLLECTION (replaces pendingRequests map)
      // SECURITY: Prevents DoS via map growth that could hit 1MB document limit
      // Flow: user creates request → admins read/approve/deny → deleted on resolution
      // ==========================
      match /joinRequests/{requestUserId} {
        // Admins/owners can read all join requests
        allow read: if isAdmin(teamId);
        
        // Users can read their own request (to check status)
        allow read: if request.auth != null && request.auth.uid == requestUserId;
        
        // Any authenticated user can create ONE request for themselves
        // SECURITY: Strict schema, user can only create their own, immutable after creation
        allow create: if request.auth != null
          && request.auth.uid == requestUserId
          && request.resource.data.keys().hasOnly(['name', 'email', 'photoURL', 'requestedAt', 'status', 'userId'])
          && request.resource.data.userId == request.auth.uid
          && request.resource.data.name is string
          && request.resource.data.name.size() >= 1
          && request.resource.data.name.size() <= 100
          && request.resource.data.email is string
          && request.resource.data.email.size() <= 254
          && request.resource.data.status == 'pending'
          && request.resource.data.requestedAt == request.time;
        
        // Only admins/owners can delete (approve removes it, deny removes it)
        allow delete: if isAdmin(teamId);
        
        // No updates allowed - immutable design (delete and recreate if needed)
        allow update: if false;
      }

      // ==========================
      // TASKS SUBCOLLECTION
      // SECURITY: Schema validation + size limits
      // ==========================
      match /tasks/{taskId} {
        // Any team member can read tasks
        allow read: if isMemberInTeam(teamId);
        
        // Create: member, createdBy must match, validate schema
        allow create: if isMemberInTeam(teamId)
          && request.resource.data.createdBy == request.auth.uid
          && request.resource.data.keys().hasOnly([
            'createdBy', 'teamId', 'title', 'description', 'status', 
            'assignee', 'assigneeId', 'priority', 'dueAt', 'dueDate', 'createdAt', 'updatedAt',
            'tags', 'completed', 'completedAt', 'completedBy', 'progress', 'estimatedTime',
            'budget', 'spreadsheetId', 'showOnCalendar'
          ])
          && request.resource.data.teamId == teamId
          && request.resource.data.title is string
          && request.resource.data.title.size() > 0
          && request.resource.data.title.size() <= 200
          && (!('description' in request.resource.data) || 
              (request.resource.data.description is string && request.resource.data.description.size() <= 5000))
          && (!('tags' in request.resource.data) || 
              (request.resource.data.tags is list && request.resource.data.tags.size() <= 20))
          && (!('progress' in request.resource.data) || 
              (request.resource.data.progress is int && request.resource.data.progress >= 0 && request.resource.data.progress <= 100))
          && (!('estimatedTime' in request.resource.data) || 
              (request.resource.data.estimatedTime is number && request.resource.data.estimatedTime >= 0 && request.resource.data.estimatedTime <= 10000));

        // Update: admin/owner can update any; creator can update their own; assignee can update progress/status
        // Cannot change immutable fields: createdBy, teamId
        // SECURITY: Schema validation on UPDATE using affectedKeys (allows legacy fields to exist)
        allow update: if isMemberInTeam(teamId) && (
          isAdmin(teamId) ||
          resource.data.createdBy == request.auth.uid ||
          // SECURITY: Assignees can update limited fields (progress, status, completed*, updatedAt)
          // Check assigneeId (UID) for permission, as assignee field is display name
          (
            resource.data.assigneeId == request.auth.uid &&
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['progress', 'status', 'completed', 'completedAt', 'completedBy', 'updatedAt'])
          )
        ) && (
          // SECURITY: Only validate CHANGED fields (affectedKeys), not entire doc
          // This allows updates when docs have legacy fields not in whitelist
          request.resource.data.diff(resource.data).affectedKeys().hasOnly([
            'title', 'description', 'status', 'assignee', 'assigneeId', 'priority', 'dueAt', 'dueDate', 'updatedAt',
            'tags', 'completed', 'completedAt', 'completedBy', 'progress', 'estimatedTime',
            'budget', 'spreadsheetId', 'showOnCalendar'
          ])
        ) && (
          // SECURITY: Immutable fields cannot change (conditional checks for legacy docs without teamId/createdAt)
          fieldUnchanged('createdBy') &&
          (!('teamId' in resource.data) || fieldUnchanged('teamId')) &&
          (!('createdAt' in resource.data) || fieldUnchanged('createdAt'))
        ) && (
          // Validate updated fields still meet constraints
          // NOTE: teamId and title checks are conditional for legacy docs
          (!('teamId' in request.resource.data) || request.resource.data.teamId == teamId) &&
          (!('title' in request.resource.data) || (
            request.resource.data.title is string &&
            request.resource.data.title.size() > 0 &&
            request.resource.data.title.size() <= 200
          )) &&
          (!('description' in request.resource.data) || 
              (request.resource.data.description is string && request.resource.data.description.size() <= 5000)) &&
          (!('progress' in request.resource.data) || 
              (request.resource.data.progress is int && request.resource.data.progress >= 0 && request.resource.data.progress <= 100))
        );

        // Delete: admin/owner or creator
        allow delete: if isAdmin(teamId) ||
          (isMemberInTeam(teamId) && resource.data.createdBy == request.auth.uid);
      }

      // ==========================
      // MESSAGES SUBCOLLECTION
      // SECURITY: Length limits + teamId validation + identity spoofing prevention
      // ==========================
      match /messages/{messageId} {
        // Any team member can read messages
        allow read: if isMemberInTeam(teamId);
        
        // Create: member, userId must match, validate content length
        // SECURITY: userEmail must match auth token email (prevents identity spoofing)
        allow create: if isMemberInTeam(teamId)
          && request.resource.data.userId == request.auth.uid
          && request.resource.data.keys().hasOnly([
            'userId', 'userName', 'message', 'timestamp', 'createdAt',
            'edited', 'editedAt', 'teamId', 'userEmail', 'photoURL'
          ])
          && (!('teamId' in request.resource.data) || request.resource.data.teamId == teamId)
          // SECURITY: Prevent identity spoofing - userEmail must match auth token if provided
          && (!('userEmail' in request.resource.data) || 
              request.resource.data.userEmail == request.auth.token.email)
          && request.resource.data.message is string
          && request.resource.data.message.size() > 0
          && request.resource.data.message.size() <= 5000;

        // Delete: admins or own message
        allow delete: if isAdmin(teamId) ||
          (isMemberInTeam(teamId) && resource.data.userId == request.auth.uid);

        // Update rules:
        // - Original author can update their own message content (except userId)
        // - NO longer allow reactions field updates (reactions moved to subcollection)
        // SECURITY: Schema validation on UPDATE + identity spoofing prevention
        allow update: if isMemberInTeam(teamId) 
          && resource.data.userId == request.auth.uid 
          && fieldUnchanged('userId')
          && !request.resource.data.diff(resource.data).affectedKeys().hasAny(['reactions'])
          // Schema validation: only allowed fields
          && request.resource.data.keys().hasOnly([
            'userId', 'userName', 'message', 'timestamp', 'createdAt',
            'edited', 'editedAt', 'teamId', 'userEmail', 'photoURL'
          ])
          // SECURITY: Prevent identity spoofing - userEmail must match auth token if provided
          && (!('userEmail' in request.resource.data) || 
              request.resource.data.userEmail == request.auth.token.email)
          && request.resource.data.message is string
          && request.resource.data.message.size() > 0
          && request.resource.data.message.size() <= 5000;

        // ==========================
        // REACTIONS SUBCOLLECTION
        // Secure per-user reaction storage
        // ==========================
        match /reactions/{odcUserId} {
          // Any team member can read reactions
          allow read: if isMemberInTeam(teamId);
          
          // Users can only create/update/delete their own reaction doc
          allow create, update: if isMemberInTeam(teamId)
            && request.auth.uid == odcUserId
            && request.resource.data.userId == request.auth.uid
            && request.resource.data.emoji is string
            && request.resource.data.emoji.size() <= 8;
          
          allow delete: if isMemberInTeam(teamId)
            && request.auth.uid == odcUserId;
        }
      }

      // ==========================
      // EVENTS SUBCOLLECTION
      // SECURITY: Visibility validation + size limits
      // ==========================
      match /events/{eventId} {
        // Read: enforce visibility server-side
        allow read: if isMemberInTeam(teamId) && (
          // Team visibility: all members
          resource.data.visibility == 'team' ||
          !('visibility' in resource.data) ||
          // Admins visibility: admins/owners or creator
          (resource.data.visibility == 'admins' && (isAdmin(teamId) || resource.data.createdBy == request.auth.uid)) ||
          // Private: only creator
          (resource.data.visibility == 'private' && resource.data.createdBy == request.auth.uid)
        );

        // Create: member, createdBy must match, visibility must be valid
        allow create: if isMemberInTeam(teamId)
          && request.resource.data.createdBy == request.auth.uid
          && request.resource.data.keys().hasOnly([
            'createdBy', 'teamId', 'title', 'description', 'startTime', 'endTimeStamp',
            'startTimeStr', 'endTimeStr', 'color', 'visibility', 'createdAt', 'createdByName', 'updatedAt'
          ])
          && (!('teamId' in request.resource.data) || request.resource.data.teamId == teamId)
          && request.resource.data.title is string
          && request.resource.data.title.size() > 0
          && request.resource.data.title.size() <= 200
          && (!('description' in request.resource.data) || 
              (request.resource.data.description is string && request.resource.data.description.size() <= 2000))
          && (!('visibility' in request.resource.data) || isValidVisibility(request.resource.data.visibility));

        // Update: admin/owner or creator; cannot change immutable fields
        // SECURITY: Schema validation on UPDATE (prevents field injection)
        allow update: if isMemberInTeam(teamId) && (
          isAdmin(teamId) ||
          resource.data.createdBy == request.auth.uid
        ) && (
          // Schema validation: only allowed fields
          request.resource.data.keys().hasOnly([
            'createdBy', 'teamId', 'title', 'description', 'startTime', 'endTimeStamp',
            'startTimeStr', 'endTimeStr', 'color', 'visibility', 'createdAt', 'createdByName', 'updatedAt'
          ])
        ) && (
          !request.resource.data.diff(resource.data).affectedKeys().hasAny(['createdBy', 'teamId']) ||
          (fieldUnchanged('createdBy') && (!('teamId' in resource.data) || fieldUnchanged('teamId')))
        ) && (
          request.resource.data.title is string &&
          request.resource.data.title.size() > 0 &&
          request.resource.data.title.size() <= 200 &&
          (!('visibility' in request.resource.data) || isValidVisibility(request.resource.data.visibility))
        );

        // Delete: admin/owner or creator
        allow delete: if isAdmin(teamId) ||
          (isMemberInTeam(teamId) && resource.data.createdBy == request.auth.uid);
      }

      // ==========================
      // ACTIVITIES SUBCOLLECTION
      // ==========================
      match /activities/{activityId} {
        // Any team member can read activities
        allow read: if isMemberInTeam(teamId);

        // Create: team member, with proper createdBy
        allow create: if isMemberInTeam(teamId)
          && request.resource.data.createdBy == request.auth.uid;

        // Activities are immutable - no updates allowed
        allow update: if false;

        // Only admins/owners can delete activities
        allow delete: if isAdmin(teamId);
      }

      // ==========================
      // SPREADSHEETS SUBCOLLECTION
      // SECURITY: Full visibility model + schema validation
      // ==========================
      match /spreadsheets/{spreadsheetId} {
        // Read: enforce visibility server-side (same model as events)
        allow read: if isMemberInTeam(teamId) && (
          // Team visibility or missing: all members
          resource.data.visibility == 'team' ||
          !('visibility' in resource.data) ||
          // Admins visibility: admins/owners or creator
          (resource.data.visibility == 'admins' && (isAdmin(teamId) || resource.data.createdBy == request.auth.uid)) ||
          // Private: only creator
          (resource.data.visibility == 'private' && resource.data.createdBy == request.auth.uid)
        );

        // Create: member, createdBy must match, visibility must be valid
        // SECURITY: Size limits to prevent cost abuse
        allow create: if isMemberInTeam(teamId) 
          && request.resource.data.createdBy == request.auth.uid
          && request.resource.data.keys().hasOnly([
            'createdBy', 'teamId', 'name', 'description', 'visibility',
            'createdAt', 'updatedAt', 'data', 'columns', 'rows',
            'type', 'icon', 'color', 'customColumns', 'columnSettings'
          ])
          && (!('teamId' in request.resource.data) || request.resource.data.teamId == teamId)
          && request.resource.data.name is string
          && request.resource.data.name.size() > 0
          && request.resource.data.name.size() <= 200
          && (!('description' in request.resource.data) || 
              (request.resource.data.description is string && request.resource.data.description.size() <= 1000))
          && (!('visibility' in request.resource.data) || isValidVisibility(request.resource.data.visibility))
          // SECURITY: Type/icon/color validation
          && (!('type' in request.resource.data) || 
              (request.resource.data.type is string && request.resource.data.type.size() <= 30))
          && (!('icon' in request.resource.data) || 
              (request.resource.data.icon is string && request.resource.data.icon.size() <= 50))
          && (!('color' in request.resource.data) || 
              (request.resource.data.color is string && request.resource.data.color.size() <= 20))
          // SECURITY: Spreadsheet size limits to prevent cost abuse
          // Limit rows array to 1000 entries, columns to 50, customColumns to 50
          && (!('rows' in request.resource.data) || 
              (request.resource.data.rows is list && request.resource.data.rows.size() <= 1000))
          && (!('columns' in request.resource.data) || 
              (request.resource.data.columns is list && request.resource.data.columns.size() <= 50))
          && (!('customColumns' in request.resource.data) || 
              (request.resource.data.customColumns is list && request.resource.data.customColumns.size() <= 50))
          && (!('columnSettings' in request.resource.data) || 
              request.resource.data.columnSettings is map);

        // Update: based on visibility - private only by creator, admins-only by admin/creator
        // SECURITY: Schema validation on UPDATE using affectedKeys (allows legacy fields to exist)
        allow update: if isMemberInTeam(teamId) && (
          // Creator can always update their own
          resource.data.createdBy == request.auth.uid ||
          // Team visibility: any member
          resource.data.visibility == 'team' ||
          !('visibility' in resource.data) ||
          // Admins visibility: only admins
          (resource.data.visibility == 'admins' && isAdmin(teamId))
          // Private: only creator (covered above)
        ) && (
          // SECURITY: Only validate CHANGED fields (affectedKeys), not entire doc
          // This allows updates when docs have legacy fields (e.g., savedType) not in whitelist
          request.resource.data.diff(resource.data).affectedKeys().hasOnly([
            'name', 'description', 'visibility', 'updatedAt', 'data', 'columns', 'rows',
            'type', 'icon', 'color', 'customColumns', 'columnSettings'
          ])
        ) && (
          // SECURITY: Immutable fields cannot change (createdAt check is conditional for legacy docs)
          fieldUnchanged('createdBy') && fieldUnchanged('teamId') &&
          (!('createdAt' in resource.data) || fieldUnchanged('createdAt'))
        ) && (
          // Visibility must be valid if provided
          request.resource.data.name is string &&
          request.resource.data.name.size() > 0 &&
          request.resource.data.name.size() <= 200 &&
          (!('visibility' in request.resource.data) || isValidVisibility(request.resource.data.visibility))
        ) && (
          // SECURITY: Type/icon/color validation
          (!('type' in request.resource.data) || 
              (request.resource.data.type is string && request.resource.data.type.size() <= 30)) &&
          (!('icon' in request.resource.data) || 
              (request.resource.data.icon is string && request.resource.data.icon.size() <= 50)) &&
          (!('color' in request.resource.data) || 
              (request.resource.data.color is string && request.resource.data.color.size() <= 20))
        ) && (
          // SECURITY: Spreadsheet size limits to prevent cost abuse
          // Limit rows array to 1000 entries, columns to 50, customColumns to 50
          (!('rows' in request.resource.data) || 
            (request.resource.data.rows is list && request.resource.data.rows.size() <= 1000)) &&
          (!('columns' in request.resource.data) || 
            (request.resource.data.columns is list && request.resource.data.columns.size() <= 50)) &&
          (!('customColumns' in request.resource.data) || 
            (request.resource.data.customColumns is list && request.resource.data.customColumns.size() <= 50)) &&
          (!('columnSettings' in request.resource.data) || 
            request.resource.data.columnSettings is map)
        );

        // Delete: creator or admin (for non-private)
        allow delete: if isMemberInTeam(teamId) && (
          resource.data.createdBy == request.auth.uid ||
          (resource.data.visibility != 'private' && isAdmin(teamId))
        );
      }

      // ==========================
      // LINK LOBBY GROUPS SUBCOLLECTION
      // SECURITY: Strict visibility validation + length limits
      // ==========================
      match /linkLobbyGroups/{groupId} {
        // Read: enforce visibility server-side
        allow read: if isMemberInTeam(teamId) && (
          // Team visibility or missing: all members
          resource.data.visibility == 'team' ||
          !('visibility' in resource.data) ||
          // Private: only creator
          (resource.data.visibility == 'private' && resource.data.createdBy == request.auth.uid)
        );

        // Create: member, createdBy must match, visibility restricted to team/private
        allow create: if isMemberInTeam(teamId) 
          && request.resource.data.createdBy == request.auth.uid
          && request.resource.data.keys().hasOnly([
            'createdBy', 'teamId', 'title', 'visibility', 'sortOrder',
            'autoGroupDomain', 'createdAt', 'updatedAt'
          ])
          && request.resource.data.title is string
          && request.resource.data.title.size() > 0
          && request.resource.data.title.size() <= 100
          && (!('visibility' in request.resource.data) || request.resource.data.visibility in ['team', 'private']);

        // Update: creator can always update; others only non-private groups
        // SECURITY: Schema validation on UPDATE using affectedKeys (allows legacy fields to exist)
        allow update: if isMemberInTeam(teamId) && (
          resource.data.createdBy == request.auth.uid ||
          (resource.data.visibility != 'private' || !('visibility' in resource.data))
        ) && (
          // SECURITY: Only validate CHANGED fields (affectedKeys), not entire doc
          // This allows updates when docs have legacy fields not in whitelist
          request.resource.data.diff(resource.data).affectedKeys().hasOnly([
            'title', 'visibility', 'sortOrder', 'autoGroupDomain', 'updatedAt'
          ])
        ) && (
          // SECURITY: Immutable fields cannot change (createdAt check is conditional for legacy docs)
          fieldUnchanged('createdBy') && fieldUnchanged('teamId') &&
          (!('createdAt' in resource.data) || fieldUnchanged('createdAt'))
        ) && (
          // Visibility must stay in allowed set if provided
          request.resource.data.title is string &&
          request.resource.data.title.size() > 0 &&
          request.resource.data.title.size() <= 100 &&
          (!('visibility' in request.resource.data) || request.resource.data.visibility in ['team', 'private'])
        );

        // Delete: creator or admin
        allow delete: if isAdmin(teamId) ||
          (isMemberInTeam(teamId) && resource.data.createdBy == request.auth.uid);

        // Links within groups - inherit parent group visibility
        match /links/{linkId} {
          // Helper to check if parent group exists (reliability guard)
          function parentGroupExists() {
            return exists(/databases/$(database)/documents/teams/$(teamId)/linkLobbyGroups/$(groupId));
          }
          
          // Helper to get parent group data (only call after exists check)
          function getParentGroup() {
            return get(/databases/$(database)/documents/teams/$(teamId)/linkLobbyGroups/$(groupId)).data;
          }
          
          // Read: check parent group visibility (with existence guard)
          allow read: if isMemberInTeam(teamId) 
            && parentGroupExists()
            && (
              getParentGroup().visibility == 'team' ||
              !('visibility' in getParentGroup()) ||
              (getParentGroup().visibility == 'private' && getParentGroup().createdBy == request.auth.uid)
            );

          // Create: check parent group visibility for non-creators (with existence guard)
          // SECURITY: Validate URL length
          allow create: if isMemberInTeam(teamId) 
            && request.resource.data.createdBy == request.auth.uid
            && parentGroupExists()
            && (
              getParentGroup().visibility != 'private' ||
              !('visibility' in getParentGroup()) ||
              getParentGroup().createdBy == request.auth.uid
            )
            && request.resource.data.keys().hasOnly([
              'createdBy', 'url', 'title', 'description', 'domain',
              'favicon', 'favorite', 'createdAt', 'updatedAt'
            ])
            && request.resource.data.url is string
            && request.resource.data.url.size() > 0
            && request.resource.data.url.size() <= 2048
            && (!('title' in request.resource.data) || 
                (request.resource.data.title is string && request.resource.data.title.size() <= 500))
            && (!('description' in request.resource.data) || 
                (request.resource.data.description is string && request.resource.data.description.size() <= 1000));

          // Update: creator of link, or anyone if group is not private (with existence guard)
          // SECURITY: Schema validation on UPDATE using affectedKeys (allows legacy fields to exist)
          allow update: if isMemberInTeam(teamId) 
            && parentGroupExists()
            && (
              resource.data.createdBy == request.auth.uid ||
              getParentGroup().visibility != 'private' ||
              !('visibility' in getParentGroup())
            )
            // SECURITY: Only validate CHANGED fields (affectedKeys), not entire doc
            && request.resource.data.diff(resource.data).affectedKeys().hasOnly([
              'url', 'title', 'description', 'domain', 'favicon', 'favorite', 'updatedAt'
            ])
            // SECURITY: Immutable fields cannot change
            && fieldUnchanged('createdBy') && fieldUnchanged('createdAt')
            && request.resource.data.url is string
            && request.resource.data.url.size() > 0
            && request.resource.data.url.size() <= 2048
            && (!('title' in request.resource.data) || 
                (request.resource.data.title is string && request.resource.data.title.size() <= 500))
            && (!('description' in request.resource.data) || 
                (request.resource.data.description is string && request.resource.data.description.size() <= 1000));

          // Delete: link creator or admin
          allow delete: if isMemberInTeam(teamId) && (
            isAdmin(teamId) ||
            resource.data.createdBy == request.auth.uid
          );
        }
      }

      // ==========================
      // TRANSACTIONS SUBCOLLECTION (Finances Tab)
      // SECURITY: Schema validation + amount bounds
      // ==========================
      match /transactions/{transactionId} {
        // Helper to safely get finances visibility setting (with guards)
        function getFinancesVisibility() {
          let teamData = getTeamData(teamId);
          // Guard: check if settings and financesVisibility exist
          return ('settings' in teamData && 'financesVisibility' in teamData.settings)
            ? teamData.settings.financesVisibility
            : 'owner-only';  // Conservative default
        }

        // Helper to check if user can access finances (safe version)
        function canAccessFinances() {
          let role = getMemberRole(teamId);
          let visibility = getFinancesVisibility();
          return role == 'owner' ||
            (role == 'admin' && visibility in ['admin-owner', 'everyone']) ||
            (role == 'member' && visibility == 'everyone');
        }

        // Read: based on finances visibility settings
        allow read: if isMemberInTeam(teamId) && canAccessFinances();

        // Create: must have access and createdBy must match
        // SECURITY: Validate schema, amount bounds, teamId
        allow create: if isMemberInTeam(teamId) 
          && canAccessFinances()
          && request.resource.data.createdBy == request.auth.uid
          && request.resource.data.keys().hasOnly([
            'createdBy', 'teamId', 'amount', 'type', 'category', 'note',
            'date', 'createdAt', 'updatedAt', 'createdByName',
            'description', 'party', 'isRecurring', 'frequency', 'notes'
          ])
          && (!('teamId' in request.resource.data) || request.resource.data.teamId == teamId)
          && request.resource.data.type in ['income', 'expense']
          && request.resource.data.amount is number
          && request.resource.data.amount >= 0
          && request.resource.data.amount <= 999999999
          && (!('note' in request.resource.data) || 
              (request.resource.data.note is string && request.resource.data.note.size() <= 500))
          && (!('description' in request.resource.data) || 
              (request.resource.data.description is string && request.resource.data.description.size() <= 500))
          && (!('party' in request.resource.data) || 
              (request.resource.data.party is string && request.resource.data.party.size() <= 200))
          && (!('notes' in request.resource.data) || 
              (request.resource.data.notes is string && request.resource.data.notes.size() <= 1000))
          && (!('frequency' in request.resource.data) || 
              (request.resource.data.frequency is string && request.resource.data.frequency in ['daily', 'weekly', 'monthly', 'yearly', '']))
          && (!('isRecurring' in request.resource.data) || 
              request.resource.data.isRecurring is bool);

        // Update: creator or admin/owner with access
        // SECURITY: Schema validation on UPDATE using affectedKeys (allows legacy fields to exist)
        allow update: if isMemberInTeam(teamId) && (
          (getMemberRole(teamId) == 'owner') ||
          (getMemberRole(teamId) == 'admin' && getFinancesVisibility() in ['admin-owner', 'everyone']) ||
          resource.data.createdBy == request.auth.uid
        ) && (
          // SECURITY: Only validate CHANGED fields (affectedKeys), not entire doc
          request.resource.data.diff(resource.data).affectedKeys().hasOnly([
            'amount', 'type', 'category', 'note', 'date', 'updatedAt', 'createdByName',
            'description', 'party', 'isRecurring', 'frequency', 'notes'
          ])
        ) && (
          // SECURITY: Immutable fields cannot change (conditional for legacy docs)
          fieldUnchanged('createdBy') &&
          (!('teamId' in resource.data) || fieldUnchanged('teamId')) &&
          fieldUnchanged('createdAt')
        ) && (
          request.resource.data.amount is number &&
          request.resource.data.amount >= 0 &&
          request.resource.data.amount <= 999999999 &&
          request.resource.data.type in ['income', 'expense'] &&
          (!('note' in request.resource.data) || 
              (request.resource.data.note is string && request.resource.data.note.size() <= 500)) &&
          (!('description' in request.resource.data) || 
              (request.resource.data.description is string && request.resource.data.description.size() <= 500)) &&
          (!('party' in request.resource.data) || 
              (request.resource.data.party is string && request.resource.data.party.size() <= 200)) &&
          (!('notes' in request.resource.data) || 
              (request.resource.data.notes is string && request.resource.data.notes.size() <= 1000)) &&
          (!('frequency' in request.resource.data) || 
              (request.resource.data.frequency is string && request.resource.data.frequency in ['daily', 'weekly', 'monthly', 'yearly', ''])) &&
          (!('isRecurring' in request.resource.data) || 
              request.resource.data.isRecurring is bool)
        );

        // Delete: creator or admin/owner with access
        allow delete: if isMemberInTeam(teamId) && (
          (getMemberRole(teamId) == 'owner') ||
          (getMemberRole(teamId) == 'admin' && getFinancesVisibility() in ['admin-owner', 'everyone']) ||
          resource.data.createdBy == request.auth.uid
        );
      }
    }

    // ============================
    // TEAM JOIN INFO (PUBLIC)
    // Limited info for join flow - does NOT expose members
    // ============================
    match /teamJoinInfo/{teamCode} {
      // Any authenticated user can read join info (for join by code)
      allow read: if request.auth != null;

      // Only admins/owners can create/update join info
      allow create: if request.auth != null
        && request.resource.data.teamId != null
        && isMemberInTeam(request.resource.data.teamId)
        && isAdmin(request.resource.data.teamId)
        && request.resource.data.keys().hasOnly(['teamId', 'teamName', 'memberCount', 'createdAt', 'updatedAt']);

      allow update: if request.auth != null
        && isMemberInTeam(resource.data.teamId)
        && isAdmin(resource.data.teamId)
        // SECURITY: Only validate CHANGED fields (affectedKeys), not entire doc
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['teamName', 'memberCount', 'updatedAt'])
        && fieldUnchanged('teamId')
        && (!('createdAt' in resource.data) || fieldUnchanged('createdAt'));

      allow delete: if request.auth != null
        && isMemberInTeam(resource.data.teamId)
        && isOwner(resource.data.teamId);
    }

    // ============================
    // LEGACY / UNUSED JOIN REQUESTS
    // ============================
    match /joinRequests/{requestId} {
      // Lock this collection down
      allow read, write: if false;
    }

    // ============================
    // TEAM INVITATIONS
    // SECURITY: Strict field whitelisting to prevent data injection
    // ============================
    match /teamInvitations/{invitationId} {
      // Create invitation:
      // - Authenticated, admin/owner of team
      // - status = 'pending', expiresAt in future
      // - token must be cryptographically secure (min 32 chars)
      // - SECURITY: Only whitelisted fields allowed
      allow create: if request.auth != null
        && request.resource.data.keys().hasOnly([
          'teamId', 'teamName', 'invitedBy', 'invitedByName', 'invitedEmail', 
          'token', 'status', 'expiresAt', 'createdAt', 'role'
        ])
        && request.resource.data.invitedBy == request.auth.uid
        && isMemberInTeam(request.resource.data.teamId)
        && isAdmin(request.resource.data.teamId)
        && request.resource.data.status == 'pending'
        && request.resource.data.expiresAt > request.time
        && request.resource.data.token is string
        && request.resource.data.token.size() >= 32
        && request.resource.data.invitedEmail is string
        && request.resource.data.invitedEmail.size() <= 254;

      // Read invitation:
      // - Inviter can read
      // - Invited user (by email) can read
      allow read: if request.auth != null &&
        (
          resource.data.invitedBy == request.auth.uid ||
          resource.data.invitedEmail == request.auth.token.email
        );

      // Update invitation:
      // - Only invited user by email
      // - Only when status is 'pending'
      // - Only allowed to change status to 'used' or 'accepted'
      // - SECURITY: All other fields must remain unchanged
      // - Invitation must not be expired
      allow update: if request.auth != null
        && resource.data.invitedEmail == request.auth.token.email
        && resource.data.status == 'pending'
        && request.time < resource.data.expiresAt
        // Only status field can change
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status'])
        && request.resource.data.status in ['used', 'accepted'];

      // Delete invitation: only admins/owners for that team
      allow delete: if request.auth != null
        && isAdmin(resource.data.teamId);
    }
  }
}