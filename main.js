// ===================================
// TEAMSTER ROUTING SYSTEM
// Handles: / (homepage), /app (main app), /home -> redirect to /
// Lazy-loads homepage bundle from /home/
// ===================================

/**
 * Current route state
 * 'home' = marketing homepage (public)
 * 'app' = main Teamster application (requires auth)
 */
let currentRoute = 'app'; // default to app for existing behavior

/**
 * Homepage bundle state
 */
let homeLoaded = false;
let homeCleanup = null;
let homeStylesheet = null;

/**
 * Load the homepage bundle (CSS, HTML, JS)
 * @returns {Promise<void>}
 */
async function loadHomeBundle() {
    const homeMount = document.getElementById('homeMount');
    if (!homeMount) return;

    // Already loaded
    if (homeLoaded && homeMount.innerHTML) {
        homeMount.style.display = 'block';
        return;
    }

    try {
        // 1. Load CSS if not already loaded
        if (!homeStylesheet) {
            homeStylesheet = document.createElement('link');
            homeStylesheet.rel = 'stylesheet';
            homeStylesheet.href = '/home/home.css?v=' + (window.APP_VERSION || Date.now());
            homeStylesheet.id = 'home-stylesheet';
            document.head.appendChild(homeStylesheet);
            
            // Wait for CSS to load
            await new Promise((resolve, reject) => {
                homeStylesheet.onload = resolve;
                homeStylesheet.onerror = reject;
                setTimeout(resolve, 1000); // Fallback timeout
            });
        }

        // 2. Load HTML
        const response = await fetch('/home/home.html?v=' + (window.APP_VERSION || Date.now()));
        if (!response.ok) throw new Error('Failed to load homepage HTML');
        const html = await response.text();
        homeMount.innerHTML = html;
        homeMount.style.display = 'block';

        // 3. Load and initialize JS module
        const homeModule = await import('/home/home.js?v=' + (window.APP_VERSION || Date.now()));
        if (homeModule.initHome) {
            homeCleanup = homeModule.initHome();
        }

        homeLoaded = true;
    } catch (error) {
        console.error('Failed to load homepage bundle:', error);
        // Fallback: show app instead
        showAppContainer();
    }
}

/**
 * Unload the homepage bundle (cleanup + hide)
 */
function unloadHomeBundle() {
    const homeMount = document.getElementById('homeMount');
    
    // Run cleanup function if it exists
    if (homeCleanup && typeof homeCleanup === 'function') {
        homeCleanup();
        homeCleanup = null;
    }
    
    // Hide mount point (keep HTML for faster re-show)
    if (homeMount) {
        homeMount.style.display = 'none';
    }
}

/**
 * Initialize routing based on current URL path
 * Called BEFORE Firebase auth to properly show homepage without auth redirect
 */
function initializeRouting() {
    const path = window.location.pathname;
    const hash = window.location.hash;
    
    // GITHUB PAGES SPA REDIRECT HANDLER
    // Check if we were redirected from 404.html and restore the original path
    const ghRedirect = sessionStorage.getItem('ghPagesRedirect');
    if (ghRedirect) {
        sessionStorage.removeItem('ghPagesRedirect');
        try {
            const redirectData = JSON.parse(ghRedirect);
            const originalPath = redirectData.path || '';
            const originalHash = redirectData.hash || '';
            
            // Determine route from the original path
            if (originalPath.includes('/app') || originalPath === '/app' || originalPath === '/app/') {
                window.history.replaceState({}, '', originalHash || '#/app');
                currentRoute = 'app';
                showAppContainer();
                return 'app';
            }
            
            if (originalPath.includes('/home') || originalPath === '/home') {
                window.history.replaceState({}, '', originalHash || '#/home');
                currentRoute = 'home';
                showHomePage();
                return 'home';
            }
            
            // For other paths like /account, /team - just go to app
            // Those pages have their own HTML files
            window.history.replaceState({}, '', '#/app');
            currentRoute = 'app';
            showAppContainer();
            return 'app';
        } catch (e) {
            console.warn('Failed to parse GitHub Pages redirect data:', e);
        }
    }
    
    // PREVENT INFINITE LOOP: If we already have a valid hash route, don't re-process
    if (hash === '#/app' || hash === '#app') {
        currentRoute = 'app';
        showAppContainer();
        return 'app';
    }
    
    if (hash === '#/home' || hash === '#home') {
        currentRoute = 'home';
        showHomePage();
        return 'home';
    }
    
    // GITHUB PAGES / STATIC HOST DETECTION
    // GitHub Pages and static hosts don't support server-side routing
    // Use hash-based routing for compatibility
    const isStaticHost = window.location.hostname.includes('github.io') || 
                        window.location.hostname.includes('gitlab.io') ||
                        window.location.hostname.includes('netlify.app') ||
                        window.location.hostname.includes('vercel.app') ||
                        window.location.hostname.includes('teamsterx.com');
    
    // LOCAL DEVELOPMENT FALLBACK
    const isLocalhost = window.location.hostname === 'localhost' || 
                       window.location.hostname === '127.0.0.1' ||
                       window.location.hostname === '';
    
    // IMPORTANT: Extract join parameter BEFORE any early returns
    // This ensures join links work on all hosts including static hosts
    const urlParams = new URLSearchParams(window.location.search);
    const joinCode = urlParams.get('join');
    if (joinCode) {
        console.log('ðŸ“¨ Join code detected:', joinCode);
        sessionStorage.setItem('pendingJoinCode', joinCode);
    }
    
    // For static hosts, if no hash, default to app and update hash
    if (isStaticHost && !hash) {
        window.history.replaceState({}, '', window.location.pathname + '#/app');
        currentRoute = 'app';
        showAppContainer();
        return 'app';
    }

    // LOCAL DEVELOPMENT: Handle query params and paths
    if (isLocalhost) {
        const route = urlParams.get('route');
        
        if (route === 'app' || path === '/app' || path === '/app/') {
            window.history.replaceState({}, '', '#/app');
            currentRoute = 'app';
            showAppContainer();
            return 'app';
        }
        
        if (route === 'home' || path === '/home' || path === '/home/') {
            window.history.replaceState({}, '', '#/home');
            currentRoute = 'home';
            showHomePage();
            return 'home';
        }
    }
    
    // Handle /app path for servers that support server-side routing
    if (path === '/app' || path === '/app/' || path.startsWith('/app/')) {
        window.history.replaceState({}, '', window.location.pathname + '#/app');
        currentRoute = 'app';
        showAppContainer();
        return 'app';
    }
    
    // Handle root path - show app
    if (path === '/' || path === '' || path === '/index.html' || path.endsWith('/Teamster/')) {
        window.history.replaceState({}, '', window.location.pathname + '#/app');
        currentRoute = 'app';
        showAppContainer();
        return 'app';
    }
    
    // Default fallback: show app
    window.history.replaceState({}, '', window.location.pathname + '#/app');
    currentRoute = 'app';
    showAppContainer();
    return 'app';
}

/**
 * Show the marketing homepage, hide the app
 */
async function showHomePage() {
    const appContainer = document.getElementById('appContainer');
    const bottomNav = document.querySelector('.mobile-bottom-nav');
    
    // Hide app elements
    if (appContainer) appContainer.style.display = 'none';
    if (bottomNav) bottomNav.style.display = 'none';
    
    // Load and show homepage bundle
    await loadHomeBundle();
    
    // Update page title
    document.title = 'Teamsterx - Work better, together';
}

/**
 * Show the main app, hide the homepage
 */
function showAppContainer() {
    const appContainer = document.getElementById('appContainer');
    
    // Unload homepage bundle
    unloadHomeBundle();
    
    // Show app
    if (appContainer) appContainer.style.display = '';
    
    // Update page title
    document.title = 'Teamsterx - Internal Collaboration Platform';
}

/**
 * Navigate to the app (used by CTAs and after auth)
 */
function navigateToApp() {
    // Use hash-based routing for GitHub Pages compatibility
    window.history.pushState({}, '', '#/app');
    currentRoute = 'app';
    showAppContainer();
}

/**
 * Navigate to the homepage (TEMPORARILY redirects to app - homepage disabled)
 */
function navigateToHome() {
    // TEMPORARY: Redirect to app instead of showing homepage
    // Use hash-based routing for GitHub Pages compatibility
    navigateToApp();
}

/**
 * Handle browser back/forward navigation
 */
window.addEventListener('popstate', () => {
    initializeRouting();
});

/**
 * Handle hash changes for hash-based routing
 */
window.addEventListener('hashchange', () => {
    initializeRouting();
});

// Initialize routing immediately when script loads (before DOMContentLoaded)
// This prevents flash of wrong content
(function() {
    // Wait for DOM elements to exist
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            initializeRouting();
        }, { once: true });
    } else {
        initializeRouting();
    }
})();

// ===================================
// FIREBASE CONFIGURATION
// ===================================
/**
 * SECURITY NOTE:
 * Firebase Web API keys are PUBLIC IDENTIFIERS, NOT secrets.
 * Security is enforced via Firestore/Storage rules and API key restrictions.
 * Never place service account credentials or admin keys in frontend code.
 * See SECURITY.md for detailed documentation.
 */
const firebaseConfig = {
    apiKey: (typeof window !== 'undefined' && window.__ENV__?.VITE_FIREBASE_API_KEY) || "AIzaSyBsV-g9DBRTCE9sk1bsYy4TRsohAETF7vg",
    authDomain: (typeof window !== 'undefined' && window.__ENV__?.VITE_FIREBASE_AUTH_DOMAIN) || "teamhub-bf61f.firebaseapp.com",
    projectId: (typeof window !== 'undefined' && window.__ENV__?.VITE_FIREBASE_PROJECT_ID) || "teamhub-bf61f",
    storageBucket: (typeof window !== 'undefined' && window.__ENV__?.VITE_FIREBASE_STORAGE_BUCKET) || "teamhub-bf61f.firebasestorage.app",
    messagingSenderId: (typeof window !== 'undefined' && window.__ENV__?.VITE_FIREBASE_MESSAGING_SENDER_ID) || "186552753103",
    appId: (typeof window !== 'undefined' && window.__ENV__?.VITE_FIREBASE_APP_ID) || "1:186552753103:web:4a102aa3b91aa71c4150ba",
    measurementId: (typeof window !== 'undefined' && window.__ENV__?.VITE_FIREBASE_MEASUREMENT_ID) || "G-1VH5ZLCH63"
};

// Initialize Firebase
let db, auth;
let currentAuthUser = null;

// Debug flag - set to true only during development
const DEBUG = false;

// ===================================
// DEBUG_PERMS FLAG - Enable verbose permission debugging
// Set to true to log Firestore write details (paths, keys, payloads)
// ===================================
const DEBUG_PERMS = false;  // DISABLED for production - prevents logging UIDs, paths, doc IDs

// ===================================
// UNIFIED FLOATING MENU SYSTEM
// Reusable helper for all menus/popovers: position, click-away, Escape, toggle
// ===================================
const floatingMenuState = {
    activeMenu: null,
    activeAnchor: null,
    clickHandler: null,
    keyHandler: null
};

/**
 * Close the currently active floating menu
 */
function closeFloatingMenu() {
    if (floatingMenuState.activeMenu) {
        floatingMenuState.activeMenu.style.display = 'none';
        floatingMenuState.activeMenu.classList.remove('visible');
    }
    if (floatingMenuState.clickHandler) {
        document.removeEventListener('click', floatingMenuState.clickHandler, true);
        floatingMenuState.clickHandler = null;
    }
    if (floatingMenuState.keyHandler) {
        document.removeEventListener('keydown', floatingMenuState.keyHandler);
        floatingMenuState.keyHandler = null;
    }
    floatingMenuState.activeMenu = null;
    floatingMenuState.activeAnchor = null;
}

/**
 * Open a floating menu, positioned relative to anchor, clamped to viewport
 * @param {HTMLElement} menuEl - The menu element
 * @param {HTMLElement|DOMRect} anchor - The anchor element or rect (e.g., from caret)
 * @param {Object} opts - Options: { margin: number, preferAbove: boolean, onClose: function }
 */
function openFloatingMenu(menuEl, anchor, opts = {}) {
    const margin = opts.margin ?? 10;
    
    // Close any existing menu first
    closeFloatingMenu();
    
    // Show menu to measure its actual size
    menuEl.style.display = 'block';
    menuEl.style.position = 'fixed';
    menuEl.style.visibility = 'hidden'; // Hide while measuring
    menuEl.classList.add('visible');
    
    // Get actual dimensions after display
    const menuRect = menuEl.getBoundingClientRect();
    const anchorRect = anchor instanceof DOMRect ? anchor : anchor.getBoundingClientRect();
    
    // Calculate position
    let top, left;
    
    // Horizontal position: prefer left-aligned with anchor, clamp to viewport
    left = anchorRect.left;
    if (left + menuRect.width > window.innerWidth - margin) {
        left = window.innerWidth - menuRect.width - margin;
    }
    if (left < margin) left = margin;
    
    // Vertical position: prefer below anchor, flip above if needed
    const spaceBelow = window.innerHeight - anchorRect.bottom - margin;
    const spaceAbove = anchorRect.top - margin;
    
    if (opts.preferAbove && spaceAbove >= menuRect.height) {
        top = anchorRect.top - menuRect.height - 4;
    } else if (spaceBelow >= menuRect.height) {
        top = anchorRect.bottom + 4;
    } else if (spaceAbove >= menuRect.height) {
        top = anchorRect.top - menuRect.height - 4;
    } else {
        // Not enough space either way, clamp to viewport
        top = Math.min(anchorRect.bottom + 4, window.innerHeight - menuRect.height - margin);
    }
    if (top < margin) top = margin;
    
    // Apply position
    menuEl.style.top = top + 'px';
    menuEl.style.left = left + 'px';
    menuEl.style.zIndex = '10001';
    menuEl.style.visibility = 'visible';
    
    // Store state
    floatingMenuState.activeMenu = menuEl;
    floatingMenuState.activeAnchor = anchor instanceof DOMRect ? null : anchor;
    
    // Click-away handler (use capture to catch clicks before they bubble)
    floatingMenuState.clickHandler = (e) => {
        // Allow clicks inside menu
        if (menuEl.contains(e.target)) return;
        // Allow clicks on anchor (for toggle behavior)
        if (floatingMenuState.activeAnchor && floatingMenuState.activeAnchor.contains(e.target)) return;
        closeFloatingMenu();
        if (opts.onClose) opts.onClose();
    };
    
    // Escape handler
    floatingMenuState.keyHandler = (e) => {
        if (e.key === 'Escape') {
            e.preventDefault();
            closeFloatingMenu();
            if (opts.onClose) opts.onClose();
        }
    };
    
    // Delay adding listeners to avoid immediate close from the opening click
    setTimeout(() => {
        document.addEventListener('click', floatingMenuState.clickHandler, true);
        document.addEventListener('keydown', floatingMenuState.keyHandler);
    }, 0);
}

/**
 * Toggle a floating menu (open if closed, close if open)
 */
function toggleFloatingMenu(menuEl, anchor, opts = {}) {
    if (floatingMenuState.activeMenu === menuEl) {
        closeFloatingMenu();
    } else {
        openFloatingMenu(menuEl, anchor, opts);
    }
}

// ===================================
// RUNTIME CONFIGURATION VALIDATION
// ===================================
/**
 * Validates Firebase configuration before initialization.
 * Prevents silent failures by failing loudly with clear error messages.
 * This makes misconfiguration immediately obvious in development.
 */
function assertFirebaseConfig(cfg) {
    const requiredKeys = ['apiKey', 'authDomain', 'projectId', 'storageBucket', 'messagingSenderId', 'appId'];
    const missing = requiredKeys.filter(key => !cfg[key] || cfg[key].includes('your-') || cfg[key].includes('your_'));
    
    if (missing.length > 0) {
        const errorMsg = `
ðŸš¨ FIREBASE CONFIGURATION ERROR ðŸš¨
Missing or invalid keys: ${missing.join(', ')}

Fix:
  1. Copy .env.example to .env
  2. Fill in Firebase config from Firebase Console
  3. Restart dev server

See SECURITY.md for detailed instructions.
        `.trim();
        console.error(errorMsg);
        throw new Error(`Invalid Firebase configuration. Missing: ${missing.join(', ')}`);
    }
    
    if (typeof window !== 'undefined' && window.location.hostname !== 'localhost' && cfg.authDomain?.includes('localhost')) {
        console.warn('âš ï¸ [SECURITY] Production site using localhost config. Check environment variables.');
    }
    
    if (DEBUG || DEBUG_PERMS) {
        console.log('âœ… Firebase configuration validated');
    }
}

// Validate before initializing
assertFirebaseConfig(firebaseConfig);

// ===================================
// FIRESTORE ERROR LOGGER HELPER
// Centralized logging for permission-denied and other Firestore errors
// ===================================
// ===================================
// ENHANCED FIRESTORE ERROR LOGGER
// ===================================
// This comprehensive logger provides detailed diagnostics for permission-denied errors:
// - Fetches and displays the ACTUAL Firestore document (resource.data)
// - Shows the MERGED document after applying updates (request.resource.data)
// - Field-by-field comparison showing what changed
// - Auth context with permission checks (creator match, role validation)
// - Color-coded output for quick visual scanning
// - Helps diagnose EXACTLY which Firestore rule condition failed
//
// FIXES APPLIED (v=48):
// - Added missing task fields: budget, spreadsheetId, showOnCalendar
// - Made teamId validation conditional for legacy tasks (like title)
// - Made teamId IMMUTABILITY checks conditional across ALL collections:
//   * Tasks: (!('teamId' in resource.data) || fieldUnchanged('teamId'))
//   * Events: Same conditional check
//   * Spreadsheets: Same conditional check
//   * LinkLobbyGroups: Same conditional check
//   * Transactions: Same conditional check
//   * TeamJoinInfo: Made createdAt check conditional too
// - This allows updates to legacy docs created before teamId was added
// - Enhanced diagnostics to show actual vs merged document state
// ===================================

async function logFirestoreError(op, path, payload, extraContext, error) {
    const isPermDenied = error?.code === 'permission-denied';
    const prefix = isPermDenied ? 'ðŸ”’ [PERMISSION-DENIED]' : 'âŒ [FIRESTORE ERROR]';
    
    // Truncate large arrays in payload for readability
    const truncateValue = (val) => {
        if (Array.isArray(val) && val.length > 5) {
            return `[Array(${val.length}): ${JSON.stringify(val.slice(0, 3))}... +${val.length - 3} more]`;
        }
        if (typeof val === 'object' && val !== null) {
            const keys = Object.keys(val);
            if (keys.length > 10) {
                return `{Object with ${keys.length} keys: ${keys.slice(0, 5).join(', ')}...}`;
            }
        }
        return val;
    };
    
    const payloadPreview = {};
    if (payload && typeof payload === 'object') {
        for (const [k, v] of Object.entries(payload)) {
            payloadPreview[k] = truncateValue(v);
        }
    }
    
    // For permission-denied on UPDATE, try to fetch the ACTUAL document to diagnose
    let actualDocData = null;
    let mergedDocData = null;
    if (isPermDenied && path && !path.includes('<new>') && db) {
        try {
            const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
            const docRef = doc(db, ...path.split('/'));
            const docSnap = await getDoc(docRef);
            if (docSnap.exists()) {
                actualDocData = docSnap.data();
                // Simulate what merged doc would look like
                mergedDocData = { ...actualDocData, ...payload };
            }
        } catch (fetchErr) {
            console.warn('âš ï¸ Could not fetch document for diagnosis:', fetchErr.message);
        }
    }
    
    console.group(`${prefix} ${op}`);
    console.log('%câ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'color: #ff4444; font-weight: bold');
    console.log('%cðŸ“ OPERATION:', 'color: #ff8800; font-weight: bold', op);
    console.log('%cðŸ“‚ PATH:', 'color: #ff8800; font-weight: bold', path);
    console.log('%cðŸš« ERROR CODE:', 'color: #ff0000; font-weight: bold', error?.code || 'unknown');
    console.log('%cðŸ’¬ ERROR MESSAGE:', 'color: #ff0000; font-weight: bold', error?.message || String(error));
    console.log('%câ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'color: #ff4444; font-weight: bold');
    console.log('%cðŸ“¦ PAYLOAD KEYS:', 'color: #00aaff; font-weight: bold', payload ? Object.keys(payload) : 'N/A');
    console.log('%cðŸ“¦ PAYLOAD DATA:', 'color: #00aaff; font-weight: bold', payloadPreview);
    
    if (actualDocData) {
        console.log('%câ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'color: #ffaa00; font-weight: bold');
        console.log('%cðŸ“„ ACTUAL FIRESTORE DOC (resource.data):', 'color: #ffaa00; font-weight: bold');
        console.log('Keys:', Object.keys(actualDocData));
        console.log('Data:', actualDocData);
        console.log('%cðŸ”€ MERGED DOC (request.resource.data):', 'color: #aa00ff; font-weight: bold');
        console.log('Keys:', Object.keys(mergedDocData));
        console.log('Data:', mergedDocData);
        console.log('%cðŸ” FIELD COMPARISON:', 'color: #00ff88; font-weight: bold');
        console.log('â€¢ teamId:', { before: actualDocData.teamId, after: mergedDocData.teamId, hasField: 'teamId' in mergedDocData });
        console.log('â€¢ title:', { before: actualDocData.title, after: mergedDocData.title, hasField: 'title' in mergedDocData });
        console.log('â€¢ createdBy:', { before: actualDocData.createdBy, after: mergedDocData.createdBy, unchanged: actualDocData.createdBy === mergedDocData.createdBy });
        console.log('â€¢ createdAt:', { before: actualDocData.createdAt, after: mergedDocData.createdAt, hasInOld: 'createdAt' in actualDocData });
    }
    
    console.log('%câ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'color: #00ff00; font-weight: bold');
    if (extraContext) {
        console.log('%cðŸ” AUTH CONTEXT:', 'color: #00ff00; font-weight: bold', extraContext);
        if (isPermDenied && extraContext.taskCreatedBy && extraContext.uid) {
            console.log('%câœ… Creator Match:', 'color: ' + (extraContext.taskCreatedBy === extraContext.uid ? '#00ff00' : '#ff0000') + '; font-weight: bold', 
                extraContext.taskCreatedBy === extraContext.uid ? 'YES' : 'NO',
                `(${extraContext.uid} ${extraContext.taskCreatedBy === extraContext.uid ? '===' : '!=='} ${extraContext.taskCreatedBy})`);
        }
        if (isPermDenied && extraContext.userRole) {
            console.log('%cðŸ‘‘ User Role:', 'color: #ffaa00; font-weight: bold', extraContext.userRole,
                '(Admin check:', ['admin', 'owner'].includes(extraContext.userRole) ? 'PASS' : 'FAIL' + ')');
        }
    }
    console.log('%câ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'color: #ff4444; font-weight: bold');
    
    if (error?.stack) {
        console.log('%cðŸ“š STACK TRACE:', 'color: #888; font-style: italic');
        console.log(error.stack);
    }
    console.groupEnd();
    
    // Also log a one-liner for quick scanning
    console.error(`${prefix} ${op} @ ${path} | keys=[${payload ? Object.keys(payload).join(',') : ''}] | ${error?.code}: ${error?.message}`);
}

// ===================================
// EARLY GLOBAL FUNCTIONS (must be defined before DOM loads)
// ===================================
window.generateJoinLink = function() {
    if (!appState?.currentTeamData?.teamCode) {
        showToast('No team code available', 'error');
        return;
    }
    const baseUrl = window.location.origin;
    const joinUrl = `${baseUrl}/app?join=${appState.currentTeamData.teamCode}`;
    
    navigator.clipboard.writeText(joinUrl).then(() => {
        showToast('Join link copied to clipboard!', 'success');
    }).catch(() => {
        // Show link in toast with longer duration
        showToast('Copy this join link: ' + joinUrl, 'info', 10000);
    });
};

// ===================================
// TABLE PRESETS
// ===================================
const TASKS_TABLE_PRESET = {
    columns: ['title', 'status', 'assignee', 'priority', 'dueDate', 'progress'],
    columnSettings: {
        status: {
            options: [
                { label: 'To Do', color: '#8E8E93' },
                { label: 'In Progress', color: '#007AFF' },
                { label: 'Done', color: '#34C759' }
            ]
        },
        priority: {
            options: [
                { label: 'Low', color: '#34C759' },
                { label: 'Medium', color: '#FF9500' },
                { label: 'High', color: '#FF3B30' }
            ]
        }
    }
};

const LEADS_TABLE_PRESET = {
    columns: ['leadName', 'status', 'source', 'value', 'contact', 'createdAt', 'notes'],
    columnSettings: {
        status: {
            options: [
                { label: 'New', color: '#007AFF' },
                { label: 'Contacted', color: '#5856D6' },
                { label: 'Qualified', color: '#FF9500' },
                { label: 'Won', color: '#34C759' },
                { label: 'Lost', color: '#FF3B30' }
            ]
        },
        source: {
            options: [
                { label: 'Website', color: '#007AFF' },
                { label: 'Referral', color: '#34C759' },
                { label: 'Ad Campaign', color: '#FF9500' },
                { label: 'Social Media', color: '#5856D6' },
                { label: 'Other', color: '#8E8E93' }
            ]
        }
    }
};

// Debug helper functions
function debugLog(...args) {
    if (DEBUG) {
        console.log(...args);
    }
}

function debugError(...args) {
    if (DEBUG) {
        console.error(...args);
    }
}

// ===================================
// EARLY THEME SUPPORT
// Apply theme immediately on page load from localStorage
// Supports 'system', 'light', 'dark' preferences
// ===================================

/**
 * Check if user prefers dark mode based on system settings
 * @returns {boolean} True if system prefers dark mode
 */
function systemPrefersDark() {
    return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
}

/**
 * Resolve the effective theme based on preference
 * @param {string} preference - 'system', 'light', or 'dark'
 * @returns {boolean} True if dark mode should be applied
 */
function resolveTheme(preference) {
    if (preference === 'dark') return true;
    if (preference === 'light') return false;
    // 'system' or unknown - use system preference
    return systemPrefersDark();
}

/**
 * Apply theme immediately on page load
 * Reads from localStorage for instant application before Firestore load
 */
function applyThemeEarly() {
    // First check new theme preference
    let themePreference = localStorage.getItem('themePreference');
    
    // Migrate from old darkMode if present
    if (!themePreference) {
        const oldDarkMode = localStorage.getItem('darkMode');
        if (oldDarkMode === 'true') {
            themePreference = 'dark';
            localStorage.setItem('themePreference', 'dark');
        } else if (oldDarkMode === 'false') {
            themePreference = 'light';
            localStorage.setItem('themePreference', 'light');
        } else {
            themePreference = 'system';
        }
    }
    
    const shouldBeDark = resolveTheme(themePreference);
    if (shouldBeDark) {
        document.body.classList.add('dark-mode');
    } else {
        document.body.classList.remove('dark-mode');
    }

    // Sync browser chrome color with chosen theme
    if (window.__setThemeMeta) {
        window.__setThemeMeta(shouldBeDark);
    }
}

// Helper: hide loader overlay if present
function hideLoaderIfPresent() {
    if (typeof window !== 'undefined' && window.hideLoader) {
        window.hideLoader();
        return;
    }
    const loaderEl = typeof document !== 'undefined' ? document.getElementById('teamsterxLoader') : null;
    if (loaderEl) loaderEl.classList.add('hidden');
}

// Run immediately
applyThemeEarly();

// Listen for system theme changes (when preference is 'system')
if (window.matchMedia) {
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
        const themePreference = localStorage.getItem('themePreference') || 'system';
        if (themePreference === 'system') {
            if (e.matches) {
                document.body.classList.add('dark-mode');
            } else {
                document.body.classList.remove('dark-mode');
            }

            if (window.__setThemeMeta) {
                window.__setThemeMeta(e.matches);
            }
            // Update settings cards if they exist
            document.querySelectorAll('.settings-card').forEach(card => {
                if (e.matches) {
                    card.classList.add('dark-mode');
                } else {
                    card.classList.remove('dark-mode');
                }
            });
        }
    });
}

// ===================================
// PROFILE NORMALIZATION HELPER
// ===================================
/**
 * Normalizes a user profile object to ensure consistent field names.
 * This is the SINGLE SOURCE OF TRUTH for how we build teammate/profile objects.
 * 
 * @param {string} uid - User's UID
 * @param {object} raw - Raw profile data from various sources
 * @returns {object} Normalized profile object
 */
/**
 * Normalize profile data to canonical identity fields.
 * CANONICAL IDENTITY FIELDS:
 * - id: User ID (uid)
 * - displayName: Primary display name (used in mentions, UI, etc.)
 * - name: Alias for displayName (legacy compatibility)
 * - avatarColor: Hex color for avatar background (#RRGGBB format)
 * - email: User email
 * - photoURL, occupation, role: Additional profile fields
 * 
 * IMPORTANT: Always use displayName for all UI rendering and mention operations.
 * The 'name' field exists only for legacy compatibility and should not be preferred.
 */
function normalizeProfile(uid, raw = {}) {
    // Determine display name using canonical resolution order
    let displayName = raw.displayName || raw.name || raw.username || null;
    if (!displayName && raw.email) {
        displayName = raw.email.split('@')[0];
    }
    if (!displayName) {
        displayName = 'Unknown';
    }
    
    // Ensure avatarColor is always a valid hex string
    let avatarColor = raw.avatarColor;
    if (!avatarColor || typeof avatarColor !== 'string' || !avatarColor.startsWith('#')) {
        avatarColor = '#0078D4'; // Default blue
    }
    
    return {
        id: uid,
        displayName: displayName,
        name: displayName, // Alias for legacy UI compatibility
        email: raw.email || null,
        avatarColor: avatarColor,
        photoURL: raw.photoURL || null,
        role: raw.role || 'member',
        occupation: raw.occupation || raw.jobTitle || null,
        joinedAt: raw.joinedAt || null
    };
}

// ===================================
// TASK DATE NORMALIZATION
// ===================================
/**
 * Normalize task date from various formats to a valid Date object.
 * Handles: Firestore Timestamp, milliseconds (number), ISO string, Date object
 * 
 * FIX: Prevents "Invalid Date" bug when creating/displaying tasks
 * 
 * @param {any} dateValue - Date in various formats
 * @returns {Date|null} - Valid Date object or null if invalid
 */
function normalizeTaskDate(dateValue) {
    if (!dateValue) return null;
    
    // Already a Date object
    if (dateValue instanceof Date) {
        return isNaN(dateValue.getTime()) ? null : dateValue;
    }
    
    // Firestore Timestamp (has toDate method)
    if (dateValue && typeof dateValue.toDate === 'function') {
        return dateValue.toDate();
    }
    
    // Firestore Timestamp serialized (has seconds and nanoseconds)
    if (dateValue && typeof dateValue.seconds === 'number') {
        return new Date(dateValue.seconds * 1000);
    }
    
    // Milliseconds timestamp (number)
    if (typeof dateValue === 'number') {
        // Check if it's seconds instead of milliseconds (pre-1970 check)
        if (dateValue < 100000000000) {
            return new Date(dateValue * 1000);
        }
        return new Date(dateValue);
    }
    
    // ISO string or other string format
    if (typeof dateValue === 'string') {
        const parsed = new Date(dateValue);
        return isNaN(parsed.getTime()) ? null : parsed;
    }
    
    return null;
}

/**
 * Calculate the next due date for a recurring task based on frequency
 * @param {Date} currentDueDate - The current due date
 * @param {string} frequency - 'daily', 'weekly', or 'monthly'
 * @param {number} interval - Interval multiplier (default 1)
 * @returns {Date} - Next due date
 */
function calculateNextDueDate(currentDueDate, frequency, interval = 1) {
    const nextDate = new Date(currentDueDate);
    
    switch (frequency) {
        case 'daily':
            nextDate.setDate(nextDate.getDate() + interval);
            break;
        case 'weekly':
            nextDate.setDate(nextDate.getDate() + (7 * interval));
            break;
        case 'monthly':
            nextDate.setMonth(nextDate.getMonth() + interval);
            break;
        default:
            return currentDueDate;
    }
    
    return nextDate;
}

// ===================================
// UNIFIED IDENTITY RESOLVER
// ===================================
/**
 * Get identity (displayName, avatarColor, initials) for any user
 * 
 * This is the SINGLE SOURCE OF TRUTH for resolving teammate identity.
 * Resolution order:
 * 1. publicProfilesById cache (most reliable for OTHER users)
 * 2. teammates array (normalized profile data)
 * 3. team member snapshot from currentTeamData (may be stale)
 * 4. fallbackName (e.g., message.userName snapshot)
 * 5. 'Unknown'
 * 
 * @param {string} uid - User ID to resolve
 * @param {string} fallbackName - Fallback name if no profile found
 * @returns {object} { displayName, avatarColor, photoURL, initials }
 */
function getIdentity(uid, fallbackName = null) {
    // Default values
    let displayName = 'Unknown';
    let avatarColor = '#0078D4';
    let photoURL = null;
    
    if (!uid) {
        // No UID - use fallback only
        displayName = fallbackName || 'Unknown';
    } else {
        // 1. Check publicProfilesById cache (best source for other users)
        const pub = appState.publicProfilesById?.[uid];
        
        // 2. Check teammates array (normalized profiles)
        const teammate = appState.teammates?.find(t => t.id === uid);
        
        // 3. Check team member snapshot (may be stale)
        const member = appState.currentTeamData?.members?.[uid];
        
        // Resolve displayName in priority order
        displayName = 
            pub?.displayName ||
            teammate?.displayName || teammate?.name ||
            member?.displayName || member?.name ||
            fallbackName ||
            'Unknown';
        
        // Resolve avatarColor in priority order
        avatarColor = 
            pub?.avatarColor ||
            teammate?.avatarColor ||
            member?.avatarColor ||
            '#0078D4';
        
        // Resolve photoURL
        photoURL = 
            pub?.photoURL ||
            teammate?.photoURL ||
            member?.photoURL ||
            null;
    }
    
    // Generate initials from displayName
    const initials = generateAvatar(displayName);
    
    return {
        displayName,
        avatarColor,
        photoURL,
        initials
    };
}

/**
 * Load publicProfiles for all team members into cache
 * Called when switching teams or on initial load
 */
async function loadPublicProfilesForTeam() {
    if (!db || !currentAuthUser || !appState.currentTeamId) {
        debugLog('Cannot load public profiles: missing db, auth, or teamId');
        return;
    }
    
    const teamData = appState.currentTeamData;
    if (!teamData?.members) {
        debugLog('No team members to load profiles for');
        return;
    }
    
    const memberUids = Object.keys(teamData.members);
    debugLog(`ðŸ“¥ Loading public profiles for ${memberUids.length} team members...`);
    
    try {
        const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        // Clear existing cache
        appState.publicProfilesById = {};
        
        // Fetch profiles in parallel (with reasonable batch size)
        const profilePromises = memberUids.map(async (uid) => {
            try {
                // Current user: use their own users doc (more complete)
                if (uid === currentAuthUser.uid) {
                    const userRef = doc(db, 'users', uid);
                    const userDoc = await getDoc(userRef);
                    if (userDoc.exists()) {
                        const userData = userDoc.data();
                        return {
                            uid,
                            displayName: userData.displayName || userData.name,
                            avatarColor: userData.avatarColor,
                            photoURL: userData.photoURL,
                            occupation: userData.occupation
                        };
                    }
                }
                
                // Other users: use publicProfiles
                const profileRef = doc(db, 'publicProfiles', uid);
                const profileDoc = await getDoc(profileRef);
                if (profileDoc.exists()) {
                    const data = profileDoc.data();
                    return {
                        uid,
                        displayName: data.displayName,
                        avatarColor: data.avatarColor,
                        photoURL: data.photoURL,
                        occupation: data.occupation
                    };
                }
                return { uid, displayName: null, avatarColor: null };
            } catch (error) {
                // Individual profile fetch failed - continue with others
                debugLog(`Could not load profile for ${uid}:`, error.code || error.message);
                return { uid, displayName: null, avatarColor: null };
            }
        });
        
        const profiles = await Promise.all(profilePromises);
        
        // Store in cache
        profiles.forEach(profile => {
            if (profile.uid) {
                appState.publicProfilesById[profile.uid] = {
                    displayName: profile.displayName,
                    avatarColor: profile.avatarColor,
                    photoURL: profile.photoURL,
                    occupation: profile.occupation
                };
            }
        });
        
        debugLog(`âœ… Loaded ${Object.keys(appState.publicProfilesById).length} public profiles`);
        
    } catch (error) {
        console.error('Error loading public profiles:', error.code || error.message);
    }
}

// ===================================
// ROLE MANAGEMENT HELPERS
// ===================================
function getCurrentUserRole(teamData) {
    const uid = currentAuthUser?.uid;
    if (!uid || !teamData?.members) return 'member';
    return teamData.members[uid]?.role || 'member';
}

function isOwner(teamData) {
    return getCurrentUserRole(teamData) === 'owner';
}

function isAdmin(teamData) {
    const role = getCurrentUserRole(teamData);
    return role === 'owner' || role === 'admin';
}

/**
 * Check if current user has permission for a specific action
 * Finances editing is allowed for owner and admin roles
 */
function hasPermission(action) {
    if (!appState.currentTeamData) return false;
    
    switch (action) {
        case 'editFinances':
        case 'editTasks':
        case 'editCalendar':
            return isAdmin(appState.currentTeamData);
        case 'manageTeam':
        case 'editSettings':
            return isOwner(appState.currentTeamData);
        default:
            return true; // Default to allow
    }
}

// ===================================
// METRICS VISIBILITY HELPERS
// ===================================
/**
 * METRICS FEATURE OVERVIEW
 * ========================
 * 
 * The Metrics tab provides performance insights for users and teams.
 * Access is controlled by a team-level visibility setting that only the
 * owner can change via Settings > Metrics Visibility.
 * 
 * VISIBILITY OPTIONS:
 * - owner-only:   Only team owner sees metrics (full team view)
 * - admin-owner:  Owner + admins see metrics (full team view)
 * - members-own:  Everyone sees metrics, but members only see their own stats
 * - everyone:     Everyone sees full team metrics including member breakdown
 * 
 * ACCESS MODES:
 * - 'none': User cannot access the Metrics tab at all (nav item hidden)
 * - 'self': User sees only their personal stats (no team section)
 * - 'team': User sees both personal and team-wide stats
 * 
 * SECURITY GUARANTEES:
 * 1. Nav item is hidden for users with mode='none' (updateNavVisibilityForMetrics)
 * 2. computePersonalMetrics() always filters by userId - no other user data exposed
 * 3. Team section is only rendered when access.mode === 'team'
 * 4. Member breakdown (names/counts) only shown in 'team' mode
 * 5. Settings card only visible to owner (checked in updateSettingsVisibility)
 * 6. handleMetricsVisibilitySave() validates owner role before Firestore write
 * 7. No new Firestore reads - all metrics computed from existing appState data
 * 
 * DATA FLOW:
 * 1. Team data loads â†’ userCanViewMetrics() computes access
 * 2. Access stored in appState.metricsAccess
 * 3. updateNavVisibilityForMetrics() shows/hides nav based on access
 * 4. renderMetrics() respects access.mode when building HTML
 * 5. Settings change â†’ refreshMetricsAccess() â†’ updates nav + view
 */

/**
 * Get the metrics visibility setting from team data.
 * @param {Object} teamData - The team document data
 * @returns {string} - 'owner-only' | 'admin-owner' | 'members-own' | 'everyone'
 */
function getMetricsVisibilitySetting(teamData) {
    return teamData?.settings?.metricsVisibility || 'owner-only';
}

/**
 * Determine if the current user can view metrics and what mode they have.
 * 
 * SECURITY NOTE: This is the central access control function. Changes here
 * affect who can see the Metrics tab and what data they can view.
 * 
 * @param {Object} teamData - The team document data
 * @param {string} currentUserId - The current user's UID
 * @returns {{ canAccess: boolean, mode: 'none' | 'self' | 'team' }}
 */
function userCanViewMetrics(teamData, currentUserId) {
    if (!teamData || !currentUserId) {
        return { canAccess: false, mode: 'none' };
    }
    
    const userRole = getCurrentUserRole(teamData);
    const visibility = getMetricsVisibilitySetting(teamData);
    
    switch (visibility) {
        case 'owner-only':
            // Only owner can access, and they see full team metrics
            if (userRole === 'owner') {
                return { canAccess: true, mode: 'team' };
            }
            return { canAccess: false, mode: 'none' };
            
        case 'admin-owner':
            // Owner and admins can access full team metrics
            if (userRole === 'owner' || userRole === 'admin') {
                return { canAccess: true, mode: 'team' };
            }
            return { canAccess: false, mode: 'none' };
            
        case 'members-own':
            // Everyone can access, but members only see their own metrics
            if (userRole === 'owner' || userRole === 'admin') {
                return { canAccess: true, mode: 'team' };
            }
            return { canAccess: true, mode: 'self' };
            
        case 'everyone':
            // Everyone can access and see all team metrics
            return { canAccess: true, mode: 'team' };
            
        default:
            // Default to owner-only for safety
            if (userRole === 'owner') {
                return { canAccess: true, mode: 'team' };
            }
            return { canAccess: false, mode: 'none' };
    }
}

/**
 * Update the visibility of the metrics nav item based on access.
 * Should be called after team data is loaded.
 */
function updateNavVisibilityForMetrics() {
    const metricsNavItem = document.getElementById('metricsNavItem');
    if (!metricsNavItem) return;
    
    const access = appState.metricsAccess;
    if (access?.canAccess) {
        metricsNavItem.classList.remove('hidden');
        metricsNavItem.style.display = '';
    } else {
        metricsNavItem.classList.add('hidden');
        metricsNavItem.style.display = 'none';
    }
}

// ===================================
// FINANCES TAB VISIBILITY SYSTEM
// ===================================

/**
 * Get the finances enabled setting from team data.
 * @param {Object} teamData - The team document data
 * @returns {boolean} - Whether finances tab is enabled
 */
function getFinancesEnabledSetting(teamData) {
    // Default to true if not explicitly set (enabled by default, visible to owner)
    if (teamData?.settings?.financesEnabled === undefined) {
        return true;
    }
    return teamData.settings.financesEnabled;
}

/**
 * Get the finances visibility setting from team data.
 * @param {Object} teamData - The team document data
 * @returns {string} - 'owner-only' | 'admin-owner' | 'everyone'
 */
function getFinancesVisibilitySetting(teamData) {
    return teamData?.settings?.financesVisibility || 'owner-only';
}

/**
 * Determine if the current user can view finances and what mode they have.
 * 
 * @param {Object} teamData - The team document data
 * @param {string} currentUserId - The current user's UID
 * @returns {{ canAccess: boolean, mode: 'none' | 'full' }}
 */
function userCanViewFinances(teamData, currentUserId) {
    if (!teamData || !currentUserId) {
        return { canAccess: false, mode: 'none' };
    }
    
    // First check if finances is enabled
    const isEnabled = getFinancesEnabledSetting(teamData);
    if (!isEnabled) {
        return { canAccess: false, mode: 'none' };
    }
    
    const userRole = getCurrentUserRole(teamData);
    const visibility = getFinancesVisibilitySetting(teamData);
    
    switch (visibility) {
        case 'owner-only':
            // Only owner can access
            if (userRole === 'owner') {
                return { canAccess: true, mode: 'full' };
            }
            return { canAccess: false, mode: 'none' };
            
        case 'admin-owner':
            // Owner and admins can access
            if (userRole === 'owner' || userRole === 'admin') {
                return { canAccess: true, mode: 'full' };
            }
            return { canAccess: false, mode: 'none' };
            
        case 'everyone':
            // Everyone can access
            return { canAccess: true, mode: 'full' };
            
        default:
            // Default to owner-only for safety
            if (userRole === 'owner') {
                return { canAccess: true, mode: 'full' };
            }
            return { canAccess: false, mode: 'none' };
    }
}

/**
 * Update the visibility of the finances nav item based on access.
 * Should be called after team data is loaded.
 */
function updateNavVisibilityForFinances() {
    const financesNavItem = document.getElementById('financesNavItem');
    if (!financesNavItem) return;
    
    const access = appState.financesAccess;
    if (access?.canAccess) {
        financesNavItem.classList.remove('hidden');
        financesNavItem.style.display = '';
    } else {
        financesNavItem.classList.add('hidden');
        financesNavItem.style.display = 'none';
    }
}

// ===================================
// AUTHENTICATION CHECK
// ===================================
async function initializeFirebaseAuth() {
    try {
        // Import Firebase modules
        const { initializeApp } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-app.js');
        const { getAuth, onAuthStateChanged, GoogleAuthProvider } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-auth.js');
        const { getFirestore } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        auth = getAuth(app);
        db = getFirestore(app);

        // Initialize Google Auth Provider
        const provider = new GoogleAuthProvider();
        provider.addScope('profile');
        provider.addScope('email');
        window.firebaseAuth = auth;
        window.googleProvider = provider;

        // Apply theme immediately if set in localStorage (already handled by applyThemeEarly)
        // This is a fallback for any race conditions
        const localTheme = localStorage.getItem('themePreference');
        if (localTheme) {
            applyTheme(localTheme);
        }

        // Check authentication state
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                // User is signed in
                currentAuthUser = user;
                updateUserProfile(user);
                console.log('âœ… User authenticated');
                
                // === PHASE 4 & 8: Sync public profile using SAVED displayName, not auth displayName ===
                // This ensures the publicProfile always reflects the user's chosen name
                try {
                    const { doc, getDoc, setDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
                    
                    // Read saved user doc to get chosen displayName and avatarColor
                    const userRef = doc(db, 'users', user.uid);
                    const userDoc = await getDoc(userRef);
                    
                    let savedDisplayName = null;
                    let savedAvatarColor = null;
                    let savedOccupation = null;
                    
                    if (userDoc.exists()) {
                        const userData = userDoc.data();
                        savedDisplayName = userData.displayName || null;
                        savedAvatarColor = userData.avatarColor || null;
                        savedOccupation = userData.jobTitle || userData.occupation || null;
                    }
                    
                    // Fallback chain for displayName
                    const displayNameToSync = savedDisplayName || user.displayName || user.email?.split('@')[0] || 'Unknown';
                    
                    // Update appState.currentUser with the correct name
                    appState.currentUser = displayNameToSync;
                    
                    // === PHASE 8: Ensure publicProfile exists with correct data ===
                    const publicProfileRef = doc(db, 'publicProfiles', user.uid);
                    const publicProfileDoc = await getDoc(publicProfileRef);
                    
                    // Generate deterministic avatar color if missing
                    if (!savedAvatarColor) {
                        // Simple hash-based color generation from UID
                        const hash = user.uid.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                        const hue = hash % 360;
                        savedAvatarColor = `hsl(${hue}, 65%, 45%)`;
                        // Convert HSL to hex for consistency
                        const hslToHex = (h, s, l) => {
                            s /= 100; l /= 100;
                            const c = (1 - Math.abs(2 * l - 1)) * s;
                            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
                            const m = l - c / 2;
                            let r = 0, g = 0, b = 0;
                            if (h < 60) { r = c; g = x; }
                            else if (h < 120) { r = x; g = c; }
                            else if (h < 180) { g = c; b = x; }
                            else if (h < 240) { g = x; b = c; }
                            else if (h < 300) { r = x; b = c; }
                            else { r = c; b = x; }
                            const toHex = n => Math.round((n + m) * 255).toString(16).padStart(2, '0');
                            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
                        };
                        savedAvatarColor = hslToHex(hue, 65, 45);
                    }
                    
                    // Sync to publicProfile
                    await syncPublicProfile({
                        displayName: displayNameToSync,
                        email: user.email,
                        photoURL: user.photoURL || null,
                        occupation: savedOccupation,
                        avatarColor: savedAvatarColor
                    });
                    
                    // Initialize publicProfilesById cache with current user
                    if (!appState.publicProfilesById) appState.publicProfilesById = {};
                    appState.publicProfilesById[user.uid] = {
                        displayName: displayNameToSync,
                        avatarColor: savedAvatarColor,
                        photoURL: user.photoURL || null,
                        occupation: savedOccupation
                    };
                    
                    console.log('âœ… [IDENTITY] Public profile synced:', { displayName: displayNameToSync, avatarColor: savedAvatarColor });
                    
                } catch (profileError) {
                    // Non-critical - don't block auth flow
                    console.warn('Public profile sync deferred:', profileError.message);
                    // Still set a fallback for appState.currentUser
                    appState.currentUser = user.displayName || user.email?.split('@')[0] || 'Unknown';
                }
                
                // Track session login time for force logout feature
                if (!localStorage.getItem('sessionLoginAt')) {
                    localStorage.setItem('sessionLoginAt', Date.now().toString());
                }
                // Apply animation preferences from user settings
                loadAnimationPreference().then(enabled => {
                    applyAnimationPreference(enabled);
                });
                // Apply sidebar icons preference from user settings
                loadSidebarIconsPreference().then(enabled => {
                    applySidebarIconsPreference(enabled);
                });
                // Start listening for force logout events
                startForceLogoutListener();
                // Initialize team after authentication
                await initializeUserTeam();
                
                // After auth and team initialization, ensure we're on the right route
                // If user is authenticated, they should see the app, not the homepage
                if (currentRoute === 'home') {
                    // User authenticated but still on homepage - navigate to app
                    navigateToApp();
                } else if (currentRoute === 'app') {
                    // User already on app route - ensure app is visible
                    showAppContainer();
                }
                
                // Check for pending join code from URL
                const pendingJoinCode = sessionStorage.getItem('pendingJoinCode');
                if (pendingJoinCode) {
                    sessionStorage.removeItem('pendingJoinCode');
                    // Small delay to ensure UI is ready
                    setTimeout(() => {
                        processJoinCode(pendingJoinCode);
                    }, 1000);
                }
                // Ready - hide loader after successful auth/bootstrap
                hideLoaderIfPresent();
            } else {
                // No user signed in - clear sensitive data and redirect to login
                console.log('âŒ No user authenticated - redirecting to login');
                // LocalStorage Safety Cleanup
                localStorage.removeItem('currentTeamId');
                localStorage.removeItem('messages');
                localStorage.removeItem('tasks');
                localStorage.removeItem('teammates');
                localStorage.removeItem('lastInvitationLink'); // Legacy cleanup
                // Clear in-memory invitation link
                if (window.lastInvitationLink) {
                    delete window.lastInvitationLink;
                }
                // Reset app state
                appState.currentTeamId = null;
                appState.userTeams = [];
                appState.messages = [];
                appState.events = [];
                appState.tasks = [];
                appState.activities = [];
                appState.teammates = [];
                
                // Only redirect to login if user is trying to access the app (not homepage)
                if (currentRoute === 'app') {
                    // Redirect to account page for authentication
                    window.location.href = '/account';
                } else if (currentRoute === 'home') {
                    // User on homepage without auth - this is fine, keep them there
                    // Don't redirect, homepage is public
                }
                // If on homepage, do nothing - they can browse the public homepage
                hideLoaderIfPresent();
            }
        });

    } catch (error) {
        console.error('Firebase initialization error:', error.code || error.message);
        debugError('Full Firebase error:', error);
        console.log('âŒ Firebase failed to initialize - redirecting to login');
        hideLoaderIfPresent();
        
        // LocalStorage Safety Cleanup on error
        localStorage.removeItem('currentTeamId');
        localStorage.removeItem('messages');
        localStorage.removeItem('tasks');
        localStorage.removeItem('teammates');
        localStorage.removeItem('lastInvitationLink'); // Legacy cleanup
        
        // Clear in-memory invitation link
        if (window.lastInvitationLink) {
            delete window.lastInvitationLink;
        }
        
        // Only redirect to login on Firebase error if on /app route
        if (currentRoute === 'app') {
            window.location.href = '/account';
        }
    }
}

// Update user profile in UI
async function updateUserProfile(user) {
    const userNameEl = document.querySelector('.user-name');
    const userAvatarEl = document.querySelector('.user-avatar');
    
    // Load user settings from Firestore
    try {
        const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        const userRef = doc(db, 'users', user.uid);
        const userDoc = await getDoc(userRef);
        
        let displayName = user.displayName || user.email.split('@')[0];
        let avatarColor = '#0078D4'; // Default color
        
        if (userDoc.exists()) {
            const userData = userDoc.data();
            displayName = userData.displayName || displayName;
            avatarColor = userData.avatarColor || avatarColor;
        }
        
        // Update sidebar profile with settings
        updateSidebarProfile(displayName, avatarColor);
        
    } catch (error) {
        console.error('Error loading user settings:', error.code || error.message);
        debugError('Full error:', error);
        // Fallback to basic profile update
        if (userNameEl) {
            userNameEl.textContent = user.displayName || user.email.split('@')[0];
        }
    }
}

// Update user profile from localStorage
function updateUserProfileFromStorage(userInfo) {
    const userNameEl = document.querySelector('.user-name');
    const userAvatarEl = document.querySelector('.user-avatar');
    
    if (userNameEl) {
        userNameEl.textContent = userInfo.displayName;
    }
    
    if (userAvatarEl && userInfo.photoURL) {
        userAvatarEl.innerHTML = `<img src="${escapeHtml(userInfo.photoURL)}" alt="User Avatar" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover;">`;
    }
}

// ===================================
// TOAST NOTIFICATION SYSTEM
// ===================================
function showToast(message, type = 'info', duration = 4000, title = '') {
    const container = document.getElementById('toastContainer');
    if (!container) return;

    const icons = {
        success: '<i class="fas fa-check-circle"></i>',
        error: '<i class="fas fa-times-circle"></i>',
        warning: '<i class="fas fa-exclamation-triangle"></i>',
        info: '<i class="fas fa-info-circle"></i>'
    };

    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.innerHTML = `
        <div class="toast-icon">${icons[type] || icons.info}</div>
        <div class="toast-content">
            ${title ? `<div class="toast-title">${title}</div>` : ''}
            <div class="toast-message">${message}</div>
        </div>
        <button class="toast-close" onclick="this.parentElement.remove()">Ã—</button>
    `;

    container.appendChild(toast);

    // Auto remove after duration
    setTimeout(() => {
        toast.classList.add('closing');
        setTimeout(() => toast.remove(), 300);
    }, duration);
}

// ===================================
// CUSTOM CONFIRMATION MODAL
// ===================================
/**
 * Show a custom confirmation modal instead of browser's confirm()
 * @param {string} message - The confirmation message
 * @param {Object} options - Optional settings
 * @param {string} options.title - Modal title (default: 'Confirm')
 * @param {string} options.confirmText - Confirm button text (default: 'Confirm')
 * @param {string} options.cancelText - Cancel button text (default: 'Cancel')
 * @param {string} options.type - 'danger' for destructive actions
 * @returns {Promise<boolean>} - true if confirmed, false if cancelled
 */
function showConfirmModal(message, options = {}) {
    return new Promise((resolve) => {
        const {
            title = 'Confirm',
            confirmText = 'Confirm',
            cancelText = 'Cancel',
            type = 'default'
        } = options;
        
        // Remove any existing confirm modal
        const existing = document.getElementById('customConfirmModal');
        if (existing) existing.remove();
        
        const isDanger = type === 'danger';
        const modal = document.createElement('div');
        modal.id = 'customConfirmModal';
        modal.className = 'unified-modal active';
        modal.innerHTML = `
            <div class="unified-modal-container modal-sm">
                <div class="unified-modal-header" style="padding: 20px 24px 16px; border-bottom: 1px solid rgba(0, 0, 0, 0.06);">
                    <div class="unified-modal-title">
                        <h2 style="font-size: 17px; font-weight: 600; color: #000000; margin: 0; display: flex; align-items: center; gap: 10px; letter-spacing: -0.01em;">
                            ${escapeHtml(title)}
                        </h2>
                    </div>
                    <button class="unified-modal-close" onclick="document.getElementById('customConfirmModal').remove();" style="width: 28px; height: 28px; border-radius: 50%; border: none; background: rgba(0, 0, 0, 0.05); color: rgba(0, 0, 0, 0.5); cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 13px;">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="unified-modal-body" style="padding: 20px 24px;">
                    <p style="color: var(--text-main); margin: 0; line-height: 1.5; font-size: 15px;">${escapeHtml(message)}</p>
                </div>
                <div class="unified-modal-footer" style="display: flex; justify-content: flex-end; gap: 10px; padding: 16px 24px; border-top: 1px solid rgba(0, 0, 0, 0.06);">
                    <button id="confirmModalCancel" style="padding: 10px 20px; border-radius: 999px; border: 1px solid rgba(0, 0, 0, 0.1); background: transparent; color: var(--text-main); font-size: 14px; font-weight: 500; cursor: pointer;">
                        ${escapeHtml(cancelText)}
                    </button>
                    <button id="confirmModalConfirm" style="padding: 10px 20px; border-radius: 999px; border: none; background: ${isDanger ? '#FF3B30' : 'var(--accent)'}; color: white; font-size: 14px; font-weight: 500; cursor: pointer;">
                        ${escapeHtml(confirmText)}
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        const cancelBtn = document.getElementById('confirmModalCancel');
        const confirmBtn = document.getElementById('confirmModalConfirm');
        
        const cleanup = (result) => {
            modal.remove();
            resolve(result);
        };
        
        cancelBtn.addEventListener('click', () => cleanup(false));
        confirmBtn.addEventListener('click', () => cleanup(true));
        
        // Close on backdrop click
        modal.addEventListener('click', (e) => {
            if (e.target === modal) cleanup(false);
        });
        
        // Close on Escape key
        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                document.removeEventListener('keydown', handleEscape);
                cleanup(false);
            }
        };
        document.addEventListener('keydown', handleEscape);
        
        // Focus confirm button
        confirmBtn.focus();
    });
}

/**
 * Show a custom input modal instead of browser's prompt()
 * @param {string} message - The prompt message
 * @param {string} defaultValue - Default input value
 * @param {Object} options - Optional settings
 * @returns {Promise<string|null>} - Input value or null if cancelled
 */
function showInputModal(message, defaultValue = '', options = {}) {
    return new Promise((resolve) => {
        const {
            title = 'Input',
            confirmText = 'OK',
            cancelText = 'Cancel',
            placeholder = ''
        } = options;
        
        // Remove any existing input modal
        const existing = document.getElementById('customInputModal');
        if (existing) existing.remove();
        
        const modal = document.createElement('div');
        modal.id = 'customInputModal';
        modal.className = 'unified-modal active';
        modal.innerHTML = `
            <div class="unified-modal-container modal-sm">
                <div class="unified-modal-header" style="padding: 20px 24px 16px; border-bottom: 1px solid rgba(0, 0, 0, 0.06);">
                    <div class="unified-modal-title">
                        <h2 style="font-size: 17px; font-weight: 600; color: #000000; margin: 0; letter-spacing: -0.01em;">
                            ${escapeHtml(title)}
                        </h2>
                    </div>
                    <button class="unified-modal-close" onclick="document.getElementById('customInputModal').remove();" style="width: 28px; height: 28px; border-radius: 50%; border: none; background: rgba(0, 0, 0, 0.05); color: rgba(0, 0, 0, 0.5); cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 13px;">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="unified-modal-body" style="padding: 20px 24px;">
                    <p style="color: var(--text-main); margin: 0 0 16px; line-height: 1.5; font-size: 15px;">${escapeHtml(message)}</p>
                    <input type="text" id="inputModalValue" class="unified-input" style="width: 100%; padding: 12px; border-radius: 8px;" placeholder="${escapeHtml(placeholder)}" value="${escapeHtml(defaultValue)}">
                </div>
                <div class="unified-modal-footer" style="display: flex; justify-content: flex-end; gap: 10px; padding: 16px 24px; border-top: 1px solid rgba(0, 0, 0, 0.06);">
                    <button id="inputModalCancel" style="padding: 10px 20px; border-radius: 999px; border: 1px solid rgba(0, 0, 0, 0.1); background: transparent; color: var(--text-main); font-size: 14px; font-weight: 500; cursor: pointer;">
                        ${escapeHtml(cancelText)}
                    </button>
                    <button id="inputModalConfirm" style="padding: 10px 20px; border-radius: 999px; border: none; background: var(--accent); color: white; font-size: 14px; font-weight: 500; cursor: pointer;">
                        ${escapeHtml(confirmText)}
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        const input = document.getElementById('inputModalValue');
        const cancelBtn = document.getElementById('inputModalCancel');
        const confirmBtn = document.getElementById('inputModalConfirm');
        
        const cleanup = (result) => {
            modal.remove();
            resolve(result);
        };
        
        cancelBtn.addEventListener('click', () => cleanup(null));
        confirmBtn.addEventListener('click', () => cleanup(input.value));
        
        // Submit on Enter
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                cleanup(input.value);
            }
        });
        
        // Close on backdrop click
        modal.addEventListener('click', (e) => {
            if (e.target === modal) cleanup(null);
        });
        
        // Close on Escape key
        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                document.removeEventListener('keydown', handleEscape);
                cleanup(null);
            }
        };
        document.addEventListener('keydown', handleEscape);
        
        // Focus and select input
        input.focus();
        input.select();
    });
}

// Sign out function
async function signOutUser() {
    try {
        // Stop force logout listener
        stopForceLogoutListener();
        
        // Stop team members listener
        if (typeof stopTeamMembersListener === 'function') {
            stopTeamMembersListener();
        }
        
        if (auth) {
            const { signOut } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-auth.js');
            await signOut(auth);
        }
        
        // LocalStorage Safety Cleanup - Remove sensitive cached data
        localStorage.removeItem('currentTeamId');
        localStorage.removeItem('messages');
        localStorage.removeItem('tasks');
        localStorage.removeItem('teammates');
        localStorage.removeItem('lastInvitationLink');
        
        // Reset app state to default values
        appState.currentSection = 'activity';
        appState.currentUser = 'Loading...';
        appState.currentTeamId = null;
        appState.userTeams = [];
        appState.messages = [];
        appState.events = [];
        appState.tasks = [];
        appState.activities = [];
        appState.teammates = [];
        appState.calendarView = 'month';
        appState.currentDate = new Date();
        
        // Clear in-memory invitation link before localStorage.clear()
        if (window.lastInvitationLink) {
            delete window.lastInvitationLink;
        }
        
        // Clear any remaining local storage completely
        localStorage.clear();
        
        // Redirect to login
        window.location.href = '/account';
    } catch (error) {
        console.error('Sign out error:', error.code || error.message);
        debugError('Full error:', error);
    }
}

// Make signOut available globally
window.signOutUser = signOutUser;

// ===================================
// APP STATE MANAGEMENT
// ===================================
const appState = {
    currentSection: 'activity',
    currentUser: 'Loading...',
    currentTeamId: null, // Current team the user is viewing
    userTeams: [], // All teams the user belongs to
    messages: [],
    events: [],
    tasks: [],
    activities: [],
    teammates: [], // Real team members only
    publicProfilesById: {}, // Cache of publicProfiles for team members (keyed by uid)
    calendarView: 'month', // 'month' or 'week'
    currentDate: new Date(),
    spreadsheets: [], // Spreadsheet configurations
    currentSpreadsheet: null, // Currently open spreadsheet
    metricsVisibility: 'owner-only', // Current team's metrics visibility setting
    metricsAccess: { canAccess: false, mode: 'none' }, // Metrics visibility access for current user
    graphTypes: {}, // Stores graph type per chart: { graphId: 'bar' | 'line' | 'pie' }
    metricsChartConfig: {}, // Stores per-chart config: { graphId: { yAxisMin, yAxisMax, primaryColor, ... } }
    // Finances state
    financesEnabled: true, // Whether finances tab is enabled for this team (default: true)
    financesVisibility: 'owner-only', // Current team's finances visibility setting
    financesAccess: { canAccess: false, mode: 'none' }, // Finances visibility access for current user
    transactions: [], // Cached transactions for current team
    subscriptions: [], // Cached subscriptions for current team
    financesFilters: { type: 'all', category: 'all', date: 'all', search: '' }, // Current filter state
    // Docs state
    docs: [], // Team documents
    activeDocId: null, // Currently open doc ID
    docsUnsub: null, // Firestore listener cleanup function
    docSaveTimer: null, // Debounce timer for autosave
    isDocDirty: false, // Whether doc has unsaved changes
    isDocSaving: false, // Whether doc is currently saving
    tasksViewMode: 'sheets' // 'sheets' or 'docs' - which view is active in tasks section
};

// ===================================
// RATE LIMITING STATE
// Prevents spam and abuse for all create operations
// ===================================
const rateLimitState = {
    // Task creation
    lastTaskCreation: 0,
    taskCreationCooldown: 1500, // 1.5 second cooldown between task creations
    isCreatingTask: false, // Prevents double-submit
    
    // Message rate limiting
    lastMessageSent: 0,
    messageCooldown: 500, // 0.5 second between messages
    messageCount: 0,
    messageWindowStart: 0,
    maxMessagesPerMinute: 30, // Max 30 messages per minute
    
    // Event creation rate limiting
    lastEventCreation: 0,
    eventCreationCooldown: 1000, // 1 second between events
    eventCount: 0,
    eventWindowStart: 0,
    maxEventsPerHour: 50, // Max 50 events per hour
    
    // Document creation rate limiting
    lastDocCreation: 0,
    docCreationCooldown: 1000, // 1 second between documents
    docCount: 0,
    docWindowStart: 0,
    maxDocsPerHour: 30 // Max 30 docs per hour
};

/**
 * Check if message sending is allowed (rate limiting)
 * @returns {Object} { allowed: boolean, reason?: string }
 */
function canSendMessage() {
    const now = Date.now();
    
    // Check cooldown between messages
    if (now - rateLimitState.lastMessageSent < rateLimitState.messageCooldown) {
        return { allowed: false, reason: 'Sending too fast' };
    }
    
    // Check messages per minute limit
    if (now - rateLimitState.messageWindowStart > 60000) {
        // Reset window
        rateLimitState.messageWindowStart = now;
        rateLimitState.messageCount = 0;
    }
    
    if (rateLimitState.messageCount >= rateLimitState.maxMessagesPerMinute) {
        return { allowed: false, reason: 'Message limit reached. Please wait a moment.' };
    }
    
    return { allowed: true };
}

/**
 * Check if event creation is allowed (rate limiting)
 * @returns {Object} { allowed: boolean, reason?: string }
 */
function canCreateEvent() {
    const now = Date.now();
    
    // Check cooldown between events
    if (now - rateLimitState.lastEventCreation < rateLimitState.eventCreationCooldown) {
        return { allowed: false, reason: 'Please wait before creating another event' };
    }
    
    // Check events per hour limit
    if (now - rateLimitState.eventWindowStart > 3600000) {
        // Reset window
        rateLimitState.eventWindowStart = now;
        rateLimitState.eventCount = 0;
    }
    
    if (rateLimitState.eventCount >= rateLimitState.maxEventsPerHour) {
        return { allowed: false, reason: 'Event limit reached. Please wait an hour.' };
    }
    
    return { allowed: true };
}

/**
 * Check if document creation is allowed (rate limiting)
 * @returns {Object} { allowed: boolean, reason?: string }
 */
function canCreateDocument() {
    const now = Date.now();
    
    // Check cooldown between documents
    if (now - rateLimitState.lastDocCreation < rateLimitState.docCreationCooldown) {
        return { allowed: false, reason: 'Please wait before creating another document' };
    }
    
    // Check docs per hour limit
    if (now - rateLimitState.docWindowStart > 3600000) {
        // Reset window
        rateLimitState.docWindowStart = now;
        rateLimitState.docCount = 0;
    }
    
    if (rateLimitState.docCount >= rateLimitState.maxDocsPerHour) {
        return { allowed: false, reason: 'Document limit reached. Please wait an hour.' };
    }
    
    return { allowed: true };
}

/**
 * Check if task creation is allowed (rate limiting)
 * @returns {Object} { allowed: boolean, reason?: string }
 */
function canCreateTask() {
    const now = Date.now();
    
    // Check if already creating a task
    if (rateLimitState.isCreatingTask) {
        return { allowed: false, reason: 'Task creation in progress...' };
    }
    
    // Check cooldown period
    const timeSinceLastCreation = now - rateLimitState.lastTaskCreation;
    if (timeSinceLastCreation < rateLimitState.taskCreationCooldown) {
        const remaining = Math.ceil((rateLimitState.taskCreationCooldown - timeSinceLastCreation) / 1000);
        return { allowed: false, reason: `Please wait ${remaining}s before creating another task` };
    }
    
    return { allowed: true };
}

// ===================================
// NAVIGATION
// ===================================
// Function to switch tabs programmatically
window.switchTab = function(sectionName) {
    // Check metrics access before allowing navigation
    if (sectionName === 'metrics' && !appState.metricsAccess?.canAccess) {
        showToast("You don't have access to metrics yet.", 'info', 3000);
        // Redirect to overview instead
        window.switchTab('activity');
        return;
    }
    
    // Check finances access before allowing navigation
    if (sectionName === 'finances' && !appState.financesAccess?.canAccess) {
        showToast("You don't have access to finances yet.", 'info', 3000);
        // Redirect to overview instead
        window.switchTab('activity');
        return;
    }
    
    const navItems = document.querySelectorAll('.nav-item');
    const sections = document.querySelectorAll('.content-section');
    
    // Update active nav item
    navItems.forEach(nav => {
        nav.classList.remove('active');
        if (nav.dataset.section === sectionName) {
            nav.classList.add('active');
        }
    });
    
    // Update active section
    sections.forEach(section => section.classList.remove('active'));
    const targetSection = document.getElementById(`${sectionName}-section`);
    if (targetSection) {
        targetSection.classList.add('active');
    }
    
    appState.currentSection = sectionName;
    
    // Clear chat notification badge when navigating to chat
    if (sectionName === 'chat') {
        const badge = document.getElementById('chatNotificationBadge');
        if (badge) {
            badge.style.display = 'none';
            badge.textContent = '0';
            appState.unreadMessages = 0;
        }
        // Store last seen timestamp for chat
        if (appState.currentTeamId) {
            localStorage.setItem(`chatLastSeen_${appState.currentTeamId}`, Date.now().toString());
        }
    }
    
    // Render metrics when navigating to metrics tab
    if (sectionName === 'metrics') {
        // Load subscriptions first for MRR chart data
        loadSubscriptions().then(() => renderMetrics());
    }
    
    // Render finances when navigating to finances tab
    if (sectionName === 'finances') {
        // Load subscriptions first, then transactions (which calls renderFinances)
        loadSubscriptions().then(() => loadTransactions());
    }
};

function initNavigation() {
    const navItems = document.querySelectorAll('.nav-item');
    const sections = document.querySelectorAll('.content-section');

    navItems.forEach(item => {
        item.addEventListener('click', () => {
            const sectionName = item.dataset.section;
            
            // Update active nav item
            navItems.forEach(nav => nav.classList.remove('active'));
            item.classList.add('active');
            
            // Update active section
            sections.forEach(section => section.classList.remove('active'));
            document.getElementById(`${sectionName}-section`).classList.add('active');
            
            appState.currentSection = sectionName;
            
            // Show/hide delete chat history option for owners in settings
            if (sectionName === 'settings') {
                updateSettingsVisibility();
            }
            
            // Clear chat notification badge when navigating to chat
            if (sectionName === 'chat') {
                const chatBadge = document.getElementById('chatNotificationBadge');
                if (chatBadge) {
                    chatBadge.style.display = 'none';
                    chatBadge.textContent = '0';
                }
                // Store last seen timestamp for chat
                if (appState.currentTeamId) {
                    localStorage.setItem(`chatLastSeen_${appState.currentTeamId}`, Date.now().toString());
                }
                // Apply chat appearance preferences
                loadChatAppearanceSettings().then(preferences => {
                    applyChatAppearance(preferences);
                });
                // Scroll to bottom when opening chat
                setTimeout(() => {
                    const chatMessages = document.getElementById('chatMessages');
                    if (chatMessages) {
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    }
                }, 100);
            }
            
            // Initialize section-specific functionality
            if (sectionName === 'settings') {
                loadAccountSettings();
            } else if (sectionName === 'team') {
                initTeamSection();
            } else if (sectionName === 'metrics') {
                // Check access before rendering metrics
                if (!appState.metricsAccess?.canAccess) {
                    showToast("You don't have access to metrics yet.", 'info', 3000);
                    // Redirect to overview
                    window.switchTab('activity');
                    return;
                }
                renderMetrics();
            } else if (sectionName === 'finances') {
                // Check access before rendering finances
                if (!appState.financesAccess?.canAccess) {
                    showToast("You don't have access to finances yet.", 'info', 3000);
                    // Redirect to overview
                    window.switchTab('activity');
                    return;
                }
                // Load subscriptions first, then transactions
                loadSubscriptions().then(() => loadTransactions());
            }
        });
    });
}

// ===================================
// CHAT FUNCTIONALITY
// ===================================

// Mention system state
let mentionState = {
    isActive: false,
    startIndex: -1,
    selectedIndex: 0,
    filteredTeammates: [],
    currentFilter: 'all' // 'all' or 'mentions'
};

// Reply system state
let replyState = {
    currentReply: null // { messageId, userId, displayName, previewText }
};

// Reactions system state
const REACTION_EMOJIS = ['ðŸ‘', 'â¤ï¸', 'ðŸ˜‚', 'ðŸ˜®', 'ðŸ˜¢', 'âœ…'];
let reactionsState = {
    activeMessageId: null, // ID of message with open reactions bar
    reactionsBarElement: null, // Reference to the floating reactions bar
    longPressTimer: null, // Timer for mobile long-press detection
    longPressTriggered: false // Flag to prevent click after long-press
};

// ===================================
// TYPING INDICATOR SYSTEM
// Shows "User is typing..." when others type
// ===================================
let typingState = {
    lastTypingUpdate: 0,          // Timestamp of last Firestore typing update
    typingThrottleMs: 700,        // Throttle typing updates to reduce Firestore writes
    typingTimeoutMs: 2000,        // Consider user stopped typing after 2s
    unsubscribeTyping: null,      // Firestore listener unsubscribe function
    currentlyTyping: new Map()    // Map of userId -> {displayName, updatedAt}
};

/**
 * Update typing status in Firestore (throttled to prevent spam)
 * Creates/updates: teams/{teamId}/typing/{userId}
 */
async function updateTypingStatus() {
    if (!db || !currentAuthUser || !appState.currentTeamId) return;
    
    const now = Date.now();
    
    // Throttle: only update if enough time has passed since last update
    if (now - typingState.lastTypingUpdate < typingState.typingThrottleMs) {
        return;
    }
    
    typingState.lastTypingUpdate = now;
    
    try {
        const { doc, setDoc, serverTimestamp } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const typingRef = doc(db, 'teams', appState.currentTeamId, 'typing', currentAuthUser.uid);
        const identity = getIdentity(currentAuthUser.uid, currentAuthUser.displayName);
        
        await setDoc(typingRef, {
            userId: currentAuthUser.uid,
            displayName: identity.displayName,
            updatedAt: serverTimestamp()
        });
        
    } catch (error) {
        // Silently fail - typing indicator is non-critical
        console.debug('Typing update failed:', error.message);
    }
}

/**
 * Clear typing status when user stops typing or sends message
 */
async function clearTypingStatus() {
    if (!db || !currentAuthUser || !appState.currentTeamId) return;
    
    try {
        const { doc, deleteDoc } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const typingRef = doc(db, 'teams', appState.currentTeamId, 'typing', currentAuthUser.uid);
        await deleteDoc(typingRef);
        
    } catch (error) {
        // Silently fail
        console.debug('Clear typing failed:', error.message);
    }
}

/**
 * Subscribe to typing status updates for the current team
 */
async function subscribeToTypingIndicator() {
    if (!db || !appState.currentTeamId) return;
    
    // Unsubscribe from previous listener
    if (typingState.unsubscribeTyping) {
        typingState.unsubscribeTyping();
    }
    
    try {
        const { collection, onSnapshot } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const typingRef = collection(db, 'teams', appState.currentTeamId, 'typing');
        
        typingState.unsubscribeTyping = onSnapshot(typingRef, (snapshot) => {
            const now = Date.now();
            typingState.currentlyTyping.clear();
            
            snapshot.forEach((doc) => {
                const data = doc.data();
                // Skip current user
                if (data.userId === currentAuthUser?.uid) return;
                
                // Check if typing entry is stale (older than 2 seconds)
                const updatedAt = data.updatedAt?.toMillis ? data.updatedAt.toMillis() : 0;
                if (now - updatedAt < typingState.typingTimeoutMs) {
                    typingState.currentlyTyping.set(data.userId, {
                        displayName: data.displayName,
                        updatedAt: updatedAt
                    });
                }
            });
            
            // Update UI
            updateTypingIndicatorUI();
        });
        
    } catch (error) {
        console.error('Error subscribing to typing indicator:', error);
    }
}

/**
 * Update the typing indicator UI based on current state
 */
function updateTypingIndicatorUI() {
    const indicator = document.getElementById('typingIndicator');
    const textEl = document.getElementById('typingText');
    
    if (!indicator || !textEl) return;
    
    const typingUsers = Array.from(typingState.currentlyTyping.values());
    
    if (typingUsers.length === 0) {
        indicator.style.display = 'none';
        return;
    }
    
    indicator.style.display = 'flex';
    
    if (typingUsers.length === 1) {
        textEl.textContent = `${typingUsers[0].displayName} is typing...`;
    } else if (typingUsers.length === 2) {
        textEl.textContent = `${typingUsers[0].displayName} and ${typingUsers[1].displayName} are typing...`;
    } else {
        textEl.textContent = `${typingUsers[0].displayName} and ${typingUsers.length - 1} others are typing...`;
    }
}

function initChat() {
    const chatInput = document.getElementById('chatInput');
    const sendBtn = document.getElementById('sendMessageBtn');
    const chatMessages = document.getElementById('chatMessages');
    const clearAllBtn = document.getElementById('clearAllMessagesBtn');
    const mentionDropdown = document.getElementById('mentionDropdown');
    const chatFilterToggle = document.getElementById('chatFilterToggle');
    const replyCancelBtn = document.getElementById('replyCancelBtn');

    // Show clear all button only for owners
    if (clearAllBtn) {
        const currentUserRole = appState.teammates?.find(t => t.id === currentAuthUser?.uid)?.role;
        if (currentUserRole === 'owner') {
            clearAllBtn.style.display = 'block';
        }
        clearAllBtn.addEventListener('click', clearAllMessages);
    }

    // Initialize reply cancel button
    if (replyCancelBtn) {
        replyCancelBtn.addEventListener('click', clearReplyContext);
    }

    // Initialize chat filter toggle
    if (chatFilterToggle) {
        chatFilterToggle.addEventListener('click', (e) => {
            const filterBtn = e.target.closest('.filter-btn');
            if (!filterBtn) return;
            
            const filter = filterBtn.dataset.filter;
            mentionState.currentFilter = filter;
            
            // Update active state
            chatFilterToggle.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.filter === filter);
            });
            
            // Re-display messages with filter
            displayMessages();
        });
    }

    // Messages will be loaded from Firestore when team data loads
    // Don't load from localStorage as it's not team-specific

    // Send message on button click
    sendBtn.addEventListener('click', sendMessage);

    // Send message on Enter key (modified to handle mentions and replies)
    chatInput.addEventListener('keydown', (e) => {
        if (mentionState.isActive) {
            handleMentionKeydown(e);
        } else if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });

    // Handle input for mention detection, /r command, AND typing indicator
    chatInput.addEventListener('input', (e) => {
        handleMentionInput(e);
        handleReplyCommand(e);
        
        // TYPING INDICATOR: Update typing status on input
        if (e.target.value.trim().length > 0) {
            updateTypingStatus();
        }
    });
    
    // TYPING INDICATOR: Clear typing status when chat input loses focus or is empty
    chatInput.addEventListener('blur', () => {
        clearTypingStatus();
    });
    
    // TYPING INDICATOR: Subscribe to typing updates when chat is initialized
    subscribeToTypingIndicator();

    // Close mention dropdown when clicking outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.mention-dropdown') && !e.target.closest('.chat-input')) {
            closeMentionDropdown();
        }
    });

    // Hide delete buttons when clicking outside messages
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.message')) {
            document.querySelectorAll('.message.show-delete').forEach(msg => {
                msg.classList.remove('show-delete');
            });
        }
    });

    // Initialize reactions system listeners
    initReactionsListeners();

    // Initialize chat emoji picker
    initChatEmojiPicker();

    async function sendMessage() {
        const messageText = chatInput.value.trim();
        
        if (messageText === '') return;

        // RATE LIMITING: Check if user can send message
        const rateCheck = canSendMessage();
        if (!rateCheck.allowed) {
            showToast(rateCheck.reason, 'warning', 2000);
            return;
        }

        // TYPING INDICATOR: Clear typing status when message is sent
        clearTypingStatus();

        // Close mention dropdown if open
        closeMentionDropdown();

        // Extract mentions from message text
        const mentions = extractMentions(messageText);

        // Get current user's avatar color from teammates
        const currentTeammate = appState.teammates?.find(t => t.id === currentAuthUser?.uid);
        const avatarColor = currentTeammate?.avatarColor || '#0078D4';

        const message = {
            author: appState.currentUser,
            text: messageText,
            userId: currentAuthUser?.uid,
            avatarColor: avatarColor,
            mentions: mentions // Array of user IDs mentioned
        };

        // Add reply data if replying to a message
        if (replyState.currentReply) {
            message.repliedTo = {
                messageId: replyState.currentReply.messageId,
                userId: replyState.currentReply.userId,
                displayName: replyState.currentReply.displayName,
                preview: replyState.currentReply.previewText.substring(0, 100) // Limit preview length
            };
        }

        // Don't add to state yet - let Firestore listener handle it
        // This ensures consistency across all clients
        
        // Encrypt and save to Firestore (team-scoped and encrypted)
        if (db && currentAuthUser && appState.currentTeamId) {
            try {
                // Manually encrypt the message first - this guarantees no plaintext reaches Firestore
                const encryptedText = await encryptMessage(message.text, appState.currentTeamId);
                
                // Only save if encryption succeeded
                await saveMessageToFirestore({
                    ...message,
                    text: encryptedText // Pass pre-encrypted text
                });

                // Send notifications to mentioned users
                if (mentions.length > 0) {
                    sendMentionNotifications(mentions, messageText);
                }
                
                // RATE LIMITING: Update rate limit state after successful send
                rateLimitState.lastMessageSent = Date.now();
                rateLimitState.messageCount++;
                
            } catch (error) {
                console.error('Message encryption failed:', error.code || error.message);
                debugError('Full error:', error);
                
                // If encryption failed, show error and abort
                if (error.message === 'ENCRYPTION_FAILED') {
                    showToast('Message encryption failed. Message not sent.', 'error', 5000, 'Encryption Failed');
                } else {
                    showToast('Failed to send message. Please try again.', 'error', 5000, 'Send Failed');
                }
                
                // Don't display message, don't clear input, don't add activity
                return;
            }
        }

        // Message will be displayed automatically by Firestore onSnapshot listener
        // This ensures the UI always uses the real Firestore doc ID

        // Don't add activity for own messages (others will see it via their listeners)
        // Activity is only for notification purposes, and you shouldn't notify yourself

        // Clear input and reply context
        chatInput.value = '';
        clearReplyContext();
        
        // Chat will auto-scroll when onSnapshot updates the messages
    }

    function displayMessage(message) {
        const messageEl = document.createElement('div');
        messageEl.className = 'message';
        messageEl.dataset.messageId = message.id; // Store message ID for deletion
        
        // Determine sender uid with backward compatibility
        const senderUid = message.authorId || message.userId || message.createdBy;
        
        // Use unified identity resolver
        const identity = getIdentity(senderUid, message.userName || message.author);
        const authorName = identity.displayName;
        const avatarColor = identity.avatarColor;
        
        // Get initials for avatar
        const initials = identity.initials;
        
        // Create avatar element
        const avatarDiv = document.createElement('div');
        avatarDiv.className = 'message-avatar';
        avatarDiv.style.background = avatarColor;
        avatarDiv.style.color = 'white';
        avatarDiv.style.display = 'flex';
        avatarDiv.style.alignItems = 'center';
        avatarDiv.style.justifyContent = 'center';
        avatarDiv.style.fontWeight = '600';
        avatarDiv.textContent = initials; // Use textContent for initials
        
        // Create content container
        const contentDiv = document.createElement('div');
        contentDiv.className = 'message-content';

        // === REPLY CONTEXT BLOCK ===
        // Polished compact card showing the message being replied to
        // Structure: [accent bar] [content: author name + preview text]
        if (message.repliedTo) {
            const replyContext = document.createElement('div');
            replyContext.className = 'message-reply-context';
            
            // Accent color bar on left side
            const replyBar = document.createElement('div');
            replyBar.className = 'reply-context-bar';
            
            // Content area with author and preview
            const replyContent = document.createElement('div');
            replyContent.className = 'reply-context-content';
            
            // Author name with reply icon
            const replyAuthor = document.createElement('div');
            replyAuthor.className = 'reply-context-author';
            const authorIcon = document.createElement('i');
            authorIcon.className = 'fas fa-reply';
            replyAuthor.appendChild(authorIcon);
            replyAuthor.appendChild(document.createTextNode(` ${message.repliedTo.displayName}`));
            
            // Preview text (truncated)
            const replyText = document.createElement('div');
            replyText.className = 'reply-context-text';
            
            // Check if original message still exists for better UX
            const originalMessage = appState.messages?.find(m => m.id === message.repliedTo.messageId);
            if (originalMessage) {
                replyText.textContent = message.repliedTo.preview || 'View message';
            } else {
                replyText.textContent = message.repliedTo.preview || 'Original message not available';
                if (!message.repliedTo.preview) {
                    replyText.classList.add('reply-context-unavailable');
                }
            }
            
            replyContent.appendChild(replyAuthor);
            replyContent.appendChild(replyText);
            replyContext.appendChild(replyBar);
            replyContext.appendChild(replyContent);
            
            // Click to scroll to original message with highlight animation
            replyContext.addEventListener('click', (e) => {
                e.stopPropagation();
                scrollToOriginalMessage(message.repliedTo.messageId);
            });
            
            contentDiv.appendChild(replyContext);
        }
        
        // Create header
        const headerDiv = document.createElement('div');
        headerDiv.className = 'message-header';
        
        const authorSpan = document.createElement('span');
        authorSpan.className = 'message-author';
        authorSpan.textContent = authorName; // Use textContent for author name
        
        const timeSpan = document.createElement('span');
        timeSpan.className = 'message-time';
        timeSpan.textContent = message.time; // Use textContent for time
        
        headerDiv.appendChild(authorSpan);
        headerDiv.appendChild(timeSpan);
        
        // Create message text element with mention rendering
        const textDiv = document.createElement('div');
        textDiv.className = 'message-text';
        
        // Render mentions as clickable pills if message has mentions
        if (message.mentions && message.mentions.length > 0) {
            const renderedContent = renderMessageWithMentions(message.text, message.mentions);
            textDiv.appendChild(renderedContent);
        } else {
            textDiv.textContent = message.text; // Use textContent for message text - never innerHTML
        }
        
        // Store mentions data on element for filtering
        messageEl.dataset.mentions = JSON.stringify(message.mentions || []);

        // === ACTION BUTTONS CONTAINER ===
        // Groups Reply and Delete buttons with consistent alignment
        // Uses unified .message-actions container for proper spacing
        const actionsDiv = document.createElement('div');
        actionsDiv.className = 'message-actions';

        // Reply button - available on all messages
        const replyBtn = document.createElement('button');
        replyBtn.className = 'message-action-btn message-reply-btn';
        replyBtn.innerHTML = '<i class="fas fa-reply"></i><span>Reply</span>';
        replyBtn.title = 'Reply to this message';
        replyBtn.tabIndex = 0; // Make keyboard accessible
        replyBtn.onclick = (e) => {
            e.stopPropagation();
            setReplyContext(message.id, message.userId, authorName, message.text);
        };
        actionsDiv.appendChild(replyBtn);
        
        // Determine if delete button should be shown
        // Show delete button only if:
        // 1. User created this message (owns it), OR
        // 2. User is admin/owner (can delete any message)
        const currentUserId = currentAuthUser?.uid;
        const currentUserRole = appState.teammates?.find(t => t.id === currentUserId)?.role || 'member';
        const isCreator = message.userId === currentUserId;
        const isAdminOrOwner = currentUserRole === 'admin' || currentUserRole === 'owner';
        const canDelete = isCreator || isAdminOrOwner;
        
        if (canDelete) {
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'message-action-btn message-delete-btn';
            deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
            deleteBtn.title = 'Delete message';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                deleteMessage(message.id, message.userId);
            };
            actionsDiv.appendChild(deleteBtn);
        }
        
        // === REACTIONS DISPLAY ===
        // Show aggregated reactions below message text
        // Load from subcollection for new messages, fall back to legacy reactions map
        const reactionsDisplay = document.createElement('div');
        reactionsDisplay.className = 'message-reactions-display';
        reactionsDisplay.dataset.messageId = message.id;
        
        // First show legacy reactions if they exist (for backward compatibility)
        if (message.reactions && Object.keys(message.reactions).length > 0) {
            renderReactionsDisplay(reactionsDisplay, message.reactions);
        }
        
        // Then async load from subcollection (will override if present)
        loadMessageReactions(message.id).then(subcollectionReactions => {
            if (Object.keys(subcollectionReactions).length > 0) {
                renderReactionsDisplay(reactionsDisplay, subcollectionReactions);
            }
        }).catch(err => {
            // Silently fail - legacy reactions will remain
            debugLog('Could not load reactions subcollection:', err.message);
        });
        
        // === MESSAGE INTERACTION HANDLERS ===
        // Desktop: click to show reactions
        // Mobile: long-press to show reactions
        
        // Long press detection for mobile
        let longPressTimer = null;
        let touchMoved = false;
        
        messageEl.addEventListener('touchstart', (e) => {
            if (e.target.closest('.message-action-btn') || e.target.closest('.message-reactions-display')) {
                return;
            }
            touchMoved = false;
            reactionsState.longPressTriggered = false;
            longPressTimer = setTimeout(() => {
                reactionsState.longPressTriggered = true;
                // Hide actions on other messages
                document.querySelectorAll('.message').forEach(msg => {
                    if (msg !== messageEl) msg.classList.remove('show-actions');
                });
                messageEl.classList.add('show-actions');
                toggleReactionsBar(message.id, messageEl);
            }, 400); // 400ms long press
        }, { passive: true });
        
        messageEl.addEventListener('touchmove', () => {
            touchMoved = true;
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }
        }, { passive: true });
        
        messageEl.addEventListener('touchend', (e) => {
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }
            // Prevent click event if long press was triggered
            if (reactionsState.longPressTriggered) {
                e.preventDefault();
                e.stopPropagation();
            }
        });
        
        // Desktop click handler
        messageEl.onclick = (e) => {
            // Don't trigger on action button clicks or reactions display
            if (e.target.closest('.message-action-btn') || e.target.closest('.message-reactions-display')) {
                return;
            }
            
            // Don't trigger if this was a long press on mobile
            if (reactionsState.longPressTriggered) {
                reactionsState.longPressTriggered = false;
                return;
            }
            
            // Hide action buttons on all other messages
            document.querySelectorAll('.message').forEach(msg => {
                if (msg !== messageEl) {
                    msg.classList.remove('show-actions');
                }
            });
            // Toggle action buttons on clicked message
            messageEl.classList.toggle('show-actions');
            
            // Toggle reactions bar
            toggleReactionsBar(message.id, messageEl);
        };
        
        // Assemble the message
        // Structure: [header] [text] [reactions] [actions container]
        contentDiv.appendChild(headerDiv);
        contentDiv.appendChild(textDiv);
        contentDiv.appendChild(reactionsDisplay);
        contentDiv.appendChild(actionsDiv);
        
        messageEl.appendChild(avatarDiv);
        messageEl.appendChild(contentDiv);
        
        chatMessages.appendChild(messageEl);
    }

    function displayMessages() {
        const chatMessages = document.getElementById('chatMessages');
        if (!chatMessages) return;
        
        // Clear existing messages
        chatMessages.innerHTML = '';
        
        // Filter messages based on current filter state
        let messagesToDisplay = appState.messages || [];
        const currentUserId = currentAuthUser?.uid;
        
        if (mentionState.currentFilter === 'mentions' && currentUserId) {
            // Filter to only messages that mention current user
            messagesToDisplay = messagesToDisplay.filter(msg => 
                msg.mentions && msg.mentions.includes(currentUserId)
            );
            
            // Show empty state if no mentions
            if (messagesToDisplay.length === 0) {
                const emptyState = document.createElement('div');
                emptyState.className = 'chat-empty-state';
                emptyState.style.cssText = 'text-align: center; padding: 40px 20px; color: var(--text-secondary);';
                emptyState.innerHTML = `
                    <i class="fas fa-at" style="font-size: 32px; margin-bottom: 12px; opacity: 0.5;"></i>
                    <p style="margin: 0; font-size: 14px;">No messages mentioning you yet</p>
                `;
                chatMessages.appendChild(emptyState);
                return;
            }
        }
        
        // Display filtered messages with date separators
        if (messagesToDisplay.length > 0) {
            let lastDate = null;
            
            messagesToDisplay.forEach(msg => {
                // Get the date of the current message
                const messageDate = msg.timestamp ? new Date(msg.timestamp.seconds * 1000) : new Date();
                const messageDateStr = messageDate.toDateString();
                
                // Add date separator if the date has changed
                if (lastDate !== messageDateStr) {
                    const dateSeparator = document.createElement('div');
                    dateSeparator.className = 'date-separator';
                    
                    // Format date label
                    const today = new Date().toDateString();
                    const yesterday = new Date(Date.now() - 86400000).toDateString();
                    let dateLabel;
                    
                    if (messageDateStr === today) {
                        dateLabel = 'Today';
                    } else if (messageDateStr === yesterday) {
                        dateLabel = 'Yesterday';
                    } else {
                        dateLabel = messageDate.toLocaleDateString('en-US', { 
                            weekday: 'long', 
                            year: 'numeric', 
                            month: 'long', 
                            day: 'numeric' 
                        });
                    }
                    
                    const dateSpan = document.createElement('span');
                    dateSpan.textContent = dateLabel; // Use textContent instead of innerHTML
                    dateSeparator.appendChild(dateSpan);
                    chatMessages.appendChild(dateSeparator);
                    lastDate = messageDateStr;
                }
                
                displayMessage(msg);
            });
            
            // Scroll to bottom after rendering
            scrollChatToBottom();
        }
    }
    
    // Helper function to scroll chat to bottom
    function scrollChatToBottom() {
        const chatMessages = document.getElementById('chatMessages');
        if (chatMessages) {
            requestAnimationFrame(() => {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            });
        }
    }
    
    // Make displayMessages and scroll helper available globally
    window.displayMessages = displayMessages;
    window.scrollChatToBottom = scrollChatToBottom;
    
    // Function to switch tabs programmatically
    window.switchTab = function(sectionName) {
        const navItems = document.querySelectorAll('.nav-item');
        const sections = document.querySelectorAll('.content-section');
        
        // Update active nav item
        navItems.forEach(nav => {
            if (nav.dataset.section === sectionName) {
                nav.classList.add('active');
            } else {
                nav.classList.remove('active');
            }
        });
        
        // Update active section
        sections.forEach(section => section.classList.remove('active'));
        const targetSection = document.getElementById(`${sectionName}-section`);
        if (targetSection) {
            targetSection.classList.add('active');
        }
        
        appState.currentSection = sectionName;
        
        // Clear chat notification badge when navigating to chat
        if (sectionName === 'chat') {
            const chatBadge = document.getElementById('chatNotificationBadge');
            if (chatBadge) {
                chatBadge.style.display = 'none';
                chatBadge.textContent = '0';
            }
            // Store last seen timestamp for chat
            if (appState.currentTeamId) {
                localStorage.setItem(`chatLastSeen_${appState.currentTeamId}`, Date.now().toString());
            }
            // Scroll to bottom when opening chat
            setTimeout(() => scrollChatToBottom(), 100);
        }
        
        // Initialize section-specific functionality
        if (sectionName === 'settings') {
            loadAccountSettings();
        } else if (sectionName === 'team') {
            initTeamSection();
        }
    };

    function loadMessages() {
        const savedMessages = loadFromLocalStorage('messages');
        if (savedMessages) {
            appState.messages = savedMessages;
            savedMessages.forEach(msg => displayMessage(msg));
        }
    }
}

// ===================================
// @MENTION SYSTEM FUNCTIONS
// ===================================

/**
 * Handle input changes in chat to detect @ mentions
 */
function handleMentionInput(e) {
    const input = e.target;
    const cursorPos = input.selectionStart;
    const text = input.value;
    
    // Find the last @ before cursor
    let atIndex = -1;
    for (let i = cursorPos - 1; i >= 0; i--) {
        if (text[i] === '@') {
            // Check if it's a valid mention start (beginning or preceded by space)
            if (i === 0 || /\s/.test(text[i - 1])) {
                atIndex = i;
                break;
            }
        }
        // Stop if we hit a space (no @ in this word)
        if (text[i] === ' ') break;
    }
    
    if (atIndex >= 0) {
        // Extract search query after @
        const query = text.substring(atIndex + 1, cursorPos).toLowerCase();
        
        // Don't show dropdown if query contains spaces (mention completed)
        if (query.includes(' ')) {
            closeMentionDropdown();
            return;
        }
        
        // Filter teammates based on query
        const teammates = appState.teammates || [];
        mentionState.filteredTeammates = teammates.filter(t => {
            const displayName = (t.displayName || t.name || '').toLowerCase();
            const email = (t.email || '').toLowerCase();
            return displayName.includes(query) || email.includes(query) || fuzzyMatch(query, displayName);
        });
        
        mentionState.isActive = true;
        mentionState.startIndex = atIndex;
        mentionState.selectedIndex = 0;
        
        showMentionDropdown();
    } else {
        closeMentionDropdown();
    }
}

/**
 * Simple fuzzy matching for mention search
 */
function fuzzyMatch(query, target) {
    if (!query) return true;
    let queryIdx = 0;
    for (let i = 0; i < target.length && queryIdx < query.length; i++) {
        if (target[i] === query[queryIdx]) {
            queryIdx++;
        }
    }
    return queryIdx === query.length;
}

/**
 * Handle keyboard navigation in mention dropdown
 */
function handleMentionKeydown(e) {
    const dropdown = document.getElementById('mentionDropdown');
    if (!dropdown || dropdown.style.display === 'none') return;
    
    switch (e.key) {
        case 'ArrowDown':
            e.preventDefault();
            mentionState.selectedIndex = Math.min(
                mentionState.selectedIndex + 1,
                mentionState.filteredTeammates.length - 1
            );
            updateMentionSelection();
            break;
            
        case 'ArrowUp':
            e.preventDefault();
            mentionState.selectedIndex = Math.max(mentionState.selectedIndex - 1, 0);
            updateMentionSelection();
            break;
            
        case 'Enter':
        case 'Tab':
            e.preventDefault();
            if (mentionState.filteredTeammates.length > 0) {
                selectMention(mentionState.filteredTeammates[mentionState.selectedIndex]);
            }
            break;
            
        case 'Escape':
            e.preventDefault();
            closeMentionDropdown();
            break;
    }
}

/**
 * Show the mention dropdown with filtered teammates
 */
function showMentionDropdown() {
    const dropdown = document.getElementById('mentionDropdown');
    if (!dropdown) return;
    
    dropdown.innerHTML = '';
    
    if (mentionState.filteredTeammates.length === 0) {
        dropdown.innerHTML = '<div class="mention-dropdown-empty">No teammates found</div>';
    } else {
        const header = document.createElement('div');
        header.className = 'mention-dropdown-header';
        header.textContent = 'Mention a teammate';
        dropdown.appendChild(header);
        
        mentionState.filteredTeammates.forEach((teammate, index) => {
            const item = document.createElement('div');
            item.className = 'mention-item' + (index === mentionState.selectedIndex ? ' selected' : '');
            item.dataset.index = index;
            
            // Use unified identity resolver for consistent display
            const identity = getIdentity(teammate.id, teammate.name);
            
            // Avatar
            const avatar = document.createElement('div');
            avatar.className = 'mention-item-avatar';
            avatar.style.background = identity.avatarColor;
            avatar.textContent = identity.initials;
            
            // Info
            const info = document.createElement('div');
            info.className = 'mention-item-info';
            
            const name = document.createElement('div');
            name.className = 'mention-item-name';
            name.textContent = identity.displayName;
            
            const role = document.createElement('div');
            role.className = 'mention-item-role';
            role.textContent = teammate.occupation || teammate.role || '';
            
            info.appendChild(name);
            info.appendChild(role);
            
            item.appendChild(avatar);
            item.appendChild(info);
            
            // Click to select
            item.addEventListener('click', () => selectMention(teammate));
            
            // Hover to highlight
            item.addEventListener('mouseenter', () => {
                mentionState.selectedIndex = index;
                updateMentionSelection();
            });
            
            dropdown.appendChild(item);
        });
    }
    
    dropdown.style.display = 'block';
}

/**
 * Update visual selection in dropdown
 */
function updateMentionSelection() {
    const dropdown = document.getElementById('mentionDropdown');
    if (!dropdown) return;
    
    dropdown.querySelectorAll('.mention-item').forEach((item, index) => {
        item.classList.toggle('selected', index === mentionState.selectedIndex);
    });
    
    // Scroll selected item into view
    const selected = dropdown.querySelector('.mention-item.selected');
    if (selected) {
        selected.scrollIntoView({ block: 'nearest' });
    }
}

/**
 * Select a teammate from the mention dropdown
 */
function selectMention(teammate) {
    const input = document.getElementById('chatInput');
    if (!input || !teammate) return;
    
    const text = input.value;
    const beforeMention = text.substring(0, mentionState.startIndex);
    const afterMention = text.substring(input.selectionStart);
    
    // Insert @DisplayName using displayName field
    const displayName = teammate.displayName || teammate.name || 'Unknown';
    const mentionText = `@${displayName} `;
    input.value = beforeMention + mentionText + afterMention;
    
    // Position cursor after the mention
    const newCursorPos = mentionState.startIndex + mentionText.length;
    input.setSelectionRange(newCursorPos, newCursorPos);
    input.focus();
    
    closeMentionDropdown();
}

/**
 * Close the mention dropdown
 */
function closeMentionDropdown() {
    const dropdown = document.getElementById('mentionDropdown');
    if (dropdown) {
        dropdown.style.display = 'none';
    }
    mentionState.isActive = false;
    mentionState.startIndex = -1;
    mentionState.selectedIndex = 0;
    mentionState.filteredTeammates = [];
}

/**
 * Extract mentioned user IDs from message text
 * Looks for @Name patterns and matches to teammates
 */
function extractMentions(text) {
    const mentions = [];
    const teammates = appState.teammates || [];
    
    if (!teammates.length) return mentions;
    
    // Sort teammates by name length (longest first) for accurate matching
    const sortedTeammates = [...teammates].sort((a, b) => 
        (b.displayName || b.name || '').length - (a.displayName || a.name || '').length
    );
    
    // Build regex to match all teammate names after @
    for (const teammate of sortedTeammates) {
        const name = teammate.displayName || teammate.name || '';
        if (!name) continue;
        
        // Escape special regex characters in name
        const escapedName = name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        // Match @Name with word boundaries: start of string or whitespace before, and whitespace/punctuation/end after
        const regex = new RegExp(`(?:^|\\s)@${escapedName}(?=\\s|$|[.,!?;:])`, 'gi');
        
        // Use match() instead of test() to avoid regex state issues
        if (text.match(regex) && !mentions.includes(teammate.id)) {
            mentions.push(teammate.id);
        }
    }
    
    return mentions;
}

/**
 * Send notifications to mentioned users
 */
async function sendMentionNotifications(mentionedUserIds, messageText) {
    if (!mentionedUserIds || mentionedUserIds.length === 0) return;
    if (!currentAuthUser || !appState.currentTeamId) return;
    
    const currentUserId = currentAuthUser.uid;
    const senderName = appState.currentUser || 'Someone';
    
    // Truncate message for notification preview
    const preview = messageText.length > 50 
        ? messageText.substring(0, 50) + '...' 
        : messageText;
    
    for (const userId of mentionedUserIds) {
        // Don't notify yourself
        if (userId === currentUserId) continue;
        
        try {
            // Add notification to user's notification collection
            const { doc, collection, addDoc, serverTimestamp } = 
                await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
            
            const notificationsRef = collection(db, 'users', userId, 'notifications');
            await addDoc(notificationsRef, {
                type: 'mention',
                title: `${senderName} mentioned you`,
                message: preview,
                teamId: appState.currentTeamId,
                senderId: currentUserId,
                read: false,
                timestamp: serverTimestamp()
            });
            
            debugLog('ðŸ“£ Sent mention notification to:', userId);
        } catch (error) {
            console.error('Failed to send mention notification:', error);
        }
    }
}

/**
 * Render message text with mention pills
 */
function renderMessageWithMentions(text, mentions = []) {
    if (!mentions || mentions.length === 0) {
        // No mentions, return sanitized text
        const div = document.createElement('span');
        div.textContent = text;
        return div;
    }
    
    const teammates = appState.teammates || [];
    const currentUserId = currentAuthUser?.uid;
    const container = document.createElement('span');
    
    // Build a map of mentioned user names
    const mentionedUsers = mentions.map(userId => {
        const teammate = teammates.find(t => t.id === userId);
        return teammate ? { id: userId, name: teammate.displayName || teammate.name } : null;
    }).filter(Boolean);
    
    // Create regex to match @Name patterns for mentioned users
    if (mentionedUsers.length === 0) {
        container.textContent = text;
        return container;
    }
    
    // Sort by name length (longest first) to avoid partial matches
    mentionedUsers.sort((a, b) => b.name.length - a.name.length);
    
    // Build regex pattern
    const namePatterns = mentionedUsers.map(u => 
        '@' + u.name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
    ).join('|');
    const mentionRegex = new RegExp(`(${namePatterns})`, 'gi');
    
    // Split text and process
    const parts = text.split(mentionRegex);
    
    parts.forEach(part => {
        if (!part) return;
        
        // Check if this part is a mention
        const matchedUser = mentionedUsers.find(u => 
            part.toLowerCase() === `@${u.name.toLowerCase()}`
        );
        
        if (matchedUser) {
            const pill = document.createElement('span');
            pill.className = 'mention-pill';
            if (matchedUser.id === currentUserId) {
                pill.classList.add('mention-me');
            }
            pill.textContent = part;
            pill.title = `Click to view ${matchedUser.name}`;
            pill.addEventListener('click', (e) => {
                e.stopPropagation();
                // Navigate to Team tab and scroll to teammate
                navigateToTeammate(matchedUser.id);
            });
            container.appendChild(pill);
        } else {
            const span = document.createElement('span');
            span.textContent = part;
            container.appendChild(span);
        }
    });
    
    return container;
}

// ===================================
// CHAT REPLY SYSTEM FUNCTIONS
// ===================================

/**
 * Set the reply context when user clicks Reply on a message
 * @param {string} messageId - ID of the message being replied to
 * @param {string} userId - User ID of the original message author
 * @param {string} displayName - Display name of the original author
 * @param {string} messageText - The text of the original message (for preview)
 */
function setReplyContext(messageId, userId, displayName, messageText) {
    // Create preview text (first 80 characters)
    const previewText = messageText.length > 80 
        ? messageText.substring(0, 80) + '...' 
        : messageText;
    
    replyState.currentReply = {
        messageId,
        userId,
        displayName,
        previewText
    };
    
    // Update the UI
    showReplyPreviewBar(displayName, previewText);
    
    // Focus the input
    const chatInput = document.getElementById('chatInput');
    if (chatInput) {
        chatInput.focus();
    }
}

/**
 * Clear the current reply context
 */
function clearReplyContext() {
    replyState.currentReply = null;
    hideReplyPreviewBar();
}

/**
 * Show the reply preview bar above the input
 * @param {string} name - Name of the person being replied to
 * @param {string} preview - Preview of the message being replied to
 */
function showReplyPreviewBar(name, preview) {
    const bar = document.getElementById('replyPreviewBar');
    const nameEl = document.getElementById('replyToName');
    const previewEl = document.getElementById('replyToPreview');
    
    if (bar && nameEl && previewEl) {
        nameEl.textContent = name;
        previewEl.textContent = preview;
        bar.style.display = 'flex';
    }
}

/**
 * Hide the reply preview bar
 */
function hideReplyPreviewBar() {
    const bar = document.getElementById('replyPreviewBar');
    if (bar) {
        bar.style.display = 'none';
    }
}

/**
 * Handle /r command in chat input for quick reply
 * Detects "/r " at the start of input and auto-sets reply context
 */
function handleReplyCommand(e) {
    const input = e.target;
    const value = input.value;
    
    // Check if input starts with "/r " (with space) or "/r" followed by more text
    if (value.startsWith('/r ') || value === '/r') {
        // Only process if we don't already have a reply context set
        if (replyState.currentReply) return;
        
        // Find a suitable message to reply to
        const currentUserId = currentAuthUser?.uid;
        const messages = appState.messages || [];
        
        // Strategy: First try to find the last message that mentions current user,
        // otherwise find the last message from someone else
        let targetMessage = null;
        
        // Look for last message mentioning current user
        for (let i = messages.length - 1; i >= 0; i--) {
            const msg = messages[i];
            if (msg.mentions && msg.mentions.includes(currentUserId) && msg.userId !== currentUserId) {
                targetMessage = msg;
                break;
            }
        }
        
        // If no mention found, find last message from someone else
        if (!targetMessage) {
            for (let i = messages.length - 1; i >= 0; i--) {
                const msg = messages[i];
                if (msg.userId !== currentUserId) {
                    targetMessage = msg;
                    break;
                }
            }
        }
        
        if (targetMessage) {
            // Get author name
            let authorName = targetMessage.author || 'User';
            const sender = appState.teammates?.find(t => t.id === targetMessage.userId);
            if (sender) {
                authorName = sender.name;
            }
            
            // Set reply context
            setReplyContext(
                targetMessage.id,
                targetMessage.userId,
                authorName,
                targetMessage.text
            );
            
            // Remove /r from input, keeping any text after the space
            if (value.startsWith('/r ')) {
                input.value = value.substring(3);
            } else {
                input.value = '';
            }
        } else {
            // No suitable message found
            if (value === '/r ' || value === '/r') {
                showToast('No recent message to reply to.', 'info', 3000);
                input.value = '';
            }
        }
    }
}

/**
 * Scroll to the original message and highlight it
 * @param {string} messageId - ID of the message to scroll to
 */
function scrollToOriginalMessage(messageId) {
    const messageEl = document.querySelector(`.message[data-message-id="${messageId}"]`);
    
    if (messageEl) {
        // Scroll to the message
        messageEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
        // Add highlight effect
        messageEl.classList.add('reply-highlight');
        
        // Remove highlight after animation completes
        setTimeout(() => {
            messageEl.classList.remove('reply-highlight');
        }, 2000);
    } else {
        showToast('Original message not found in current view', 'info', 3000);
    }
}

/**
 * Reset reply state when switching teams or contexts
 * Called when team changes or chat panel closes
 */
function resetReplyState() {
    clearReplyContext();
}

// ===================================
// REACTIONS SYSTEM
// ===================================

/**
 * Toggle the reactions bar for a message
 * @param {string} messageId - ID of the message
 * @param {HTMLElement} messageEl - The message element
 */
function toggleReactionsBar(messageId, messageEl) {
    // If clicking the same message, close the bar
    if (reactionsState.activeMessageId === messageId && reactionsState.reactionsBarElement) {
        closeReactionsBar();
        return;
    }
    
    // Close any existing bar
    closeReactionsBar();
    
    // Create and show new reactions bar
    showReactionsBar(messageId, messageEl);
}

/**
 * Show the reactions bar above a message (WhatsApp/Instagram style)
 * @param {string} messageId - ID of the message
 * @param {HTMLElement} messageEl - The message element
 */
function showReactionsBar(messageId, messageEl) {
    const bar = document.createElement('div');
    bar.className = 'reactions-bar';
    bar.dataset.messageId = messageId;
    
    // Add emoji buttons
    REACTION_EMOJIS.forEach(emoji => {
        const btn = document.createElement('button');
        btn.className = 'reaction-emoji-btn';
        btn.textContent = emoji;
        btn.onclick = (e) => {
            e.stopPropagation();
            e.preventDefault();
            toggleReaction(messageId, emoji);
        };
        // Prevent touch events from bubbling
        btn.ontouchend = (e) => {
            e.stopPropagation();
            e.preventDefault();
            toggleReaction(messageId, emoji);
        };
        bar.appendChild(btn);
    });
    
    // Append to body for proper positioning (fixed)
    document.body.appendChild(bar);
    
    // Position the bar - WhatsApp style (above the message bubble, slightly to the right)
    const messageContent = messageEl.querySelector('.message-content');
    const messageBubble = messageEl.querySelector('.message-text');
    const targetEl = messageBubble || messageContent || messageEl;
    const rect = targetEl.getBoundingClientRect();
    const chatContainer = document.getElementById('chatMessages');
    const chatRect = chatContainer?.getBoundingClientRect() || { left: 0, right: window.innerWidth };
    
    // Calculate position
    const barHeight = 48; // Approximate height of bar
    const barWidth = 220; // Approximate width of bar
    const padding = 8;
    
    // Vertical position: above the message bubble
    let top = rect.top - barHeight - padding;
    
    // If too close to top of viewport, position below
    if (top < 60) {
        top = rect.bottom + padding;
    }
    
    // Horizontal position: centered on message, but keep within viewport
    let left = rect.left + (rect.width / 2) - (barWidth / 2);
    
    // Clamp to viewport bounds
    const minLeft = chatRect.left + 8;
    const maxLeft = chatRect.right - barWidth - 8;
    left = Math.max(minLeft, Math.min(maxLeft, left));
    
    // Apply position
    bar.style.position = 'fixed';
    bar.style.top = `${top}px`;
    bar.style.left = `${left}px`;
    bar.style.zIndex = '10001';
    
    reactionsState.activeMessageId = messageId;
    reactionsState.reactionsBarElement = bar;
    
    // Animate in
    requestAnimationFrame(() => {
        bar.classList.add('active');
    });
}

/**
 * Close the reactions bar
 */
function closeReactionsBar() {
    if (reactionsState.reactionsBarElement) {
        reactionsState.reactionsBarElement.classList.remove('active');
        // Remove after animation
        setTimeout(() => {
            if (reactionsState.reactionsBarElement) {
                reactionsState.reactionsBarElement.remove();
                reactionsState.reactionsBarElement = null;
            }
        }, 150);
    }
    reactionsState.activeMessageId = null;
    // Clear long press state
    if (reactionsState.longPressTimer) {
        clearTimeout(reactionsState.longPressTimer);
        reactionsState.longPressTimer = null;
    }
    reactionsState.longPressTriggered = false;
}

/**
 * Toggle a reaction on a message
 * Uses reactions subcollection: /teams/{teamId}/messages/{messageId}/reactions/{userId}
 * Each user can only modify their own reaction document
 * @param {string} messageId - ID of the message
 * @param {string} emoji - The emoji to toggle
 */
async function toggleReaction(messageId, emoji) {
    if (!currentAuthUser || !appState.currentTeamId || !db) return;
    
    const userId = currentAuthUser.uid;
    
    try {
        const { doc, getDoc, setDoc, deleteDoc, serverTimestamp } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        // Reference to user's reaction document in the subcollection
        const reactionRef = doc(db, 'teams', appState.currentTeamId, 'messages', messageId, 'reactions', userId);
        const reactionDoc = await getDoc(reactionRef);
        
        if (reactionDoc.exists()) {
            const currentEmoji = reactionDoc.data().emoji;
            if (currentEmoji === emoji) {
                // Same emoji - remove reaction (toggle off)
                await deleteDoc(reactionRef);
            } else {
                // Different emoji - update to new emoji
                await setDoc(reactionRef, {
                    emoji: emoji,
                    userId: userId,
                    updatedAt: serverTimestamp()
                });
            }
        } else {
            // No existing reaction - create new one
            await setDoc(reactionRef, {
                emoji: emoji,
                userId: userId,
                updatedAt: serverTimestamp()
            });
        }
        
        // Refresh the reactions display for this message
        await refreshMessageReactions(messageId);
        
        // Close reactions bar after toggling
        closeReactionsBar();
        
    } catch (error) {
        console.error('Error toggling reaction:', error);
        showToast('Failed to update reaction', 'error');
    }
}

/**
 * Fetch and refresh reactions display for a specific message
 * @param {string} messageId - ID of the message
 */
async function refreshMessageReactions(messageId) {
    try {
        const { collection, getDocs } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const reactionsRef = collection(db, 'teams', appState.currentTeamId, 'messages', messageId, 'reactions');
        const reactionsSnapshot = await getDocs(reactionsRef);
        
        // Aggregate reactions by emoji
        const reactionsByEmoji = {};
        reactionsSnapshot.forEach(doc => {
            const data = doc.data();
            const emoji = data.emoji;
            if (emoji) {
                if (!reactionsByEmoji[emoji]) {
                    reactionsByEmoji[emoji] = [];
                }
                reactionsByEmoji[emoji].push(doc.id); // doc.id is the userId
            }
        });
        
        // Find the reactions display container for this message
        const container = document.querySelector(`.message-reactions-display[data-message-id="${messageId}"]`);
        if (container) {
            renderReactionsDisplay(container, reactionsByEmoji);
        }
    } catch (error) {
        console.error('Error refreshing reactions:', error);
    }
}

/**
 * Load reactions for a message from the subcollection
 * @param {string} messageId - ID of the message
 * @returns {Object} Aggregated reactions { emoji: [userIds] }
 */
async function loadMessageReactions(messageId) {
    if (!db || !appState.currentTeamId) return {};
    
    try {
        const { collection, getDocs } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const reactionsRef = collection(db, 'teams', appState.currentTeamId, 'messages', messageId, 'reactions');
        const reactionsSnapshot = await getDocs(reactionsRef);
        
        // Aggregate reactions by emoji
        const reactionsByEmoji = {};
        reactionsSnapshot.forEach(doc => {
            const data = doc.data();
            const emoji = data.emoji;
            if (emoji) {
                if (!reactionsByEmoji[emoji]) {
                    reactionsByEmoji[emoji] = [];
                }
                reactionsByEmoji[emoji].push(doc.id);
            }
        });
        
        return reactionsByEmoji;
    } catch (error) {
        console.error('Error loading reactions:', error);
        return {};
    }
}

/**
 * Render the reactions display for a message
 * @param {HTMLElement} container - The container element
 * @param {Object} reactions - Reactions object { emoji: [userIds] }
 */
function renderReactionsDisplay(container, reactions) {
    container.innerHTML = '';
    
    if (!reactions || Object.keys(reactions).length === 0) {
        container.style.display = 'none';
        return;
    }
    
    let hasReactions = false;
    
    Object.entries(reactions).forEach(([emoji, userIds]) => {
        if (userIds && userIds.length > 0) {
            hasReactions = true;
            const chip = document.createElement('button');
            chip.className = 'reaction-chip';
            
            // Highlight if current user reacted
            if (currentAuthUser && userIds.includes(currentAuthUser.uid)) {
                chip.classList.add('user-reacted');
            }
            
            chip.innerHTML = `<span class="reaction-emoji">${emoji}</span><span class="reaction-count">${userIds.length}</span>`;
            chip.onclick = (e) => {
                e.stopPropagation();
                const messageId = container.dataset.messageId;
                toggleReaction(messageId, emoji);
            };
            
            // Tooltip showing who reacted
            const names = userIds.map(uid => {
                const teammate = appState.teammates?.find(t => t.id === uid);
                return teammate?.name || 'Unknown';
            }).join(', ');
            chip.title = names;
            
            container.appendChild(chip);
        }
    });
    
    container.style.display = hasReactions ? 'flex' : 'none';
}

/**
 * Close reactions bar on scroll or click outside
 */
function initReactionsListeners() {
    const chatMessages = document.getElementById('chatMessages');
    
    // Close on scroll
    if (chatMessages) {
        chatMessages.addEventListener('scroll', closeReactionsBar);
    }
    
    // Close on click outside
    document.addEventListener('click', (e) => {
        if (reactionsState.reactionsBarElement && 
            !e.target.closest('.reactions-bar') && 
            !e.target.closest('.message')) {
            closeReactionsBar();
        }
    });
}

/**
 * Initialize chat emoji picker
 */
function initChatEmojiPicker() {
    const chatInput = document.getElementById('chatInput');
    const emojiBtn = document.getElementById('chatEmojiBtn');
    const popover = document.getElementById('chatEmojiPopover');
    const searchInput = document.getElementById('chatEmojiSearch');
    const emojiGrid = document.getElementById('chatEmojiGrid');
    const categoryTabs = document.getElementById('chatEmojiCategoryTabs');
    
    if (!chatInput || !emojiBtn || !popover || !emojiGrid) return;
    
    // Reuse emoji data from doc emoji picker (or define separately)
    const emojiData = {
        smileys: ['ðŸ˜€', 'ðŸ˜ƒ', 'ðŸ˜„', 'ðŸ˜', 'ðŸ˜†', 'ðŸ˜…', 'ðŸ¤£', 'ðŸ˜‚', 'ðŸ™‚', 'ðŸ™ƒ', 'ðŸ˜‰', 'ðŸ˜Š', 'ðŸ˜‡', 'ðŸ¥°', 'ðŸ˜', 'ðŸ¤©', 'ðŸ˜˜', 'ðŸ˜—', 'ðŸ˜š', 'ðŸ˜™', 'ðŸ¥²', 'ðŸ˜‹', 'ðŸ˜›', 'ðŸ˜œ', 'ðŸ¤ª', 'ðŸ˜', 'ðŸ¤‘', 'ðŸ¤—', 'ðŸ¤­', 'ðŸ¤«', 'ðŸ¤”', 'ðŸ¤', 'ðŸ¤¨', 'ðŸ˜', 'ðŸ˜‘', 'ðŸ˜¶', 'ðŸ˜', 'ðŸ˜’', 'ðŸ™„', 'ðŸ˜¬', 'ðŸ¤¥', 'ðŸ˜Œ', 'ðŸ˜”', 'ðŸ˜ª', 'ðŸ¤¤', 'ðŸ˜´', 'ðŸ˜·', 'ðŸ¤’', 'ðŸ¤•', 'ðŸ¤¢', 'ðŸ¤®', 'ðŸ¤§', 'ðŸ¥µ', 'ðŸ¥¶', 'ðŸ¥´', 'ðŸ˜µ', 'ðŸ¤¯', 'ðŸ¤ ', 'ðŸ¥³', 'ðŸ¥¸', 'ðŸ˜Ž', 'ðŸ¤“', 'ðŸ§', 'ðŸ˜•', 'ðŸ˜Ÿ', 'ðŸ™', 'â˜¹ï¸', 'ðŸ˜®', 'ðŸ˜¯', 'ðŸ˜²', 'ðŸ˜³', 'ðŸ¥º', 'ðŸ˜¦', 'ðŸ˜§', 'ðŸ˜¨', 'ðŸ˜°', 'ðŸ˜¥', 'ðŸ˜¢', 'ðŸ˜­', 'ðŸ˜±', 'ðŸ˜–', 'ðŸ˜£', 'ðŸ˜ž', 'ðŸ˜“', 'ðŸ˜©', 'ðŸ˜«', 'ðŸ¥±', 'ðŸ˜¤', 'ðŸ˜¡', 'ðŸ˜ ', 'ðŸ¤¬', 'ðŸ˜ˆ', 'ðŸ‘¿', 'ðŸ’€', 'â˜ ï¸', 'ðŸ’©', 'ðŸ¤¡', 'ðŸ‘¹', 'ðŸ‘º', 'ðŸ‘»', 'ðŸ‘½', 'ðŸ‘¾', 'ðŸ¤–'],
        people: ['ðŸ‘‹', 'ðŸ¤š', 'ðŸ–ï¸', 'âœ‹', 'ðŸ––', 'ðŸ‘Œ', 'ðŸ¤Œ', 'ðŸ¤', 'âœŒï¸', 'ðŸ¤ž', 'ðŸ¤Ÿ', 'ðŸ¤˜', 'ðŸ¤™', 'ðŸ‘ˆ', 'ðŸ‘‰', 'ðŸ‘†', 'ðŸ–•', 'ðŸ‘‡', 'â˜ï¸', 'ðŸ‘', 'ðŸ‘Ž', 'âœŠ', 'ðŸ‘Š', 'ðŸ¤›', 'ðŸ¤œ', 'ðŸ‘', 'ðŸ™Œ', 'ðŸ‘', 'ðŸ¤²', 'ðŸ¤', 'ðŸ™', 'âœï¸', 'ðŸ’…', 'ðŸ¤³', 'ðŸ’ª', 'ðŸ¦¾', 'ðŸ¦¿', 'ðŸ¦µ', 'ðŸ¦¶', 'ðŸ‘‚', 'ðŸ¦»', 'ðŸ‘ƒ', 'ðŸ§ ', 'ðŸ«€', 'ðŸ«', 'ðŸ¦·', 'ðŸ¦´', 'ðŸ‘€', 'ðŸ‘ï¸', 'ðŸ‘…', 'ðŸ‘„', 'ðŸ‘¶', 'ðŸ§’', 'ðŸ‘¦', 'ðŸ‘§', 'ðŸ§‘', 'ðŸ‘±', 'ðŸ‘¨', 'ðŸ§”', 'ðŸ‘©', 'ðŸ§“', 'ðŸ‘´', 'ðŸ‘µ', 'ðŸ™', 'ðŸ™Ž', 'ðŸ™…', 'ðŸ™†', 'ðŸ’', 'ðŸ™‹', 'ðŸ§', 'ðŸ™‡', 'ðŸ¤¦', 'ðŸ¤·', 'ðŸ‘®', 'ðŸ•µï¸', 'ðŸ’‚', 'ðŸ¥·', 'ðŸ‘·', 'ðŸ¤´', 'ðŸ‘¸', 'ðŸ‘³', 'ðŸ‘²', 'ðŸ§•', 'ðŸ¤µ', 'ðŸ‘°', 'ðŸ¤°', 'ðŸ¤±', 'ðŸ‘¼', 'ðŸŽ…', 'ðŸ¤¶', 'ðŸ¦¸', 'ðŸ¦¹', 'ðŸ§™', 'ðŸ§š', 'ðŸ§›', 'ðŸ§œ', 'ðŸ§', 'ðŸ§ž', 'ðŸ§Ÿ', 'ðŸ’†', 'ðŸ’‡', 'ðŸš¶', 'ðŸ§', 'ðŸ§Ž', 'ðŸƒ', 'ðŸ’ƒ', 'ðŸ•º', 'ðŸ•´ï¸', 'ðŸ‘¯', 'ðŸ§–', 'ðŸ§—', 'ðŸ¤¸', 'ðŸŒï¸', 'ðŸ‡', 'â›·ï¸', 'ðŸ‚', 'ðŸ‹ï¸', 'ðŸ¤¼', 'ðŸ¤½', 'ðŸ¤¾', 'ðŸ¤º', 'â›¹ï¸', 'ðŸŠ', 'ðŸš£', 'ðŸ§˜', 'ðŸ›€', 'ðŸ›Œ'],
        nature: ['ðŸ¶', 'ðŸ±', 'ðŸ­', 'ðŸ¹', 'ðŸ°', 'ðŸ¦Š', 'ðŸ»', 'ðŸ¼', 'ðŸ»â€â„ï¸', 'ðŸ¨', 'ðŸ¯', 'ðŸ¦', 'ðŸ®', 'ðŸ·', 'ðŸ½', 'ðŸ¸', 'ðŸµ', 'ðŸ™ˆ', 'ðŸ™‰', 'ðŸ™Š', 'ðŸ’', 'ðŸ”', 'ðŸ§', 'ðŸ¦', 'ðŸ¤', 'ðŸ£', 'ðŸ¥', 'ðŸ¦†', 'ðŸ¦…', 'ðŸ¦‰', 'ðŸ¦‡', 'ðŸº', 'ðŸ—', 'ðŸ´', 'ðŸ¦„', 'ðŸ', 'ðŸª±', 'ðŸ›', 'ðŸ¦‹', 'ðŸŒ', 'ðŸž', 'ðŸœ', 'ðŸª°', 'ðŸª²', 'ðŸª³', 'ðŸ¦Ÿ', 'ðŸ¦—', 'ðŸ•·ï¸', 'ðŸ•¸ï¸', 'ðŸ¦‚', 'ðŸ¢', 'ðŸ', 'ðŸ¦Ž', 'ðŸ¦–', 'ðŸ¦•', 'ðŸ™', 'ðŸ¦‘', 'ðŸ¦', 'ðŸ¦ž', 'ðŸ¦€', 'ðŸ¡', 'ðŸ ', 'ðŸŸ', 'ðŸ¬', 'ðŸ³', 'ðŸ‹', 'ðŸ¦ˆ', 'ðŸŠ', 'ðŸ…', 'ðŸ†', 'ðŸ¦“', 'ðŸ¦', 'ðŸ¦§', 'ðŸ¦£', 'ðŸ˜', 'ðŸ¦›', 'ðŸ¦', 'ðŸª', 'ðŸ«', 'ðŸ¦’', 'ðŸ¦˜', 'ðŸ¦¬', 'ðŸƒ', 'ðŸ‚', 'ðŸ„', 'ðŸŽ', 'ðŸ–', 'ðŸ', 'ðŸ‘', 'ðŸ¦™', 'ðŸ', 'ðŸ¦Œ', 'ðŸ•', 'ðŸ©', 'ðŸ¦®', 'ðŸ•â€ðŸ¦º', 'ðŸˆ', 'ðŸˆâ€â¬›', 'ðŸª¶', 'ðŸ“', 'ðŸ¦ƒ', 'ðŸ¦¤', 'ðŸ¦š', 'ðŸ¦œ', 'ðŸ¦¢', 'ðŸ¦©', 'ðŸ•Šï¸', 'ðŸ‡', 'ðŸ¦', 'ðŸ¦¨', 'ðŸ¦¡', 'ðŸ¦«', 'ðŸ¦¦', 'ðŸ¦¥', 'ðŸ', 'ðŸ€', 'ðŸ¿ï¸', 'ðŸ¦”', 'ðŸŒµ', 'ðŸŽ„', 'ðŸŒ²', 'ðŸŒ³', 'ðŸŒ´', 'ðŸªµ', 'ðŸŒ±', 'ðŸŒ¿', 'â˜˜ï¸', 'ðŸ€', 'ðŸŽ', 'ðŸª´', 'ðŸŽ‹', 'ðŸƒ', 'ðŸ‚', 'ðŸ', 'ðŸªº', 'ðŸª¹', 'ðŸ„', 'ðŸš', 'ðŸª¸', 'ðŸª¨', 'ðŸŒ¾', 'ðŸ’', 'ðŸŒ·', 'ðŸŒ¹', 'ðŸ¥€', 'ðŸŒº', 'ðŸŒ¸', 'ðŸŒ¼', 'ðŸŒ»', 'ðŸŒž', 'ðŸŒ', 'ðŸŒ›', 'ðŸŒœ', 'ðŸŒš', 'ðŸŒ•', 'ðŸŒ–', 'ðŸŒ—', 'ðŸŒ˜', 'ðŸŒ‘', 'ðŸŒ’', 'ðŸŒ“', 'ðŸŒ”', 'ðŸŒ™', 'ðŸŒŽ', 'ðŸŒ', 'ðŸŒ', 'ðŸª', 'ðŸ’«', 'â­', 'ðŸŒŸ', 'âœ¨', 'âš¡', 'â˜„ï¸', 'ðŸ’¥', 'ðŸ”¥', 'ðŸŒªï¸', 'ðŸŒˆ', 'â˜€ï¸', 'ðŸŒ¤ï¸', 'â›…', 'ðŸŒ¥ï¸', 'â˜ï¸', 'ðŸŒ¦ï¸', 'ðŸŒ§ï¸', 'â›ˆï¸', 'ðŸŒ©ï¸', 'ðŸŒ¨ï¸', 'â„ï¸', 'â˜ƒï¸', 'â›„', 'ðŸŒ¬ï¸', 'ðŸ’¨', 'ðŸ’§', 'ðŸ’¦', 'ðŸŒŠ'],
        food: ['ðŸ', 'ðŸŽ', 'ðŸ', 'ðŸŠ', 'ðŸ‹', 'ðŸŒ', 'ðŸ‰', 'ðŸ‡', 'ðŸ“', 'ðŸ«', 'ðŸˆ', 'ðŸ’', 'ðŸ‘', 'ðŸ¥­', 'ðŸ', 'ðŸ¥¥', 'ðŸ¥', 'ðŸ…', 'ðŸ†', 'ðŸ¥‘', 'ðŸ¥¦', 'ðŸ¥¬', 'ðŸ¥’', 'ðŸŒ¶ï¸', 'ðŸ«‘', 'ðŸŒ½', 'ðŸ¥•', 'ðŸ«’', 'ðŸ§„', 'ðŸ§…', 'ðŸ¥”', 'ðŸ ', 'ðŸ¥', 'ðŸ¥¯', 'ðŸž', 'ðŸ¥–', 'ðŸ¥¨', 'ðŸ§€', 'ðŸ¥š', 'ðŸ³', 'ðŸ§ˆ', 'ðŸ¥ž', 'ðŸ§‡', 'ðŸ¥“', 'ðŸ¥©', 'ðŸ—', 'ðŸ–', 'ðŸ¦´', 'ðŸŒ­', 'ðŸ”', 'ðŸŸ', 'ðŸ•', 'ðŸ«“', 'ðŸ¥ª', 'ðŸ¥™', 'ðŸ§†', 'ðŸŒ®', 'ðŸŒ¯', 'ðŸ«”', 'ðŸ¥—', 'ðŸ¥˜', 'ðŸ«•', 'ðŸ', 'ðŸœ', 'ðŸ²', 'ðŸ›', 'ðŸ£', 'ðŸ±', 'ðŸ¥Ÿ', 'ðŸ¦ª', 'ðŸ¤', 'ðŸ™', 'ðŸš', 'ðŸ˜', 'ðŸ¥', 'ðŸ¥ ', 'ðŸ¥®', 'ðŸ¢', 'ðŸ¡', 'ðŸ§', 'ðŸ¨', 'ðŸ¦', 'ðŸ¥§', 'ðŸ§', 'ðŸ°', 'ðŸŽ‚', 'ðŸ®', 'ðŸ­', 'ðŸ¬', 'ðŸ«', 'ðŸ¿', 'ðŸ©', 'ðŸª', 'ðŸŒ°', 'ðŸ¥œ', 'ðŸ¯', 'ðŸ¥›', 'ðŸ¼', 'ðŸ«–', 'â˜•', 'ðŸµ', 'ðŸ§ƒ', 'ðŸ¥¤', 'ðŸ§‹', 'ðŸ¶', 'ðŸº', 'ðŸ»', 'ðŸ¥‚', 'ðŸ·', 'ðŸ¥ƒ', 'ðŸ¸', 'ðŸ¹', 'ðŸ§‰', 'ðŸ¾', 'ðŸ§Š', 'ðŸ¥„', 'ðŸ´', 'ðŸ½ï¸', 'ðŸ¥£', 'ðŸ¥¡', 'ðŸ¥¢', 'ðŸ§‚'],
        activities: ['âš½', 'ðŸ€', 'ðŸˆ', 'âš¾', 'ðŸ¥Ž', 'ðŸŽ¾', 'ðŸ', 'ðŸ‰', 'ðŸ¥', 'ðŸŽ±', 'ðŸª€', 'ðŸ“', 'ðŸ¸', 'ðŸ’', 'ðŸ‘', 'ðŸ¥', 'ðŸ', 'ðŸªƒ', 'ðŸ¥…', 'â›³', 'ðŸª', 'ðŸ¹', 'ðŸŽ£', 'ðŸ¤¿', 'ðŸ¥Š', 'ðŸ¥‹', 'ðŸŽ½', 'ðŸ›¹', 'ðŸ›¼', 'ðŸ›·', 'â›¸ï¸', 'ðŸ¥Œ', 'ðŸŽ¿', 'â›·ï¸', 'ðŸ‚', 'ðŸª‚', 'ðŸ‹ï¸', 'ðŸ¤¼', 'ðŸ¤¸', 'â›¹ï¸', 'ðŸ¤º', 'ðŸ¤¾', 'ðŸŒï¸', 'ðŸ‡', 'ðŸ§˜', 'ðŸ„', 'ðŸŠ', 'ðŸ¤½', 'ðŸš£', 'ðŸ§—', 'ðŸšµ', 'ðŸš´', 'ðŸ†', 'ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰', 'ðŸ…', 'ðŸŽ–ï¸', 'ðŸµï¸', 'ðŸŽ—ï¸', 'ðŸŽ«', 'ðŸŽŸï¸', 'ðŸŽª', 'ðŸ¤¹', 'ðŸŽ­', 'ðŸ©°', 'ðŸŽ¨', 'ðŸŽ¬', 'ðŸŽ¤', 'ðŸŽ§', 'ðŸŽ¼', 'ðŸŽ¹', 'ðŸ¥', 'ðŸª˜', 'ðŸŽ·', 'ðŸŽº', 'ðŸª—', 'ðŸŽ¸', 'ðŸª•', 'ðŸŽ»', 'ðŸŽ²', 'â™Ÿï¸', 'ðŸŽ¯', 'ðŸŽ³', 'ðŸŽ®', 'ðŸŽ°', 'ðŸ§©'],
        travel: ['ðŸš—', 'ðŸš•', 'ðŸš™', 'ðŸšŒ', 'ðŸšŽ', 'ðŸŽï¸', 'ðŸš“', 'ðŸš‘', 'ðŸš’', 'ðŸš', 'ðŸ›»', 'ðŸšš', 'ðŸš›', 'ðŸšœ', 'ðŸ¦¯', 'ðŸ¦½', 'ðŸ¦¼', 'ðŸ›´', 'ðŸš²', 'ðŸ›µ', 'ðŸï¸', 'ðŸ›º', 'ðŸš¨', 'ðŸš”', 'ðŸš', 'ðŸš˜', 'ðŸš–', 'ðŸš¡', 'ðŸš ', 'ðŸšŸ', 'ðŸšƒ', 'ðŸš‹', 'ðŸšž', 'ðŸš', 'ðŸš„', 'ðŸš…', 'ðŸšˆ', 'ðŸš‚', 'ðŸš†', 'ðŸš‡', 'ðŸšŠ', 'ðŸš‰', 'âœˆï¸', 'ðŸ›«', 'ðŸ›¬', 'ðŸ›©ï¸', 'ðŸ’º', 'ðŸ›°ï¸', 'ðŸš€', 'ðŸ›¸', 'ðŸš', 'ðŸ›¶', 'â›µ', 'ðŸš¤', 'ðŸ›¥ï¸', 'ðŸ›³ï¸', 'â›´ï¸', 'ðŸš¢', 'âš“', 'ðŸª', 'â›½', 'ðŸš§', 'ðŸš¦', 'ðŸš¥', 'ðŸš', 'ðŸ—ºï¸', 'ðŸ—¿', 'ðŸ—½', 'ðŸ—¼', 'ðŸ°', 'ðŸ¯', 'ðŸŸï¸', 'ðŸŽ¡', 'ðŸŽ¢', 'ðŸŽ ', 'â›²', 'â›±ï¸', 'ðŸ–ï¸', 'ðŸï¸', 'ðŸœï¸', 'ðŸŒ‹', 'â›°ï¸', 'ðŸ”ï¸', 'ðŸ—»', 'ðŸ•ï¸', 'â›º', 'ðŸ›–', 'ðŸ ', 'ðŸ¡', 'ðŸ˜ï¸', 'ðŸšï¸', 'ðŸ—ï¸', 'ðŸ­', 'ðŸ¢', 'ðŸ¬', 'ðŸ£', 'ðŸ¤', 'ðŸ¥', 'ðŸ¦', 'ðŸ¨', 'ðŸª', 'ðŸ«', 'ðŸ©', 'ðŸ’’', 'ðŸ›ï¸', 'â›ª', 'ðŸ•Œ', 'ðŸ•', 'ðŸ›•', 'ðŸ•‹', 'â›©ï¸', 'ðŸ›¤ï¸', 'ðŸ›£ï¸', 'ðŸ—¾', 'ðŸŽ‘', 'ðŸžï¸', 'ðŸŒ…', 'ðŸŒ„', 'ðŸŒ ', 'ðŸŽ‡', 'ðŸŽ†', 'ðŸŒ‡', 'ðŸŒ†', 'ðŸ™ï¸', 'ðŸŒƒ', 'ðŸŒŒ', 'ðŸŒ‰', 'ðŸŒ'],
        objects: ['ðŸ’¡', 'ðŸ”¦', 'ðŸ®', 'ðŸª”', 'ðŸ“±', 'ðŸ“²', 'ðŸ’»', 'ðŸ–¥ï¸', 'ðŸ–¨ï¸', 'âŒ¨ï¸', 'ðŸ–±ï¸', 'ðŸ–²ï¸', 'ðŸ’½', 'ðŸ’¾', 'ðŸ’¿', 'ðŸ“€', 'ðŸ§®', 'ðŸŽ¥', 'ðŸŽžï¸', 'ðŸ“½ï¸', 'ðŸŽ¬', 'ðŸ“º', 'ðŸ“·', 'ðŸ“¸', 'ðŸ“¹', 'ðŸ“¼', 'ðŸ”', 'ðŸ”Ž', 'ðŸ•¯ï¸', 'ðŸ’¡', 'ðŸ”¦', 'ðŸ®', 'ðŸª”', 'ðŸ“”', 'ðŸ“•', 'ðŸ“–', 'ðŸ“—', 'ðŸ“˜', 'ðŸ“™', 'ðŸ“š', 'ðŸ““', 'ðŸ“’', 'ðŸ“ƒ', 'ðŸ“œ', 'ðŸ“„', 'ðŸ“°', 'ðŸ—žï¸', 'ðŸ“‘', 'ðŸ”–', 'ðŸ·ï¸', 'ðŸ’°', 'ðŸª™', 'ðŸ’´', 'ðŸ’µ', 'ðŸ’¶', 'ðŸ’·', 'ðŸ’¸', 'ðŸ’³', 'ðŸ§¾', 'ðŸ’¹', 'âœ‰ï¸', 'ðŸ“§', 'ðŸ“¨', 'ðŸ“©', 'ðŸ“¤', 'ðŸ“¥', 'ðŸ“¦', 'ðŸ“«', 'ðŸ“ª', 'ðŸ“¬', 'ðŸ“­', 'ðŸ“®', 'ðŸ—³ï¸', 'âœï¸', 'âœ’ï¸', 'ðŸ–‹ï¸', 'ðŸ–Šï¸', 'ðŸ–Œï¸', 'ðŸ–ï¸', 'ðŸ“', 'ðŸ’¼', 'ðŸ“', 'ðŸ“‚', 'ðŸ—‚ï¸', 'ðŸ“…', 'ðŸ“†', 'ðŸ—’ï¸', 'ðŸ—“ï¸', 'ðŸ“‡', 'ðŸ“ˆ', 'ðŸ“‰', 'ðŸ“Š', 'ðŸ“‹', 'ðŸ“Œ', 'ðŸ“', 'ðŸ“Ž', 'ðŸ–‡ï¸', 'ðŸ“', 'ðŸ“', 'âœ‚ï¸', 'ðŸ—ƒï¸', 'ðŸ—„ï¸', 'ðŸ—‘ï¸', 'ðŸ”’', 'ðŸ”“', 'ðŸ”', 'ðŸ”', 'ðŸ”‘', 'ðŸ—ï¸', 'ðŸ”¨', 'ðŸª“', 'â›ï¸', 'âš’ï¸', 'ðŸ› ï¸', 'ðŸ—¡ï¸', 'âš”ï¸', 'ðŸ”«', 'ðŸªƒ', 'ðŸ¹', 'ðŸ›¡ï¸', 'ðŸªš', 'ðŸ”§', 'ðŸª›', 'ðŸ”©', 'âš™ï¸', 'ðŸ—œï¸', 'âš–ï¸', 'ðŸ¦¯', 'ðŸ”—', 'â›“ï¸', 'ðŸª', 'ðŸ§°', 'ðŸ§²', 'ðŸªœ', 'âš—ï¸', 'ðŸ§ª', 'ðŸ§«', 'ðŸ§¬', 'ðŸ”¬', 'ðŸ”­', 'ðŸ“¡', 'ðŸ’‰', 'ðŸ©¸', 'ðŸ’Š', 'ðŸ©¹', 'ðŸ©º', 'ðŸšª', 'ðŸ›—', 'ðŸªž', 'ðŸªŸ', 'ðŸ›ï¸', 'ðŸ›‹ï¸', 'ðŸª‘', 'ðŸš½', 'ðŸª ', 'ðŸš¿', 'ðŸ›', 'ðŸª¤', 'ðŸª’', 'ðŸ§´', 'ðŸ§·', 'ðŸ§¹', 'ðŸ§º', 'ðŸ§»', 'ðŸª£', 'ðŸ§¼', 'ðŸª¥', 'ðŸ§½', 'ðŸ§¯', 'ðŸ›’', 'ðŸš¬', 'âš°ï¸', 'ðŸª¦', 'âš±ï¸', 'ðŸ—¿', 'ðŸª§', 'ðŸ§'],
        symbols: ['â¤ï¸', 'ðŸ§¡', 'ðŸ’›', 'ðŸ’š', 'ðŸ’™', 'ðŸ’œ', 'ðŸ–¤', 'ðŸ¤', 'ðŸ¤Ž', 'ðŸ’”', 'â£ï¸', 'ðŸ’•', 'ðŸ’ž', 'ðŸ’“', 'ðŸ’—', 'ðŸ’–', 'ðŸ’˜', 'ðŸ’', 'ðŸ’Ÿ', 'â˜®ï¸', 'âœï¸', 'â˜ªï¸', 'ðŸ•‰ï¸', 'â˜¸ï¸', 'âœ¡ï¸', 'ðŸ”¯', 'ðŸ•Ž', 'â˜¯ï¸', 'â˜¦ï¸', 'ðŸ›', 'â›Ž', 'â™ˆ', 'â™‰', 'â™Š', 'â™‹', 'â™Œ', 'â™', 'â™Ž', 'â™', 'â™', 'â™‘', 'â™’', 'â™“', 'ðŸ†”', 'âš›ï¸', 'ðŸ‰‘', 'â˜¢ï¸', 'â˜£ï¸', 'ðŸ“´', 'ðŸ“³', 'ðŸˆ¶', 'ðŸˆš', 'ðŸˆ¸', 'ðŸˆº', 'ðŸˆ·ï¸', 'âœ´ï¸', 'ðŸ†š', 'ðŸ’®', 'ðŸ‰', 'ãŠ™ï¸', 'ãŠ—ï¸', 'ðŸˆ´', 'ðŸˆµ', 'ðŸˆ¹', 'ðŸˆ²', 'ðŸ…°ï¸', 'ðŸ…±ï¸', 'ðŸ†Ž', 'ðŸ†‘', 'ðŸ…¾ï¸', 'ðŸ†˜', 'âŒ', 'â­•', 'ðŸ›‘', 'â›”', 'ðŸ“›', 'ðŸš«', 'ðŸ’¯', 'ðŸ’¢', 'â™¨ï¸', 'ðŸš·', 'ðŸš¯', 'ðŸš³', 'ðŸš±', 'ðŸ”ž', 'ðŸ“µ', 'ðŸš­', 'â—', 'â•', 'â“', 'â”', 'â€¼ï¸', 'â‰ï¸', 'ðŸ”…', 'ðŸ”†', 'ã€½ï¸', 'âš ï¸', 'ðŸš¸', 'ðŸ”±', 'âšœï¸', 'ðŸ”°', 'â™»ï¸', 'âœ…', 'ðŸˆ¯', 'ðŸ’¹', 'â‡ï¸', 'âœ³ï¸', 'âŽ', 'ðŸŒ', 'ðŸ’ ', 'â“‚ï¸', 'ðŸŒ€', 'ðŸ’¤', 'ðŸ§', 'ðŸš¾', 'â™¿', 'ðŸ…¿ï¸', 'ðŸ›—', 'ðŸˆ³', 'ðŸˆ‚ï¸', 'ðŸ›‚', 'ðŸ›ƒ', 'ðŸ›„', 'ðŸ›…', 'ðŸš¹', 'ðŸšº', 'ðŸš¼', 'âš§ï¸', 'ðŸš»', 'ðŸš®', 'ðŸŽ¦', 'ðŸ“¶', 'ðŸˆ', 'ðŸ”£', 'â„¹ï¸', 'ðŸ”¤', 'ðŸ”¡', 'ðŸ” ', 'ðŸ†–', 'ðŸ†—', 'ðŸ†™', 'ðŸ†’', 'ðŸ†•', 'ðŸ†“', '0ï¸âƒ£', '1ï¸âƒ£', '2ï¸âƒ£', '3ï¸âƒ£', '4ï¸âƒ£', '5ï¸âƒ£', '6ï¸âƒ£', '7ï¸âƒ£', '8ï¸âƒ£', '9ï¸âƒ£', 'ðŸ”Ÿ', 'ðŸ”¢', '#ï¸âƒ£', '*ï¸âƒ£', 'âï¸', 'â–¶ï¸', 'â¸ï¸', 'â¯ï¸', 'â¹ï¸', 'âºï¸', 'â­ï¸', 'â®ï¸', 'â©', 'âª', 'â«', 'â¬', 'â—€ï¸', 'ðŸ”¼', 'ðŸ”½', 'âž¡ï¸', 'â¬…ï¸', 'â¬†ï¸', 'â¬‡ï¸', 'â†—ï¸', 'â†˜ï¸', 'â†™ï¸', 'â†–ï¸', 'â†•ï¸', 'â†”ï¸', 'â†ªï¸', 'â†©ï¸', 'â¤´ï¸', 'â¤µï¸', 'ðŸ”€', 'ðŸ”', 'ðŸ”‚', 'ðŸ”„', 'ðŸ”ƒ', 'ðŸŽµ', 'ðŸŽ¶', 'âž•', 'âž–', 'âž—', 'âœ–ï¸', 'ðŸŸ°', 'â™¾ï¸', 'ðŸ’²', 'ðŸ’±', 'â„¢ï¸', 'Â©ï¸', 'Â®ï¸', 'ã€°ï¸', 'âž°', 'âž¿', 'ðŸ”š', 'ðŸ”™', 'ðŸ”›', 'ðŸ”', 'ðŸ”œ', 'âœ”ï¸', 'â˜‘ï¸', 'ðŸ”˜', 'ðŸ”´', 'ðŸŸ ', 'ðŸŸ¡', 'ðŸŸ¢', 'ðŸ”µ', 'ðŸŸ£', 'âš«', 'âšª', 'ðŸŸ¤', 'ðŸ”º', 'ðŸ”»', 'ðŸ”¸', 'ðŸ”¹', 'ðŸ”¶', 'ðŸ”·', 'ðŸ”³', 'ðŸ”²', 'â–ªï¸', 'â–«ï¸', 'â—¾', 'â—½', 'â—¼ï¸', 'â—»ï¸', 'ðŸŸ¥', 'ðŸŸ§', 'ðŸŸ¨', 'ðŸŸ©', 'ðŸŸ¦', 'ðŸŸª', 'â¬›', 'â¬œ', 'ðŸŸ«', 'ðŸ”ˆ', 'ðŸ”‡', 'ðŸ”‰', 'ðŸ”Š', 'ðŸ””', 'ðŸ”•', 'ðŸ“£', 'ðŸ“¢', 'ðŸ‘ï¸â€ðŸ—¨ï¸', 'ðŸ’¬', 'ðŸ’­', 'ðŸ—¯ï¸', 'â™ ï¸', 'â™£ï¸', 'â™¥ï¸', 'â™¦ï¸', 'ðŸƒ', 'ðŸŽ´', 'ðŸ€„', 'ðŸ•', 'ðŸ•‘', 'ðŸ•’', 'ðŸ•“', 'ðŸ•”', 'ðŸ••', 'ðŸ•–', 'ðŸ•—', 'ðŸ•˜', 'ðŸ•™', 'ðŸ•š', 'ðŸ•›', 'ðŸ•œ', 'ðŸ•', 'ðŸ•ž', 'ðŸ•Ÿ', 'ðŸ• ', 'ðŸ•¡', 'ðŸ•¢', 'ðŸ•£', 'ðŸ•¤', 'ðŸ•¥', 'ðŸ•¦', 'ðŸ•§']
    };
    
    let currentCategory = 'smileys';
    let isOpen = false;
    
    /**
     * Render emoji grid
     */
    function renderEmojiGrid(category) {
        const emojis = emojiData[category] || [];
        emojiGrid.innerHTML = emojis.map(emoji => `
            <div class="emoji-item" data-emoji="${emoji}">${emoji}</div>
        `).join('');
    }
    
    /**
     * Position and show the popover
     */
    function showPopover() {
        if (isOpen) {
            hidePopover();
            return;
        }
        
        // Position relative to emoji button
        const btnRect = emojiBtn.getBoundingClientRect();
        const inputContainer = emojiBtn.closest('.chat-input-footer') || emojiBtn.closest('.chat-input-container');
        const containerRect = inputContainer?.getBoundingClientRect() || btnRect;
        
        popover.style.display = 'flex';
        popover.style.position = 'absolute';
        
        // Get popover dimensions
        const popoverRect = popover.getBoundingClientRect();
        
        // Position above the button, aligned to left of container
        popover.style.bottom = '100%';
        popover.style.left = '0';
        popover.style.marginBottom = '8px';
        
        // Render current category
        renderEmojiGrid(currentCategory);
        
        // Reset search
        if (searchInput) searchInput.value = '';
        
        isOpen = true;
        
        // Focus search input
        setTimeout(() => searchInput?.focus(), 50);
        
        // Add click-away listener
        setTimeout(() => {
            document.addEventListener('click', handleClickAway);
        }, 10);
    }
    
    /**
     * Hide the popover
     */
    function hidePopover() {
        popover.style.display = 'none';
        isOpen = false;
        document.removeEventListener('click', handleClickAway);
    }
    
    /**
     * Handle click away to close popover
     */
    function handleClickAway(e) {
        if (!popover.contains(e.target) && !emojiBtn.contains(e.target)) {
            hidePopover();
        }
    }
    
    /**
     * Insert emoji into chat input
     */
    function insertEmoji(emoji) {
        const start = chatInput.selectionStart;
        const end = chatInput.selectionEnd;
        const text = chatInput.value;
        
        chatInput.value = text.substring(0, start) + emoji + text.substring(end);
        
        // Move cursor after emoji
        const newPos = start + emoji.length;
        chatInput.setSelectionRange(newPos, newPos);
        
        // Focus the input
        chatInput.focus();
        
        hidePopover();
    }
    
    // Emoji button click
    emojiBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        showPopover();
    });
    
    // Category tab clicks
    if (categoryTabs) {
        categoryTabs.addEventListener('click', (e) => {
            const tab = e.target.closest('.emoji-tab');
            if (!tab) return;
            
            const category = tab.dataset.category;
            if (!category) return;
            
            // Update active tab
            categoryTabs.querySelectorAll('.emoji-tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            
            // Render new category
            currentCategory = category;
            renderEmojiGrid(category);
            
            // Clear search
            if (searchInput) searchInput.value = '';
        });
    }
    
    // Emoji grid clicks
    emojiGrid.addEventListener('click', (e) => {
        const item = e.target.closest('.emoji-item');
        if (!item) return;
        
        const emoji = item.dataset.emoji;
        if (emoji) {
            insertEmoji(emoji);
        }
    });
    
    // Search input
    if (searchInput) {
        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.trim().toLowerCase();
            if (term) {
                // Show all emojis for search (simplified - would need keyword database for real search)
                let allEmojis = [];
                Object.values(emojiData).forEach(arr => allEmojis.push(...arr));
                emojiGrid.innerHTML = allEmojis.map(emoji => `
                    <div class="emoji-item" data-emoji="${emoji}">${emoji}</div>
                `).join('');
            } else {
                renderEmojiGrid(currentCategory);
            }
        });
        
        // Keyboard navigation
        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                e.preventDefault();
                hidePopover();
                chatInput.focus();
            } else if (e.key === 'Enter') {
                e.preventDefault();
                // Select first emoji
                const firstEmoji = emojiGrid.querySelector('.emoji-item');
                if (firstEmoji) {
                    insertEmoji(firstEmoji.dataset.emoji);
                }
            }
        });
    }
}

// ===================================
// ===================================
// MESSAGE MANAGEMENT (OUTSIDE initChat FOR GLOBAL ACCESS)
// ===================================

/**
 * Delete a message from Firestore
 * 
 * Permission model (matches Firestore rules):
 * - Members can delete their own messages (userId matches auth.uid)
 * - Admins and owners can delete any message
 * 
 * UI behavior:
 * - Delete button only shown when user has permission
 * - Deletion triggers Firestore deleteDoc
 * - onSnapshot listener auto-updates UI when deletion succeeds
 * 
 * @param {string} messageId - The Firestore document ID
 * @param {string} messageUserId - The userId who created the message (for permission check)
 */
async function deleteMessage(messageId, messageUserId) {
    if (!messageId || !appState.currentTeamId || !db || !currentAuthUser) {
        console.error('âŒ Cannot delete: missing required data', {
            hasMessageId: !!messageId,
            hasTeamId: !!appState.currentTeamId,
            hasDb: !!db,
            hasAuth: !!currentAuthUser
        });
        return;
    }
    
    const currentUserId = currentAuthUser.uid;
    const teamId = appState.currentTeamId;
    
    try {
        // Fetch the team document to get accurate role information
        const { doc, getDoc, deleteDoc } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const teamRef = doc(db, 'teams', teamId);
        const teamSnap = await getDoc(teamRef);
        
        if (!teamSnap.exists()) {
            console.error('âŒ Team document not found:', { teamId, currentUserId });
            showToast('Team not found. Please try again.', 'error');
            return;
        }
        
        const teamData = teamSnap.data();
        const currentUserRole = getCurrentUserRole(teamData);
        
        // Find the message object in appState to verify its userId
        const message = appState.messages.find(m => m.id === messageId);
        const actualMessageUserId = messageUserId || message?.userId;
        
        // Check if user has permission to delete this message
        const isCreator = actualMessageUserId === currentUserId;
        const isAdminOrOwner = currentUserRole === 'admin' || currentUserRole === 'owner';
        
        debugLog('ðŸ” Delete permission check:', {
            messageId,
            messageUserId: actualMessageUserId,
            currentUserId,
            currentUserRole,
            isCreator,
            isAdminOrOwner,
            teamId
        });
        
        if (!isCreator && !isAdminOrOwner) {
            console.error('âŒ Permission denied:', {
                reason: 'User is neither creator nor admin/owner',
                messageUserId: actualMessageUserId,
                currentUserId,
                currentUserRole
            });
            showToast('You can only delete your own messages', 'error');
            return;
        }
        
        // Delete from Firestore using the real Firestore document ID
        const messageRef = doc(db, 'teams', teamId, 'messages', messageId);
        await deleteDoc(messageRef);
        
        debugLog('âœ… Message deleted successfully from Firestore:', { messageId });
        showToast('Message deleted', 'success');
        
        // UI will update automatically via onSnapshot listener
        // No need to manually update appState.messages or call displayMessages()
        
    } catch (error) {
        console.error('âŒ Error deleting message:', {
            error: error.message,
            code: error.code,
            messageId,
            messageUserId,
            teamId,
            currentUserId
        });
        
        // Handle specific error cases
        if (error.code === 'permission-denied') {
            showToast('You don\'t have permission to delete this message', 'error');
        } else if (error.code === 'not-found') {
            console.warn('âš ï¸ Message not found in Firestore (may have been already deleted)');
            showToast('Message not found', 'error');
        } else {
            showToast('Failed to delete message. Please try again.', 'error');
        }
    }
}

// Clear all messages (owner only)
// Show delete chat history modal (owner only)
window.showDeleteChatHistoryModal = function() {
    const currentUserRole = appState.teammates?.find(t => t.id === currentAuthUser?.uid)?.role;
    if (currentUserRole !== 'owner') {
        showToast('Only team owners can delete chat history', 'error');
        return;
    }
    
    openModal('deleteChatHistoryModal');
};

// Clear all messages from team chat
async function clearAllMessages() {
    if (!appState.currentTeamId || !db) {
        showToast('Cannot delete messages right now', 'error');
        return;
    }
    
    const currentUserRole = appState.teammates?.find(t => t.id === currentAuthUser?.uid)?.role;
    if (currentUserRole !== 'owner') {
        showToast('Only team owners can clear all messages', 'error');
        return;
    }
    
    try {
        const { getDocs, deleteDoc, collection } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const messagesRef = collection(db, 'teams', appState.currentTeamId, 'messages');
        const snapshot = await getDocs(messagesRef);
        
        if (snapshot.empty) {
            showToast('No messages to delete', 'info');
            closeModal('deleteChatHistoryModal');
            return;
        }
        
        const deletePromises = [];
        snapshot.forEach(messageDoc => {
            deletePromises.push(deleteDoc(messageDoc.ref));
        });
        
        await Promise.all(deletePromises);
        
        // Clear local state (onSnapshot will also update but this is immediate)
        appState.messages = [];
        displayMessages();
        
        debugLog(`âœ… Deleted ${deletePromises.length} messages from chat history`);
        showToast(`Successfully deleted ${deletePromises.length} message${deletePromises.length === 1 ? '' : 's'}`, 'success');
        
        // Close modal
        closeModal('deleteChatHistoryModal');
        
    } catch (error) {
        console.error('Error clearing messages:', error.code || error.message);
        if (error.code === 'permission-denied') {
            showToast('Permission denied. Only owners can delete chat history.', 'error');
        } else {
            showToast('Failed to clear messages. Please try again.', 'error');
        }
    }
}

// ===================================
// CALENDAR FUNCTIONALITY
// ===================================
function initCalendar() {
    const calendarTitle = document.getElementById('calendarTitle');
    const calendarDays = document.getElementById('calendarDays');
    const prevMonthBtn = document.getElementById('prevMonth');
    const nextMonthBtn = document.getElementById('nextMonth');
    const addEventBtn = document.getElementById('addEventBtn');
    const todayBtn = document.getElementById('todayBtn');

    // Load events from Firestore
    loadEventsFromFirestore();

    // View toggle handlers (buttons are now in HTML)
    const calendarViewButtons = document.querySelectorAll('#calendar-section .calendar-view-toggle .view-toggle-btn');
    calendarViewButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            calendarViewButtons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            const view = btn.dataset.view;
            // Only support month and week for now
            if (view === 'month' || view === 'week') {
                appState.calendarView = view;
                renderCalendar();
            }
        });
    });

    // Navigation buttons
    if (prevMonthBtn) {
        prevMonthBtn.addEventListener('click', () => {
            if (appState.calendarView === 'month') {
                appState.currentDate.setMonth(appState.currentDate.getMonth() - 1);
            } else {
                appState.currentDate.setDate(appState.currentDate.getDate() - 7);
            }
            renderCalendar();
        });
    }

    if (nextMonthBtn) {
        nextMonthBtn.addEventListener('click', () => {
            if (appState.calendarView === 'month') {
                appState.currentDate.setMonth(appState.currentDate.getMonth() + 1);
            } else {
                appState.currentDate.setDate(appState.currentDate.getDate() + 7);
            }
            renderCalendar();
        });
    }

    // Today button - jump to current date
    if (todayBtn) {
        todayBtn.addEventListener('click', () => {
            appState.currentDate = new Date();
            renderCalendar();
        });
    }

    // Add event button
    if (addEventBtn) {
        addEventBtn.addEventListener('click', () => {
            openModal('eventModal');
        });
    }

    // Initial render
    renderCalendar();

    // Expose for external use
    window.displayCalendarEvents = () => renderCalendar();
    window.renderCalendar = renderCalendar;
}

function renderCalendar() {
    const calendarSection = document.getElementById('calendar-section');
    const calendarTitle = document.getElementById('calendarTitle');
    const calendarDays = document.getElementById('calendarDays');
    const dayHeaders = document.querySelectorAll('.calendar-day-header');
    
    // Check if calendar section exists
    if (!calendarTitle || !calendarDays) {
        console.log('Calendar elements not found - calendar section may not be visible yet');
        return;
    }
    
    // Update view toggle button states
    document.querySelectorAll('#calendar-section .calendar-view-toggle .view-toggle-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.view === appState.calendarView);
    });
    
    // Check if calendar section is currently active
    const isCalendarActive = calendarSection && calendarSection.classList.contains('active');
    console.log(`Rendering calendar in ${appState.calendarView} view with ${appState.events.length} events (active: ${isCalendarActive})`);
    
    if (appState.calendarView === 'month') {
        // Show day headers in month view
        dayHeaders.forEach(header => header.style.display = '');
        renderMonthView(calendarTitle, calendarDays);
    } else {
        // Hide day headers in week view
        dayHeaders.forEach(header => header.style.display = 'none');
        renderWeekView(calendarTitle, calendarDays);
    }
}

// Helper function to render event items in month view
function renderMonthEventItems(dayEvents) {
    return dayEvents.slice(0, 2).map(evt => {
        const color = evt.color || '#0078d4';
        const startTime = evt.date instanceof Date ? evt.date : new Date(evt.date);
        const timeStr = formatTime24(startTime.getHours(), startTime.getMinutes());
        const isPrivate = evt.visibility === 'private' || evt.visibility === 'admins';
        const lockIcon = isPrivate ? '<i class="fas fa-lock month-event-lock"></i>' : '';
        const repeatIcon = evt.isRecurrence ? '<i class="fas fa-redo month-event-repeat"></i>' : '';
        const eventId = evt.masterId || evt.id;
        return `<div class="month-event-item" 
            draggable="true"
            data-event-id="${escapeHtml(eventId)}"
            data-original-time="${timeStr}"
            onclick="if(!monthDragStarted){viewEventDetails('${escapeHtml(eventId)}', '${evt.occurrenceDate ? evt.occurrenceDate.toISOString() : ''}');} event.stopPropagation();" 
            style="background: ${escapeHtml(color)}15; border-left: 3px solid ${escapeHtml(color)};">
            <span class="month-event-time" style="color: ${escapeHtml(color)};">${timeStr}</span>
            <span class="month-event-title">${escapeHtml(evt.title)}</span>
            ${lockIcon}${repeatIcon}
        </div>`;
    }).join('') + (dayEvents.length > 2 ? `<div class="month-event-more">+${dayEvents.length - 2} more</div>` : '');
}

function renderMonthView(titleEl, daysEl) {
    const year = appState.currentDate.getFullYear();
    const month = appState.currentDate.getMonth();
    
    // Format title like "August 2026" - month light, year bold
    const monthName = new Date(year, month).toLocaleDateString('en-US', { month: 'long' });
    titleEl.innerHTML = `${monthName} <span>${year}</span>`;

    let firstDayOfMonth = new Date(year, month, 1).getDay();
    // Adjust for Monday start: 0 (Sunday) becomes 6, 1 (Monday) becomes 0, etc.
    firstDayOfMonth = firstDayOfMonth === 0 ? 6 : firstDayOfMonth - 1;
    
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const daysInPrevMonth = new Date(year, month, 0).getDate();
    
    let html = '';
    const today = new Date();
    
    // Generate occurrences for the entire month (including overflow days)
    const rangeStart = new Date(year, month - 1, daysInPrevMonth - firstDayOfMonth + 1, 0, 0, 0);
    const rangeEnd = new Date(year, month + 1, 14, 23, 59, 59);
    const allOccurrences = getAllEventOccurrences(appState.events, rangeStart, rangeEnd);
    
    // Previous month days (to fill the first week)
    for (let i = firstDayOfMonth - 1; i >= 0; i--) {
        const day = daysInPrevMonth - i;
        const date = new Date(year, month - 1, day);
        
        // Filter occurrences for this day
        const dayEvents = allOccurrences.filter(e => {
            const eventDate = e.date instanceof Date ? e.date : new Date(e.date);
            return eventDate.toDateString() === date.toDateString();
        });
        
        const eventItemsHtml = renderMonthEventItems(dayEvents);
        
        html += `
            <div class="calendar-day other-month" data-date="${date.toISOString()}">
                <div class="day-number">${day}</div>
                ${dayEvents.length > 0 ? `<div class="month-events">${eventItemsHtml}</div>` : ''}
            </div>
        `;
    }
    
    // Current month days
    for (let day = 1; day <= daysInMonth; day++) {
        const date = new Date(year, month, day);
        const isToday = date.toDateString() === today.toDateString();
        
        // Filter occurrences for this day
        const dayEvents = allOccurrences.filter(e => {
            const eventDate = e.date instanceof Date ? e.date : new Date(e.date);
            return eventDate.toDateString() === date.toDateString();
        });
        
        const eventItemsHtml = renderMonthEventItems(dayEvents);
        
        html += `
            <div class="calendar-day ${isToday ? 'today' : ''}" data-date="${date.toISOString()}">
                <div class="day-number">${day}</div>
                ${dayEvents.length > 0 ? `<div class="month-events">${eventItemsHtml}</div>` : ''}
            </div>
        `;
    }
    
    // Next month days (to complete the grid - fill remaining cells to make 6 rows)
    const totalCells = firstDayOfMonth + daysInMonth;
    const cellsToAdd = totalCells <= 35 ? (35 - totalCells) : (42 - totalCells);
    
    for (let day = 1; day <= cellsToAdd; day++) {
        const date = new Date(year, month + 1, day);
        
        // Filter occurrences for this day
        const dayEvents = allOccurrences.filter(e => {
            const eventDate = e.date instanceof Date ? e.date : new Date(e.date);
            return eventDate.toDateString() === date.toDateString();
        });
        
        const eventItemsHtml = renderMonthEventItems(dayEvents);
        
        // Show month indicator on first day of next month
        const dayLabel = day === 1 ? `1.${month + 2 > 12 ? 1 : month + 2}.` : day;
        
        html += `
            <div class="calendar-day other-month" data-date="${date.toISOString()}">
                <div class="day-number">${dayLabel}</div>
                ${dayEvents.length > 0 ? `<div class="month-events">${eventItemsHtml}</div>` : ''}
            </div>
        `;
    }
    
    daysEl.innerHTML = html;
    
    // Add click handlers to open event modal with selected date using event delegation
    setTimeout(() => {
        const calendarDays = document.getElementById('calendarDays');
        if (!calendarDays) return;
        
        // Remove any existing handlers
        const oldMouseDown = calendarDays._monthDayMouseDownHandler;
        const oldMouseUp = calendarDays._monthDayMouseUpHandler;
        const oldMouseLeave = calendarDays._monthDayMouseLeaveHandler;
        if (oldMouseDown) calendarDays.removeEventListener('mousedown', oldMouseDown);
        if (oldMouseUp) calendarDays.removeEventListener('mouseup', oldMouseUp);
        if (oldMouseLeave) calendarDays.removeEventListener('mouseleave', oldMouseLeave);
        
        // Track press-and-hold state
        let pressTimer = null;
        let pressedDay = null;
        
        // Mouse down - start the timer
        const mouseDownHandler = (e) => {
            const day = e.target.closest('.calendar-day:not(.other-month)');
            if (!day) return;
            
            // Don't trigger if clicking on an event item
            if (e.target.closest('.month-event-item')) {
                return;
            }
            
            pressedDay = day;
            
            // Start 1-second timer
            pressTimer = setTimeout(() => {
                const dateStr = day.dataset.date;
                if (dateStr) {
                    const selectedDate = new Date(dateStr);
                    openEventModalWithDate(selectedDate);
                    pressedDay = null;
                }
            }, 1000);
        };
        
        // Mouse up - cancel the timer if released too early
        const mouseUpHandler = (e) => {
            if (pressTimer) {
                clearTimeout(pressTimer);
                pressTimer = null;
            }
            pressedDay = null;
        };
        
        // Mouse leave - cancel if mouse leaves the calendar area
        const mouseLeaveHandler = (e) => {
            if (pressTimer) {
                clearTimeout(pressTimer);
                pressTimer = null;
            }
            pressedDay = null;
        };
        
        calendarDays.addEventListener('mousedown', mouseDownHandler);
        calendarDays.addEventListener('mouseup', mouseUpHandler);
        calendarDays.addEventListener('mouseleave', mouseLeaveHandler);
        
        calendarDays._monthDayMouseDownHandler = mouseDownHandler;
        calendarDays._monthDayMouseUpHandler = mouseUpHandler;
        calendarDays._monthDayMouseLeaveHandler = mouseLeaveHandler;
        
        // Initialize drag-and-drop for month view events
        initCalendarDragDrop();
    }, 100);
}

function renderWeekView(titleEl, daysEl) {
    const isMobile = window.innerWidth < 900;
    const startOfWeek = getStartOfWeek(appState.currentDate);
    const endOfWeek = new Date(startOfWeek);
    endOfWeek.setDate(endOfWeek.getDate() + 6);
    
    if (DEBUG) {
        console.log(`ðŸ“… Week view: ${startOfWeek.toDateString()} to ${endOfWeek.toDateString()}`);
        console.log(`ðŸ“‹ Total events in appState: ${appState.events.length}`);
    }
    
    // Mobile: shortened format "Jan. 12-18", Desktop: full format
    if (isMobile) {
        const startMonth = startOfWeek.toLocaleDateString('en-US', { month: 'short' });
        const endMonth = endOfWeek.toLocaleDateString('en-US', { month: 'short' });
        const startDay = startOfWeek.getDate();
        const endDay = endOfWeek.getDate();
        // If same month: "Jan. 12-18", if different: "Jan. 28 - Feb. 3"
        if (startMonth === endMonth) {
            titleEl.textContent = `${startMonth} ${startDay}-${endDay}`;
        } else {
            titleEl.textContent = `${startMonth} ${startDay} - ${endMonth} ${endDay}`;
        }
    } else {
        titleEl.textContent = `${startOfWeek.toLocaleDateString('en-US', { month: 'long', day: 'numeric' })} - ${endOfWeek.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })}`;
    }
    
    // Generate occurrences for the week range
    const rangeStart = new Date(startOfWeek);
    rangeStart.setHours(0, 0, 0, 0);
    const rangeEnd = new Date(endOfWeek);
    rangeEnd.setHours(23, 59, 59, 999);
    const allOccurrences = getAllEventOccurrences(appState.events, rangeStart, rangeEnd);
    
    // Check if mobile view
    if (isMobile) {
        renderMobileDayAgenda(titleEl, daysEl, startOfWeek, allOccurrences);
    } else {
        renderDesktopColumnWeek(titleEl, daysEl, startOfWeek, allOccurrences);
    }
}

// Desktop: Column-based week view (>= 900px)
function renderDesktopColumnWeek(titleEl, daysEl, startOfWeek, allOccurrences) {
    const START_HOUR = 6;
    const END_HOUR = 22;
    const SLOT_HEIGHT = 60; // px per hour
    const TIME_COL_WIDTH = 64; // px for time column
    const DEFAULT_SCROLL_HOUR = 8;
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const currentHour = today.getHours();
    const currentMinute = today.getMinutes();
    
    // Build column week HTML with scrollable container
    let html = '<div class="week-view-scroll-container">';
    html += '<div class="week-colview">';
    
    // Time scaffold column (sticky left)
    html += '<div class="week-time-scaffold">';
    html += '<div class="week-time-header"></div>'; // Empty corner for header row
    for (let hour = START_HOUR; hour <= END_HOUR; hour++) {
        const hourFormatted = formatTime24(hour, 0);
        html += `<div class="week-time-label">${hourFormatted}</div>`;
    }
    html += '</div>';
    
    // Day columns
    for (let i = 0; i < 7; i++) {
        const date = new Date(startOfWeek);
        date.setDate(date.getDate() + i);
        const isToday = date.toDateString() === today.toDateString();
        const dayName = date.toLocaleDateString('en-US', { weekday: 'short' });
        const dayNum = date.getDate();
        
        html += `<div class="week-day-column ${isToday ? 'today-column' : ''}" data-date="${date.toISOString()}">`;
        
        // Day header (sticky top)
        html += `<div class="week-day-header ${isToday ? 'is-today' : ''}">`;
        html += `<span class="week-day-name">${dayName}</span>`;
        html += `<span class="week-day-number">${dayNum}</span>`;
        html += '</div>';
        
        // Time grid (for visual rows)
        html += '<div class="week-day-grid">';
        for (let hour = START_HOUR; hour <= END_HOUR; hour++) {
            html += `<div class="week-grid-cell" data-hour="${hour}"></div>`;
        }
        html += '</div>';
        
        // Events container (absolute positioning)
        html += '<div class="week-events-container">';
        
        // Get all event occurrences for this day
        const dayEvents = allOccurrences.filter(e => {
            const eventDate = e.date instanceof Date ? e.date : new Date(e.date);
            return eventDate.toDateString() === date.toDateString();
        });
        
        // Calculate overlapping events and assign lanes
        const eventsWithTimes = dayEvents.map(event => {
            const eventStartDate = new Date(event.date);
            const eventEndDate = event.endDate ? new Date(event.endDate) : new Date(eventStartDate.getTime() + 60*60*1000);
            return {
                ...event,
                startMinutes: eventStartDate.getHours() * 60 + eventStartDate.getMinutes(),
                endMinutes: eventEndDate.getHours() * 60 + eventEndDate.getMinutes(),
                startDate: eventStartDate,
                endDate: eventEndDate
            };
        }).sort((a, b) => a.startMinutes - b.startMinutes);
        
        // Assign lanes for overlapping events within this day only
        const lanes = [];
        eventsWithTimes.forEach(event => {
            let laneIndex = 0;
            while (lanes[laneIndex] && lanes[laneIndex].endMinutes > event.startMinutes) {
                laneIndex++;
            }
            event.laneIndex = laneIndex;
            lanes[laneIndex] = event;
        });
        const totalLanes = Math.max(lanes.filter(l => l).length, 1);
        
        // Render events as absolutely positioned blocks
        eventsWithTimes.forEach(event => {
            const startHour = event.startDate.getHours();
            const startMinute = event.startDate.getMinutes();
            
            const minutesSinceStart = (startHour - START_HOUR) * 60 + startMinute;
            const topPosition = (minutesSinceStart * SLOT_HEIGHT / 60);
            const durationMinutes = event.endMinutes - event.startMinutes;
            const height = Math.max((durationMinutes * SLOT_HEIGHT / 60), 30);
            
            const eventColor = event.color || '#007AFF';
            const shortEvent = height < 50;
            
            // Calculate width and left position based on lanes
            const laneWidth = 100 / totalLanes;
            const leftPercent = event.laneIndex * laneWidth;
            const widthPercent = laneWidth - 2; // 2% gap
            
            // Format times in 24h format
            const startTimeStr = formatTime24(event.startDate.getHours(), event.startDate.getMinutes());
            const endTimeStr = formatTime24(event.endDate.getHours(), event.endDate.getMinutes());
            
            // Check for visibility badges
            const isPrivate = event.visibility === 'private';
            const isAdmins = event.visibility === 'admins';
            const lockIcon = isPrivate ? '<i class="fas fa-lock"></i>' : '';
            const shieldIcon = isAdmins ? '<i class="fas fa-shield-alt"></i>' : '';
            const repeatIcon = event.isRecurrence ? '<i class="fas fa-redo"></i>' : '';
            const eventId = event.masterId || event.id;
            const occurrenceDateStr = event.occurrenceDate ? event.occurrenceDate.toISOString() : '';
            
            html += `
                <div class="week-col-event ${shortEvent ? 'short-event' : ''}" 
                     draggable="true"
                     data-event-id="${escapeHtml(eventId)}"
                     data-occurrence-date="${occurrenceDateStr}"
                     data-time-range="${startTimeStr}â€“${endTimeStr}"
                     data-start-minutes="${event.startMinutes}"
                     data-end-minutes="${event.endMinutes}"
                     data-visibility="${event.visibility || 'team'}"
                     onclick="if(!event.target.closest('.week-event-resize-handle')){event.stopPropagation(); viewEventDetails('${escapeHtml(eventId)}', '${occurrenceDateStr}')}" 
                     style="top: ${topPosition}px; height: ${height}px; left: ${leftPercent}%; width: ${widthPercent}%; border-left: 4px solid ${escapeHtml(eventColor)};">
                    <div class="week-event-resize-handle week-event-resize-top" data-resize="top" title="Drag to change start time"></div>
                    <div class="week-event-content">
                        <div class="week-event-title">${escapeHtml(event.title)}</div>
                        ${!shortEvent ? `<div class="week-event-time-inline">${startTimeStr}</div>` : ''}
                        <div class="week-event-icons">${lockIcon}${shieldIcon}${repeatIcon}</div>
                    </div>
                    <div class="week-event-hover-details">
                        <div class="hover-time">${startTimeStr}â€“${endTimeStr}</div>
                        ${isPrivate ? '<span class="hover-badge private-badge">Private</span>' : ''}
                        ${isAdmins ? '<span class="hover-badge admins-badge">Admins</span>' : ''}
                    </div>
                    <div class="week-event-resize-handle week-event-resize-bottom" data-resize="bottom" title="Drag to change end time"></div>
                </div>
            `;
        });
        
        html += '</div>'; // Close .week-events-container
        html += '</div>'; // Close .week-day-column
    }
    
    html += '</div>'; // Close .week-colview
    
    // Current time indicator (red line across today's column)
    const todayIndex = [...Array(7)].findIndex((_, i) => {
        const date = new Date(startOfWeek);
        date.setDate(date.getDate() + i);
        return date.toDateString() === today.toDateString();
    });
    
    if (todayIndex !== -1 && currentHour >= START_HOUR && currentHour <= END_HOUR) {
        const minutesSinceStart = (currentHour - START_HOUR) * 60 + currentMinute;
        const topPosition = (minutesSinceStart * SLOT_HEIGHT / 60);
        const timeLabel = formatTime24(currentHour, currentMinute);
        html += `<div class="week-now-line" style="top: ${topPosition}px;" data-time="${timeLabel}"></div>`;
    }
    
    html += '</div>'; // Close .week-view-scroll-container
    daysEl.innerHTML = html;
    
    // Auto-scroll to default hour (08:00) after render
    requestAnimationFrame(() => {
        const scrollContainer = daysEl.querySelector('.week-view-scroll-container');
        if (scrollContainer) {
            const scrollTo = (DEFAULT_SCROLL_HOUR - START_HOUR) * SLOT_HEIGHT;
            scrollContainer.scrollTop = scrollTo;
        }
    });
    
    // Add click handlers to grid cells to create events
    setTimeout(() => {
        const gridCells = daysEl.querySelectorAll('.week-grid-cell');
        console.log(`[Calendar] Attaching click handlers to ${gridCells.length} grid cells`);
        
        gridCells.forEach((cell, index) => {
            const handler = function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const dayColumn = this.closest('.week-day-column');
                const dateStr = dayColumn?.dataset.date;
                const hour = parseInt(this.dataset.hour);
                
                console.log('[Calendar] Grid cell clicked:', { dateStr, hour, cell: this });
                
                if (dateStr && !isNaN(hour)) {
                    const selectedDate = new Date(dateStr);
                    selectedDate.setHours(hour, 0, 0, 0);
                    console.log('[Calendar] Opening event modal for:', selectedDate);
                    if (typeof window.openEventModalWithDate === 'function') {
                        window.openEventModalWithDate(selectedDate, hour);
                    } else if (typeof openEventModalWithDate === 'function') {
                        openEventModalWithDate(selectedDate, hour);
                    } else {
                        console.error('[Calendar] openEventModalWithDate function not found!');
                    }
                }
            };
            
            cell.addEventListener('click', handler);
            if (index === 0) {
                console.log('[Calendar] First cell data:', { date: cell.closest('.week-day-column')?.dataset.date, hour: cell.dataset.hour });
            }
        });
    }, 100);
    
    // Initialize drag-and-drop for events
    initCalendarDragDrop();
}

// Mobile: Day agenda view (< 900px)
function renderMobileDayAgenda(titleEl, daysEl, startOfWeek, allOccurrences) {
    // Use currently selected day or default to today
    if (!appState.selectedMobileDay) {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        // Check if today is in this week
        const todayInWeek = [...Array(7)].some((_, i) => {
            const date = new Date(startOfWeek);
            date.setDate(date.getDate() + i);
            return date.toDateString() === today.toDateString();
        });
        appState.selectedMobileDay = todayInWeek ? today : startOfWeek;
    }
    
    const selectedDay = new Date(appState.selectedMobileDay);
    selectedDay.setHours(0, 0, 0, 0);
    
    let html = '<div class="day-agenda">';
    
    // Day strip (horizontal scrollable day selector)
    html += '<div class="day-strip">';
    for (let i = 0; i < 7; i++) {
        const date = new Date(startOfWeek);
        date.setDate(date.getDate() + i);
        const isSelected = date.toDateString() === selectedDay.toDateString();
        const dayName = date.toLocaleDateString('en-US', { weekday: 'short' });
        const dayNum = date.getDate();
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const isToday = date.toDateString() === today.toDateString();
        
        html += `<div class="day-strip-item ${isSelected ? 'selected' : ''} ${isToday ? 'is-today' : ''}" 
                      onclick="selectMobileDay('${date.toISOString()}')">
            <div class="day-strip-name">${dayName}</div>
            <div class="day-strip-number">${dayNum}</div>
        </div>`;
    }
    html += '</div>';
    
    // Event list for selected day
    html += '<div class="day-agenda-list">';
    
    const dayEvents = allOccurrences.filter(e => {
        const eventDate = e.date instanceof Date ? e.date : new Date(e.date);
        return eventDate.toDateString() === selectedDay.toDateString();
    }).sort((a, b) => {
        const aDate = new Date(a.date);
        const bDate = new Date(b.date);
        return aDate - bDate;
    });
    
    if (dayEvents.length === 0) {
        html += '<div class="day-agenda-empty">';
        html += '<i class="fas fa-calendar-day"></i>';
        html += '<p>No events today</p>';
        html += '</div>';
    } else {
        dayEvents.forEach(event => {
            const eventStartDate = new Date(event.date);
            const eventEndDate = event.endDate ? new Date(event.endDate) : new Date(eventStartDate.getTime() + 60*60*1000);
            const startTimeStr = formatTime24(eventStartDate.getHours(), eventStartDate.getMinutes());
            const endTimeStr = formatTime24(eventEndDate.getHours(), eventEndDate.getMinutes());
            const eventColor = event.color || '#007AFF';
            
            const isPrivate = event.visibility === 'private';
            const isAdmins = event.visibility === 'admins';
            const eventId = event.masterId || event.id;
            const occurrenceDateStr = event.occurrenceDate ? event.occurrenceDate.toISOString() : '';
            
            html += `
                <div class="day-event-row" 
                     onclick="viewEventDetails('${escapeHtml(eventId)}', '${occurrenceDateStr}')"
                     style="border-left-color: ${escapeHtml(eventColor)};">
                    <div class="day-event-time">${startTimeStr}</div>
                    <div class="day-event-content">
                        <div class="day-event-title">${escapeHtml(event.title)}</div>
                        <div class="day-event-duration">${startTimeStr} â€“ ${endTimeStr}</div>
                    </div>
                    <div class="day-event-badges">
                        ${isPrivate ? '<span class="event-badge private-badge"><i class="fas fa-lock"></i></span>' : ''}
                        ${isAdmins ? '<span class="event-badge admins-badge"><i class="fas fa-shield-alt"></i></span>' : ''}
                        ${event.isRecurrence ? '<span class="event-badge repeat-badge"><i class="fas fa-redo"></i></span>' : ''}
                    </div>
                </div>
            `;
        });
    }
    
    html += '</div>'; // Close .day-agenda-list
    html += '</div>'; // Close .day-agenda
    
    daysEl.innerHTML = html;
    
    // Swipe detection for mobile day navigation
    let touchStartX = 0;
    let touchEndX = 0;
    
    const dayAgenda = daysEl.querySelector('.day-agenda-list');
    if (dayAgenda) {
        dayAgenda.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
        }, { passive: true });
        
        dayAgenda.addEventListener('touchend', (e) => {
            touchEndX = e.changedTouches[0].screenX;
            handleSwipe();
        }, { passive: true });
    }
    
    function handleSwipe() {
        const threshold = 50;
        if (touchEndX < touchStartX - threshold) {
            // Swipe left - next day
            const nextDay = new Date(selectedDay);
            nextDay.setDate(nextDay.getDate() + 1);
            const endOfWeek = new Date(startOfWeek);
            endOfWeek.setDate(endOfWeek.getDate() + 6);
            if (nextDay <= endOfWeek) {
                selectMobileDay(nextDay.toISOString());
            }
        }
        
        if (touchEndX > touchStartX + threshold) {
            // Swipe right - previous day
            const prevDay = new Date(selectedDay);
            prevDay.setDate(prevDay.getDate() - 1);
            if (prevDay >= startOfWeek) {
                selectMobileDay(prevDay.toISOString());
            }
        }
    }
}

// Helper function to select a day in mobile view
function selectMobileDay(dateISOString) {
    appState.selectedMobileDay = new Date(dateISOString);
    renderCalendar();
}

// Format time in 24-hour format (HH:MM)
function formatTime24(hours, minutes) {
    return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
}

/**
 * Generate event occurrences for repeating events within a date range
 * @param {Object} event - The master event object
 * @param {Date} rangeStart - Start of the visible range
 * @param {Date} rangeEnd - End of the visible range
 * @returns {Array} Array of occurrence objects
 */
function getEventOccurrences(event, rangeStart, rangeEnd) {
    const occurrences = [];
    const repeat = event.repeat || 'none';
    
    if (DEBUG && repeat !== 'none') {
        console.log('ðŸ”„ Generating occurrences for repeating event:', {
            eventId: event.id,
            title: event.title,
            repeat: repeat,
            repeatStart: event.repeatStart,
            rangeStart: rangeStart.toISOString(),
            rangeEnd: rangeEnd.toISOString()
        });
    }
    
    // Non-repeating events: return single occurrence if in range
    if (repeat === 'none') {
        const eventDate = event.date instanceof Date ? event.date : new Date(event.date);
        if (eventDate >= rangeStart && eventDate <= rangeEnd) {
            occurrences.push({
                ...event,
                occurrenceId: event.id,
                occurrenceDate: eventDate,
                masterId: event.id
            });
        }
        return occurrences;
    }
    
    // Get the repeat start date (defaults to event date)
    const repeatStart = event.repeatStart 
        ? (event.repeatStart instanceof Date ? event.repeatStart : new Date(event.repeatStart))
        : (event.date instanceof Date ? event.date : new Date(event.date));
    
    // Calculate event duration in milliseconds
    const eventStartDate = event.date instanceof Date ? event.date : new Date(event.date);
    const eventEndDate = event.endDate 
        ? (event.endDate instanceof Date ? event.endDate : new Date(event.endDate))
        : new Date(eventStartDate.getTime() + 60 * 60 * 1000); // Default 1 hour
    const durationMs = eventEndDate.getTime() - eventStartDate.getTime();
    
    // Start time components from original event
    const startHour = eventStartDate.getHours();
    const startMinute = eventStartDate.getMinutes();
    
    // Generate occurrences based on repeat type
    let currentDate = new Date(repeatStart);
    
    // Don't generate occurrences before the repeat start
    if (currentDate < rangeStart) {
        // Fast-forward to rangeStart
        switch (repeat) {
            case 'daily':
                const daysDiff = Math.floor((rangeStart - currentDate) / (24 * 60 * 60 * 1000));
                currentDate.setDate(currentDate.getDate() + daysDiff);
                break;
            case 'weekly':
                const weeksDiff = Math.floor((rangeStart - currentDate) / (7 * 24 * 60 * 60 * 1000));
                currentDate.setDate(currentDate.getDate() + (weeksDiff * 7));
                break;
            case 'monthly':
                currentDate.setFullYear(rangeStart.getFullYear());
                currentDate.setMonth(rangeStart.getMonth() - 1);
                break;
            case 'yearly':
                currentDate.setFullYear(rangeStart.getFullYear() - 1);
                break;
        }
    }
    
    // Limit iterations to prevent infinite loops
    const maxIterations = 400; // ~1 year of daily events
    let iterations = 0;
    
    while (currentDate <= rangeEnd && iterations < maxIterations) {
        iterations++;
        
        // Check if this occurrence is valid and in range
        const occurrenceDate = new Date(currentDate);
        occurrenceDate.setHours(startHour, startMinute, 0, 0);
        
        if (occurrenceDate >= rangeStart && occurrenceDate <= rangeEnd && occurrenceDate >= repeatStart) {
            // For monthly: check if day exists in this month
            if (repeat === 'monthly') {
                const targetDay = repeatStart.getDate();
                const daysInMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0).getDate();
                if (targetDay > daysInMonth) {
                    // Skip this month if day doesn't exist (e.g., 31st in February)
                    currentDate.setMonth(currentDate.getMonth() + 1);
                    continue;
                }
            }
            
            // For yearly: check for Feb 29 on non-leap years
            if (repeat === 'yearly') {
                const targetMonth = repeatStart.getMonth();
                const targetDay = repeatStart.getDate();
                if (targetMonth === 1 && targetDay === 29) {
                    const year = currentDate.getFullYear();
                    const isLeapYear = (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
                    if (!isLeapYear) {
                        currentDate.setFullYear(currentDate.getFullYear() + 1);
                        continue;
                    }
                }
            }
            
            const occurrenceEndDate = new Date(occurrenceDate.getTime() + durationMs);
            const dateKey = `${occurrenceDate.getFullYear()}${String(occurrenceDate.getMonth() + 1).padStart(2, '0')}${String(occurrenceDate.getDate()).padStart(2, '0')}`;
            
            occurrences.push({
                ...event,
                date: occurrenceDate,
                endDate: occurrenceEndDate,
                occurrenceId: `${event.id}_${dateKey}`,
                occurrenceDate: occurrenceDate,
                masterId: event.id,
                isRecurrence: true
            });
        }
        
        // Move to next occurrence
        switch (repeat) {
            case 'daily':
                currentDate.setDate(currentDate.getDate() + 1);
                break;
            case 'weekly':
                currentDate.setDate(currentDate.getDate() + 7);
                break;
            case 'monthly':
                currentDate.setMonth(currentDate.getMonth() + 1);
                // Ensure we're on the right day of month
                const targetDay = repeatStart.getDate();
                const daysInMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0).getDate();
                currentDate.setDate(Math.min(targetDay, daysInMonth));
                break;
            case 'yearly':
                currentDate.setFullYear(currentDate.getFullYear() + 1);
                break;
        }
    }
    
    return occurrences;
}

/**
 * Get ordinal suffix for a number (1st, 2nd, 3rd, etc.)
 */
function getOrdinalSuffix(n) {
    const s = ['th', 'st', 'nd', 'rd'];
    const v = n % 100;
    return s[(v - 20) % 10] || s[v] || s[0];
}

/**
 * Get all event occurrences for a date range, expanding repeating events
 * @param {Array} events - Array of master events
 * @param {Date} rangeStart - Start of the visible range
 * @param {Date} rangeEnd - End of the visible range
 * @returns {Array} Array of all occurrences
 */
function getAllEventOccurrences(events, rangeStart, rangeEnd) {
    let allOccurrences = [];
    
    for (const event of events) {
        const occurrences = getEventOccurrences(event, rangeStart, rangeEnd);
        allOccurrences = allOccurrences.concat(occurrences);
    }
    
    return allOccurrences;
}

// Toggle task overflow popover
window.toggleTaskOverflowPopover = function(element) {
    const popover = element.querySelector('.week-overflow-popover');
    if (popover) {
        const isVisible = popover.classList.contains('show');
        // Close all other popovers first
        document.querySelectorAll('.week-overflow-popover.show').forEach(p => p.classList.remove('show'));
        if (!isVisible) {
            popover.classList.add('show');
        }
    }
};

// Navigate to the sheet containing a specific task
/**
 * SINGLE SOURCE OF TRUTH: Navigate to a spreadsheet from anywhere
 * This function ensures proper cleanup and consistent navigation behavior
 */
async function navigateToSpreadsheet(spreadsheetId, options = {}) {
    const { highlightTaskId } = options;
    
    // Find the spreadsheet
    const spreadsheet = appState.spreadsheets.find(s => s.id === spreadsheetId);
    if (!spreadsheet) {
        showToast('Sheet not found', 'error');
        console.error('Spreadsheet not found:', spreadsheetId);
        return;
    }
    
    // 1. Close doc panel if open (with full cleanup)
    if (appState.activeDocId && window.closeDocPanel) {
        await window.closeDocPanel();
    }
    
    // 2. Close any sheet preview overlays/drawers
    if (window.closeSheetPreview) {
        window.closeSheetPreview();
    }
    
    // 3. Ensure we're on the tasks tab
    if (typeof window.switchTab === 'function') {
        window.switchTab('tasks');
    }
    
    // 4. Switch tasks view to sheets (not docs)
    if (typeof switchTasksView === 'function') {
        switchTasksView('sheets');
    }
    
    // 5. Close any previously open spreadsheet cleanly
    const tasksSection = document.getElementById('tasks-section');
    if (tasksSection) {
        tasksSection.classList.remove('spreadsheet-open');
        tasksSection.classList.remove('doc-open');
    }
    
    // 6. Open the target spreadsheet using canonical function
    await openSpreadsheetPanel(spreadsheet);
    
    // 7. Highlight task row if requested
    if (highlightTaskId) {
        setTimeout(() => {
            const taskRow = document.querySelector(`tr[data-task-id="${highlightTaskId}"]`);
            if (taskRow) {
                // Scroll within the nearest table container (not the whole page)
                const scrollContainer = taskRow.closest('.table-container') || taskRow.closest('.spreadsheet-table-area') || document.querySelector('.table-container') || document.querySelector('.spreadsheet-table-area');
                if (scrollContainer) {
                    const rowRect = taskRow.getBoundingClientRect();
                    const containerRect = scrollContainer.getBoundingClientRect();
                    const currentScroll = scrollContainer.scrollTop;
                    const targetScroll = currentScroll + (rowRect.top - containerRect.top) - (containerRect.height / 2) + (rowRect.height / 2);
                    scrollContainer.scrollTo({ top: Math.max(0, targetScroll), behavior: 'smooth' });
                } else {
                    taskRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
                taskRow.classList.add('highlight-row');
                setTimeout(() => taskRow.classList.remove('highlight-row'), 2400);
            }
        }, 400);
    }
}

window.navigateToSpreadsheet = navigateToSpreadsheet;

/**
 * Navigate to a task's sheet (calls navigateToSpreadsheet internally)
 */
window.navigateToTaskSheet = async function(taskId) {
    // Close search UI
    if (window.clearSearchUI) {
        window.clearSearchUI();
    }
    
    const task = appState.tasks.find(t => t.id === taskId);
    if (!task) {
        showToast('Task not found', 'error');
        console.error('Task not found:', taskId);
        return;
    }
    
    const sheetId = task.sheetId || task.spreadsheetId;
    if (!sheetId) {
        showToast('Opening task details...', 'info');
        if (window.viewTaskDetails) {
            window.viewTaskDetails(taskId);
        }
        return;
    }
    
    // Use the single source of truth
    await navigateToSpreadsheet(sheetId, { highlightTaskId: taskId });
};

// Close popovers when clicking outside
document.addEventListener('click', (e) => {
    if (!e.target.closest('.week-allday-overflow')) {
        document.querySelectorAll('.week-overflow-popover.show').forEach(p => p.classList.remove('show'));
    }
});

function getStartOfWeek(date) {
    const d = new Date(date);
    const day = d.getDay();
    // Adjust so Monday is the first day of the week (0 = Sunday, 1 = Monday, etc.)
    const diff = day === 0 ? -6 : 1 - day; // If Sunday, go back 6 days; otherwise go back to Monday
    const result = new Date(d);
    result.setDate(d.getDate() + diff);
    return result;
}

// ===================================
// CALENDAR DRAG AND DROP
// ===================================
function initCalendarDragDrop() {
    // Support both old (.week-event-block) and new (.week-col-event) event selectors
    const eventBlocks = document.querySelectorAll('.week-event-block[draggable="true"], .week-col-event[draggable="true"]');
    const dayColumns = document.querySelectorAll('.week-day-column');
    const timeCells = document.querySelectorAll('.week-time-cell');
    const gridCells = document.querySelectorAll('.week-grid-cell'); // New column view cells
    
    // Month view elements
    const monthEventItems = document.querySelectorAll('.month-event-item[draggable="true"]');
    const calendarDays = document.querySelectorAll('.calendar-day');
    
    console.log('[DragDrop] Initializing with', eventBlocks.length, 'week events,', monthEventItems.length, 'month events,', gridCells.length, 'grid cells');
    
    eventBlocks.forEach(block => {
        block.addEventListener('dragstart', handleEventDragStart);
        block.addEventListener('dragend', handleEventDragEnd);
    });
    
    // Month view drag and drop
    monthEventItems.forEach(item => {
        item.addEventListener('dragstart', handleMonthEventDragStart);
        item.addEventListener('dragend', handleMonthEventDragEnd);
    });
    
    calendarDays.forEach(day => {
        day.addEventListener('dragover', handleMonthDayDragOver);
        day.addEventListener('dragleave', handleMonthDayDragLeave);
        day.addEventListener('drop', handleMonthDayDrop);
    });
    
    dayColumns.forEach(column => {
        column.addEventListener('dragover', handleEventDragOver);
        column.addEventListener('dragleave', handleEventDragLeave);
        column.addEventListener('drop', handleEventDrop);
    });
    
    // Support both old time cells and new grid cells
    timeCells.forEach(cell => {
        cell.addEventListener('dragover', handleCellDragOver);
        cell.addEventListener('dragleave', handleCellDragLeave);
        cell.addEventListener('drop', handleCellDrop);
    });
    
    gridCells.forEach(cell => {
        cell.addEventListener('dragover', handleGridCellDragOver);
        cell.addEventListener('dragleave', handleGridCellDragLeave);
        cell.addEventListener('drop', handleGridCellDrop);
    });
    
    // Initialize week view resize functionality
    initWeekEventResize();
}

// ===================================
// WEEK VIEW EVENT RESIZE
// ===================================
let resizingEvent = null;
let resizeStartY = 0;
let resizeStartHeight = 0;
let resizeStartTop = 0;
let resizeEventId = null;
let resizeDirection = null; // 'top' or 'bottom'

function initWeekEventResize() {
    const resizeHandles = document.querySelectorAll('.week-event-resize-handle');
    
    resizeHandles.forEach(handle => {
        handle.addEventListener('mousedown', startResize);
    });
    
    // Also set up touch events for mobile
    resizeHandles.forEach(handle => {
        handle.addEventListener('touchstart', startResizeTouch, { passive: false });
    });
}

function startResize(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const handle = e.target.closest('.week-event-resize-handle');
    const eventEl = e.target.closest('.week-col-event');
    if (!eventEl || !handle) return;
    
    resizingEvent = eventEl;
    resizeEventId = eventEl.dataset.eventId;
    resizeStartY = e.clientY;
    resizeStartHeight = eventEl.offsetHeight;
    resizeStartTop = parseFloat(eventEl.style.top);
    resizeDirection = handle.dataset.resize; // 'top' or 'bottom'
    
    // Disable dragging while resizing
    eventEl.setAttribute('draggable', 'false');
    eventEl.classList.add('resizing');
    
    document.addEventListener('mousemove', doResize);
    document.addEventListener('mouseup', stopResize);
}

function startResizeTouch(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const touch = e.touches[0];
    const handle = e.target.closest('.week-event-resize-handle');
    const eventEl = e.target.closest('.week-col-event');
    if (!eventEl || !handle) return;
    
    resizingEvent = eventEl;
    resizeEventId = eventEl.dataset.eventId;
    resizeStartY = touch.clientY;
    resizeStartHeight = eventEl.offsetHeight;
    resizeStartTop = parseFloat(eventEl.style.top);
    resizeDirection = handle.dataset.resize;
    
    eventEl.setAttribute('draggable', 'false');
    eventEl.classList.add('resizing');
    
    document.addEventListener('touchmove', doResizeTouch, { passive: false });
    document.addEventListener('touchend', stopResizeTouch);
}

function doResize(e) {
    if (!resizingEvent) return;
    
    const SLOT_HEIGHT = 60; // px per hour
    const MIN_HEIGHT = 30; // minimum 30 minutes
    const START_HOUR = 6;
    
    const deltaY = e.clientY - resizeStartY;
    
    if (resizeDirection === 'bottom') {
        // Dragging bottom - change end time
        let newHeight = resizeStartHeight + deltaY;
        const snapInterval = SLOT_HEIGHT / 4; // 15px for 15 minutes
        newHeight = Math.round(newHeight / snapInterval) * snapInterval;
        newHeight = Math.max(MIN_HEIGHT, newHeight);
        
        resizingEvent.style.height = newHeight + 'px';
    } else if (resizeDirection === 'top') {
        // Dragging top - change start time (move top and adjust height)
        const snapInterval = SLOT_HEIGHT / 4;
        let newTop = resizeStartTop + deltaY;
        newTop = Math.round(newTop / snapInterval) * snapInterval;
        newTop = Math.max(0, newTop); // Can't go above 6:00
        
        // Adjust height to keep the same end position
        const topDelta = newTop - resizeStartTop;
        let newHeight = resizeStartHeight - topDelta;
        newHeight = Math.max(MIN_HEIGHT, newHeight);
        
        // Recalculate top based on constrained height
        if (newHeight === MIN_HEIGHT && topDelta > 0) {
            newTop = resizeStartTop + resizeStartHeight - MIN_HEIGHT;
        }
        
        resizingEvent.style.top = newTop + 'px';
        resizingEvent.style.height = newHeight + 'px';
    }
    
    // Update the time display
    const topPosition = parseFloat(resizingEvent.style.top);
    const height = parseFloat(resizingEvent.style.height);
    const startMinutes = (topPosition / SLOT_HEIGHT) * 60 + START_HOUR * 60;
    const durationMinutes = (height / SLOT_HEIGHT) * 60;
    const endMinutes = startMinutes + durationMinutes;
    
    const startHour = Math.floor(startMinutes / 60);
    const startMin = Math.round(startMinutes % 60);
    const endHour = Math.floor(endMinutes / 60);
    const endMin = Math.round(endMinutes % 60);
    
    const startTimeStr = formatTime24(startHour, startMin);
    const endTimeStr = formatTime24(endHour, endMin);
    
    // Update the time range display
    resizingEvent.dataset.timeRange = `${startTimeStr}â€“${endTimeStr}`;
    const hoverTime = resizingEvent.querySelector('.hover-time');
    if (hoverTime) {
        hoverTime.textContent = `${startTimeStr}â€“${endTimeStr}`;
    }
    
    // Update inline time display
    const inlineTime = resizingEvent.querySelector('.week-event-time-inline');
    if (inlineTime) {
        inlineTime.textContent = startTimeStr;
    }
}

function doResizeTouch(e) {
    if (!resizingEvent) return;
    e.preventDefault();
    
    // Create a fake mouse event with touch coordinates
    const touch = e.touches[0];
    const fakeEvent = { clientY: touch.clientY };
    doResize(fakeEvent);
}

async function stopResize(e) {
    if (!resizingEvent || !resizeEventId) {
        cleanup();
        return;
    }
    
    const SLOT_HEIGHT = 60;
    const START_HOUR = 6;
    
    const newHeight = resizingEvent.offsetHeight;
    const topPosition = parseFloat(resizingEvent.style.top);
    
    // Calculate new start and end times
    const startMinutes = (topPosition / SLOT_HEIGHT) * 60 + START_HOUR * 60;
    const durationMinutes = (newHeight / SLOT_HEIGHT) * 60;
    const endMinutes = startMinutes + durationMinutes;
    
    const startHour = Math.floor(startMinutes / 60);
    const startMin = Math.round(startMinutes % 60);
    const endHour = Math.floor(endMinutes / 60);
    const endMin = Math.round(endMinutes % 60);
    
    // Update event in Firestore
    await resizeEventTime(resizeEventId, startHour, startMin, endHour, endMin);
    
    cleanup();
    
    function cleanup() {
        if (resizingEvent) {
            resizingEvent.setAttribute('draggable', 'true');
            resizingEvent.classList.remove('resizing');
        }
        resizingEvent = null;
        resizeEventId = null;
        resizeStartY = 0;
        resizeStartHeight = 0;
        resizeStartTop = 0;
        resizeDirection = null;
        document.removeEventListener('mousemove', doResize);
        document.removeEventListener('mouseup', stopResize);
    }
}

async function stopResizeTouch(e) {
    await stopResize(e);
    document.removeEventListener('touchmove', doResizeTouch);
    document.removeEventListener('touchend', stopResizeTouch);
}

async function resizeEventTime(eventId, newStartHour, newStartMin, newEndHour, newEndMin) {
    const event = appState.events.find(e => e.id === eventId);
    if (!event) {
        showToast('Event not found', 'error');
        return;
    }
    
    const oldStartDate = new Date(event.date);
    
    // Create new start date keeping the same day
    const newStartDate = new Date(oldStartDate);
    newStartDate.setHours(newStartHour, newStartMin, 0, 0);
    
    // Create new end date
    const newEndDate = new Date(oldStartDate);
    newEndDate.setHours(newEndHour, newEndMin, 0, 0);
    
    // Make sure end is after start
    if (newEndDate <= newStartDate) {
        newEndDate.setTime(newStartDate.getTime() + 30 * 60 * 1000); // Minimum 30 minutes
    }
    
    // Update local state
    event.date = newStartDate;
    event.endDate = newEndDate;
    event.time = newStartDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
    event.endTime = newEndDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
    
    // Update in Firestore
    try {
        await updateEventInFirestore(event);
        showToast('Event time updated', 'success');
        // Preserve scroll position when re-rendering after resize
        const scrollContainer = document.querySelector('.week-view-scroll-container');
        const scrollTop = scrollContainer ? scrollContainer.scrollTop : 0;
        renderCalendar();
        // Restore scroll position after render
        requestAnimationFrame(() => {
            const newScrollContainer = document.querySelector('.week-view-scroll-container');
            if (newScrollContainer) {
                newScrollContainer.scrollTop = scrollTop;
            }
        });
    } catch (error) {
        console.error('Error resizing event:', error);
        showToast('Failed to update event', 'error');
    }
}

// ===================================
// MONTH VIEW DRAG AND DROP
// ===================================
let monthDraggedEventId = null;
let monthDraggedElement = null;
let monthDraggedOriginalTime = null;
let monthDragStarted = false;

function handleMonthEventDragStart(e) {
    const eventItem = e.target.closest('.month-event-item');
    if (!eventItem) return;
    
    monthDraggedEventId = eventItem.dataset.eventId;
    monthDraggedElement = eventItem;
    monthDraggedOriginalTime = eventItem.dataset.originalTime;
    monthDragStarted = true;
    
    eventItem.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', monthDraggedEventId);
    
    // Create a drag image
    const dragImage = eventItem.cloneNode(true);
    dragImage.style.position = 'absolute';
    dragImage.style.top = '-1000px';
    document.body.appendChild(dragImage);
    e.dataTransfer.setDragImage(dragImage, 0, 0);
    setTimeout(() => dragImage.remove(), 0);
    
    console.log('[MonthDrag] Started dragging:', monthDraggedEventId, 'time:', monthDraggedOriginalTime);
}

function handleMonthEventDragEnd(e) {
    const eventItem = e.target.closest('.month-event-item');
    if (eventItem) {
        eventItem.classList.remove('dragging');
    }
    
    monthDraggedEventId = null;
    monthDraggedElement = null;
    monthDraggedOriginalTime = null;
    
    // Reset drag flag after a short delay to prevent click firing
    setTimeout(() => {
        monthDragStarted = false;
    }, 100);
    
    // Remove all drag-over highlights
    document.querySelectorAll('.calendar-day.drag-over').forEach(el => el.classList.remove('drag-over'));
    console.log('[MonthDrag] Drag ended');
}

function handleMonthDayDragOver(e) {
    // CRITICAL: Must call preventDefault FIRST to allow drop - browsers require this
    e.preventDefault();
    e.stopPropagation();
    
    // Set drop effect - must be done even if no event being dragged
    // 'move' tells the browser this is a valid drop target
    e.dataTransfer.dropEffect = monthDraggedEventId ? 'move' : 'none';
    
    // Only show visual feedback if we're dragging a month event
    if (monthDraggedEventId) {
        // Find the calendar-day element - could be currentTarget or need to traverse up
        let day = e.currentTarget;
        if (!day.classList.contains('calendar-day')) {
            day = e.target.closest('.calendar-day');
        }
        if (day) {
            day.classList.add('drag-over');
        }
    }
}

function handleMonthDayDragLeave(e) {
    // Find the calendar-day element
    let day = e.currentTarget;
    if (!day.classList.contains('calendar-day')) {
        day = e.target.closest('.calendar-day');
    }
    
    // Only remove if we're actually leaving the day (not entering a child)
    if (day && !day.contains(e.relatedTarget)) {
        day.classList.remove('drag-over');
    }
}

async function handleMonthDayDrop(e) {
    e.preventDefault();
    e.stopPropagation();
    
    // Find the calendar-day element - could be currentTarget or need to traverse up
    let day = e.currentTarget;
    if (!day.classList.contains('calendar-day')) {
        day = e.target.closest('.calendar-day');
    }
    
    if (!day) {
        console.log('[MonthDrag] No calendar-day found');
        return;
    }
    
    day.classList.remove('drag-over');
    
    // Remove all drag-over states
    document.querySelectorAll('.calendar-day.drag-over').forEach(el => el.classList.remove('drag-over'));
    
    if (!monthDraggedEventId) {
        console.log('[MonthDrag] No dragged event ID');
        return;
    }
    
    const dateStr = day.dataset.date;
    if (!dateStr) {
        console.log('[MonthDrag] Invalid drop target - missing date');
        return;
    }
    
    const newDate = new Date(dateStr);
    console.log('[MonthDrag] Dropping event:', monthDraggedEventId, 'onto date:', newDate.toDateString());
    
    // Store the event ID before it gets cleared
    const eventIdToReschedule = monthDraggedEventId;
    
    // Clear drag state immediately
    monthDraggedEventId = null;
    monthDraggedElement = null;
    monthDraggedOriginalTime = null;
    
    // Reschedule the event keeping the same time but changing the date
    await rescheduleMonthEvent(eventIdToReschedule, newDate);
}

async function rescheduleMonthEvent(eventId, newDate) {
    const event = appState.events.find(e => e.id === eventId);
    if (!event) {
        showToast('Event not found', 'error');
        return;
    }
    
    // Get the original times
    const oldStartDate = new Date(event.date);
    const oldEndDate = event.endDate ? new Date(event.endDate) : new Date(oldStartDate.getTime() + 60 * 60 * 1000);
    const duration = oldEndDate.getTime() - oldStartDate.getTime();
    
    // Create new date keeping the same time
    const newStartDate = new Date(newDate);
    newStartDate.setHours(oldStartDate.getHours(), oldStartDate.getMinutes(), 0, 0);
    const newEndDate = new Date(newStartDate.getTime() + duration);
    
    // Update local state
    event.date = newStartDate;
    event.endDate = newEndDate;
    
    // Update in Firestore
    try {
        await updateEventInFirestore(event);
        showToast('Event moved to ' + newStartDate.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' }), 'success');
        renderCalendar();
    } catch (error) {
        console.error('Error moving event:', error);
        showToast('Failed to move event', 'error');
    }
}

let draggedEventId = null;
let draggedEventElement = null;
let dragOffsetY = 0; // Offset from top of event where user clicked

function handleEventDragStart(e) {
    draggedEventId = e.target.dataset.eventId;
    draggedEventElement = e.target;
    
    // Calculate offset from top of event element to mouse position
    const rect = e.target.getBoundingClientRect();
    dragOffsetY = e.clientY - rect.top;
    
    e.target.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', draggedEventId);
    console.log('[DragDrop] Started dragging event:', draggedEventId, 'offsetY:', dragOffsetY);
}

function handleEventDragEnd(e) {
    e.target.classList.remove('dragging');
    draggedEventId = null;
    draggedEventElement = null;
    dragOffsetY = 0;
    
    // Remove all drag-over highlights
    document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
    console.log('[DragDrop] Drag ended');
}

function handleEventDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
}

function handleEventDragLeave(e) {
    e.target.classList.remove('drag-over');
}

function handleCellDragOver(e) {
    e.preventDefault();
    e.target.classList.add('drag-over');
    e.dataTransfer.dropEffect = 'move';
}

function handleCellDragLeave(e) {
    e.target.classList.remove('drag-over');
}

// Dedicated handlers for week grid cells (column view)
function handleGridCellDragOver(e) {
    e.preventDefault();
    e.stopPropagation();
    
    // Only highlight if we're dragging an event
    if (!draggedEventId) return;
    
    e.currentTarget.classList.add('drag-over');
    e.dataTransfer.dropEffect = 'move';
}

function handleGridCellDragLeave(e) {
    e.currentTarget.classList.remove('drag-over');
}

async function handleGridCellDrop(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const cell = e.currentTarget;
    cell.classList.remove('drag-over');
    
    // Remove all drag-over states
    document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
    
    if (!draggedEventId) {
        console.log('[DragDrop] No dragged event ID');
        return;
    }
    
    // Get the day column for the date
    const column = cell.closest('.week-day-column');
    const dateStr = column?.dataset.date;
    
    if (!dateStr) {
        console.log('[DragDrop] Invalid drop target - missing date');
        return;
    }
    
    // Calculate the drop position based on the TOP of the event (not mouse position)
    // The top of the event = mouse position - drag offset
    const eventTopY = e.clientY - dragOffsetY;
    
    // Find the grid container to calculate relative position
    const gridContainer = column.querySelector('.week-day-grid');
    const gridRect = gridContainer.getBoundingClientRect();
    
    // Calculate position relative to the grid (in pixels from top of grid)
    const relativeY = eventTopY - gridRect.top;
    
    // Each cell is 60px (SLOT_HEIGHT), starting from hour 6 (START_HOUR)
    const SLOT_HEIGHT = 60;
    const START_HOUR = 6;
    
    // Calculate total minutes from the top of the grid
    const totalMinutesFromStart = (relativeY / SLOT_HEIGHT) * 60;
    
    // Calculate hour and minute (snap to 30-minute intervals)
    const hour = Math.floor(totalMinutesFromStart / 60) + START_HOUR;
    const rawMinute = totalMinutesFromStart % 60;
    const minute = Math.round(rawMinute / 30) * 30; // Snap to 0 or 30
    
    // Clamp values to valid range
    const clampedHour = Math.max(START_HOUR, Math.min(22, hour));
    const clampedMinute = Math.max(0, Math.min(30, minute));
    
    const newDate = new Date(dateStr);
    newDate.setHours(clampedHour, clampedMinute, 0, 0);
    
    console.log('[DragDrop] Rescheduling to:', newDate, 'hour:', clampedHour, 'minute:', clampedMinute);
    
    await rescheduleEvent(draggedEventId, newDate, clampedHour, clampedMinute);
}

async function handleEventDrop(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const column = e.currentTarget;
    column.classList.remove('drag-over');
    
    if (!draggedEventId) return;
    
    const newDateStr = column.dataset.date;
    if (!newDateStr) return;
    
    await rescheduleEvent(draggedEventId, new Date(newDateStr));
}

async function handleCellDrop(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const cell = e.target;
    cell.classList.remove('drag-over');
    
    if (!draggedEventId) return;
    
    // Try to get hour from cell dataset (old week view: .week-time-cell)
    let hour = parseInt(cell.dataset.hour);
    let dateStr = cell.dataset.date;
    
    // If no hour, try to get from parent column and calculate from mouse position (new column view: .week-grid-cell)
    if (isNaN(hour)) {
        const column = cell.closest('.week-day-column');
        if (!column) return;
        
        dateStr = column.dataset.date;
        const cellRect = cell.getBoundingClientRect();
        const mouseY = e.clientY - cellRect.top;
        const cellIndex = Array.from(column.querySelectorAll('.week-grid-cell')).indexOf(cell);
        
        // Each cell represents 1 hour starting from hour 6
        const START_HOUR = 6;
        hour = START_HOUR + cellIndex;
        
        // Calculate minute based on mouse position within cell (snap to 15-minute intervals)
        const minuteFraction = mouseY / cellRect.height;
        const minute = Math.round(minuteFraction * 4) * 15; // 0, 15, 30, or 45
        
        if (!dateStr) return;
        
        const newDate = new Date(dateStr);
        newDate.setHours(hour, minute, 0, 0);
        
        await rescheduleEvent(draggedEventId, newDate, hour, minute);
        return;
    }
    
    // Old behavior for .week-time-cell
    if (isNaN(hour) || !dateStr) return;
    
    const newDate = new Date(dateStr);
    newDate.setHours(hour, 0, 0, 0);
    
    await rescheduleEvent(draggedEventId, newDate, hour);
}

async function rescheduleEvent(eventId, newDate, newHour = null, newMinute = 0) {
    const event = appState.events.find(e => e.id === eventId);
    if (!event) {
        showToast('Event not found', 'error');
        return;
    }
    
    // Calculate the new start time
    const oldDate = new Date(event.date);
    const oldEndDate = event.endDate ? new Date(event.endDate) : new Date(oldDate.getTime() + 60*60*1000);
    const duration = oldEndDate.getTime() - oldDate.getTime();
    
    // Create new date preserving original time unless hour is specified
    const newStartDate = new Date(newDate);
    if (newHour !== null) {
        newStartDate.setHours(newHour, newMinute, 0, 0);
    } else {
        newStartDate.setHours(oldDate.getHours(), oldDate.getMinutes(), 0, 0);
    }
    
    const newEndDate = new Date(newStartDate.getTime() + duration);
    
    // Update local state
    event.date = newStartDate;
    event.endDate = newEndDate;
    event.time = newStartDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
    event.endTime = newEndDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
    
    // Update in Firestore
    try {
        await updateEventInFirestore(event);
        showToast('Event rescheduled', 'success');
        // Preserve scroll position when re-rendering after week drag-drop
        const scrollContainer = document.querySelector('.week-view-scroll-container');
        const scrollTop = scrollContainer ? scrollContainer.scrollTop : 0;
        renderCalendar();
        // Restore scroll position after render
        requestAnimationFrame(() => {
            const newScrollContainer = document.querySelector('.week-view-scroll-container');
            if (newScrollContainer) {
                newScrollContainer.scrollTop = scrollTop;
            }
        });
    } catch (error) {
        console.error('Error rescheduling event:', error);
        showToast('Failed to reschedule event', 'error');
    }
}

// ===================================
// TASK MANAGEMENT
// ===================================

// Spreadsheet state for sorting, filtering, selection
const spreadsheetState = {
    sortColumn: null,
    sortDirection: 'asc',
    filters: { status: '', priority: '', assignee: '' },
    searchQuery: '',
    selectedTasks: new Set(),
    showCompleted: localStorage.getItem('showCompletedTasks') === 'true' // Default: hide completed
};

function initTasks() {
    const addTaskBtn = document.getElementById('addTaskBtn');

    // Don't load from localStorage on init - Firestore will provide the source of truth
    // Tasks will be loaded via loadTasksFromFirestore() in loadTeamData()
    
    // Add task button
    if (addTaskBtn) {
        addTaskBtn.addEventListener('click', () => {
            // Reset form for new task
            document.getElementById('taskForm').reset();
            delete document.getElementById('taskForm').dataset.editingTaskId;
            
            // Update modal title and button for unified modal
            const titleEl = document.querySelector('#taskModal .unified-modal-title h2');
            const submitBtn = document.querySelector('#taskModal .unified-btn-primary');
            if (titleEl) titleEl.innerHTML = '<i class="fas fa-plus-circle"></i> New Task';
            if (submitBtn) submitBtn.innerHTML = '<i class="fas fa-check"></i> Create Task';
            
            populateTaskAssigneeDropdown(); // Populate with current team members
            populateTaskSpreadsheetDropdown(); // Populate with available spreadsheets
            resetTaskModalDropdowns(); // Reset all custom dropdowns to defaults
            
            // Set minimum date to today
            const taskDueDateInput = document.getElementById('taskDueDate');
            if (taskDueDateInput) {
                const today = new Date().toISOString().split('T')[0];
                taskDueDateInput.setAttribute('min', today);
            }
            
            openModal('taskModal');
        });
    }

    // Create spreadsheet card handler
    const createSpreadsheetBtn = document.getElementById('createSpreadsheetCard');
    if (createSpreadsheetBtn) {
        createSpreadsheetBtn.addEventListener('click', () => {
            openModal('spreadsheetModal');
        });
    }

    // Initialize spreadsheet modal handlers
    initSpreadsheetModal();
    
    // Initialize custom column modal handlers
    initCustomColumnModal();
    
    // Initialize spreadsheet panel handlers
    initSpreadsheetPanelHandlers();
    
    // Initialize spreadsheet context menu
    initSpreadsheetContextMenu();

    // Progress bar update (range slider + number input + fill bar + badge sync)
    const progressSlider = document.getElementById('taskProgressSlider');
    const progressInput = document.getElementById('taskProgress');
    const progressFill = document.getElementById('taskProgressFill');
    const progressBadge = document.getElementById('taskProgressBadge');
    
    function updateProgressVisuals(value) {
        if (progressFill) {
            progressFill.style.width = value + '%';
        }
        if (progressBadge) {
            progressBadge.textContent = value + '%';
        }
        if (progressSlider) {
            progressSlider.style.setProperty('--progress', value + '%');
        }
    }
    
    if (progressSlider && progressInput) {
        // Sync slider to input and visuals
        progressSlider.addEventListener('input', () => {
            const value = progressSlider.value;
            progressInput.value = value;
            updateProgressVisuals(value);
        });
        
        // Sync input to slider and visuals
        progressInput.addEventListener('input', () => {
            let value = parseInt(progressInput.value) || 0;
            value = Math.max(0, Math.min(100, value));
            progressSlider.value = value;
            updateProgressVisuals(value);
        });
        
        // On change (when user finishes typing), clamp and sync
        progressInput.addEventListener('change', () => {
            let value = parseInt(progressInput.value) || 0;
            value = Math.max(0, Math.min(100, value));
            progressInput.value = value;
            progressSlider.value = value;
            updateProgressVisuals(value);
        });
    }

    // ===================================
    // DISPLAY TASKS - Main entry point
    // ===================================
    function displayTasks() {
        // Update overview section counters
        const todoCount = appState.tasks.filter(t => t.status === 'todo').length;
        const inProgressCount = appState.tasks.filter(t => t.status === 'inprogress').length;
        const doneCount = appState.tasks.filter(t => t.status === 'done').length;
        const totalCount = appState.tasks.length;

        // Update metrics in overview
        const totalTasksCountEl = document.getElementById('totalTasksCount');
        const inProgressTasksCountEl = document.getElementById('inProgressTasksCount');
        const completedTasksCountEl = document.getElementById('completedTasksCount');
        
        if (totalTasksCountEl) totalTasksCountEl.textContent = totalCount;
        if (inProgressTasksCountEl) inProgressTasksCountEl.textContent = inProgressCount;
        if (completedTasksCountEl) completedTasksCountEl.textContent = doneCount;

        // Render spreadsheet cards
        renderSpreadsheetCards();
        
        // If spreadsheet panel is open, refresh its data
        if (appState.currentSpreadsheet) {
            renderSpreadsheetTable(appState.currentSpreadsheet);
        }
    }

    // ===================================
    // SPREADSHEET CARDS
    // ===================================
    function renderSpreadsheetCards() {
        const container = document.getElementById('spreadsheetCards');
        if (!container) return;

        // Keep the create card
        const createCardEl = container.querySelector('.create-new');
        container.innerHTML = '';
        if (createCardEl) container.appendChild(createCardEl);

        // Initialize spreadsheets array if not exists
        if (!appState.spreadsheets) {
            appState.spreadsheets = [];
        }

        // If no spreadsheets exist AND we've already loaded from Firestore, create a default "All Tasks" spreadsheet
        // IMPORTANT: Check _spreadsheetsLoaded flag to avoid race condition where displayTasks() is called
        // before loadSpreadsheetsFromFirestore() completes
        if (appState.spreadsheets.length === 0 && appState._spreadsheetsLoaded) {
            const defaultSpreadsheet = {
                id: 'default',
                name: 'All Tasks',
                color: '#0070f3',
                icon: 'fa-list-check',
                visibility: 'team',
                type: 'tasks',
                columns: ['title', 'status', 'assignee', 'priority', 'dueDate', 'progress'],
                createdBy: currentAuthUser?.uid || null,
                _needsFirstSave: true  // Flag to save only once
            };
            appState.spreadsheets.push(defaultSpreadsheet);
            // Save to Firestore ONCE (only if we have a valid user and it's truly new)
            // NOTE: saveSpreadsheetToFirestore will check if doc exists and handle create vs update
            if (currentAuthUser?.uid && defaultSpreadsheet._needsFirstSave) {
                delete defaultSpreadsheet._needsFirstSave;  // Remove flag before save
                // Only try to create if there's no existing 'default' spreadsheet in Firestore
                // The saveSpreadsheetToFirestore function will check doc existence
                saveSpreadsheetToFirestore(defaultSpreadsheet).catch(err => {
                    // Silently ignore if it already exists - will be loaded on next refresh
                    if (err.code !== 'permission-denied') {
                        console.warn('Could not create default spreadsheet:', err.message);
                    }
                });
            }
        }

        // Filter spreadsheets by visibility (show team + own private)
        const visibleSpreadsheets = appState.spreadsheets.filter(s => {
            if (s.visibility === 'private') {
                return s.createdBy === currentAuthUser?.uid;
            }
            return true; // team visibility or no visibility set (legacy)
        });

        // Render spreadsheet cards
        visibleSpreadsheets.forEach(spreadsheet => {
            const card = buildSpreadsheetCard(spreadsheet);
            container.insertBefore(card, createCardEl);
        });
    }

    // Build spreadsheet card with improved design
    function buildSpreadsheetCard(spreadsheet) {
        const card = document.createElement('div');
        card.className = 'spreadsheet-card';
        card.dataset.spreadsheetId = spreadsheet.id;

        // Determine if this is a leads table
        const isLeadsTable = spreadsheet.type === 'leads';

        // Count tasks/leads in this spreadsheet
        const spreadsheetTasks = getTasksForSpreadsheet(spreadsheet);
        const taskCount = spreadsheetTasks.length;
        const completedCount = spreadsheetTasks.filter(t => t.status === 'done').length;
        const progressPercent = taskCount > 0 ? Math.round((completedCount / taskCount) * 100) : 0;

        // Check if this is a private spreadsheet
        const isPrivate = spreadsheet.visibility === 'private';
        const privateTag = isPrivate ? '<span class="spreadsheet-private-tag"><i class="fas fa-lock"></i> Private</span>' : '';

        // Different metrics for leads vs tasks
        let metaHtml;
        if (isLeadsTable) {
            const wonCount = spreadsheetTasks.filter(t => t.status === 'won').length;
            metaHtml = `
                <span><i class="fas fa-user-tie"></i> ${taskCount} leads</span>
                <span><i class="fas fa-trophy"></i> ${wonCount} won</span>
            `;
        } else {
            metaHtml = `
                <span><i class="fas fa-tasks"></i> ${taskCount} tasks</span>
                <span><i class="fas fa-check-circle"></i> ${completedCount} done</span>
            `;
        }

        card.innerHTML = `
            <button class="spreadsheet-card-menu-btn" title="More options">
                <i class="fas fa-ellipsis-v"></i>
            </button>
            <div class="spreadsheet-card-header-row">
                <div class="spreadsheet-card-icon" style="background: ${spreadsheet.color}15; color: ${spreadsheet.color};">
                    <i class="fas ${spreadsheet.icon || 'fa-table'}"></i>
                </div>
            </div>
            <div class="spreadsheet-card-content">
                <h4 class="spreadsheet-card-title">${escapeHtml(spreadsheet.name)}</h4>
                <div class="spreadsheet-card-meta">
                    ${metaHtml}
                </div>
            </div>
            ${privateTag}
        `;

        // Click handler for the card (open spreadsheet)
        card.addEventListener('click', (e) => {
            // Don't open if clicking the menu button
            if (e.target.closest('.spreadsheet-card-menu-btn')) return;
            openSpreadsheetPanel(spreadsheet);
        });
        
        // 3-dot menu button click
        const menuBtn = card.querySelector('.spreadsheet-card-menu-btn');
        if (menuBtn) {
            menuBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                showSpreadsheetContextMenu(e, spreadsheet);
            });
        }
        
        // Right-click context menu
        card.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
            showSpreadsheetContextMenu(e, spreadsheet);
        });
        
        return card;
    }

    // ===================================
    // SPREADSHEET CONTEXT MENU
    // ===================================
    let contextMenuSpreadsheet = null;
    
    function initSpreadsheetContextMenu() {
        const menu = document.getElementById('spreadsheetContextMenu');
        if (!menu) return;
        
        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!menu.contains(e.target)) {
                hideSpreadsheetContextMenu();
            }
        });
        
        // Close menu on escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                hideSpreadsheetContextMenu();
            }
        });
        
        // Open action
        document.getElementById('contextMenuOpen')?.addEventListener('click', () => {
            if (contextMenuSpreadsheet) {
                openSpreadsheetPanel(contextMenuSpreadsheet);
            }
            hideSpreadsheetContextMenu();
        });
        
        // Rename action
        document.getElementById('contextMenuRename')?.addEventListener('click', () => {
            if (contextMenuSpreadsheet) {
                promptRenameSpreadsheet(contextMenuSpreadsheet);
            }
            hideSpreadsheetContextMenu();
        });
        
        // Edit action (icon, color, visibility)
        document.getElementById('contextMenuEdit')?.addEventListener('click', () => {
            if (contextMenuSpreadsheet) {
                openEditSpreadsheetModal(contextMenuSpreadsheet);
            }
            hideSpreadsheetContextMenu();
        });
        
        // Delete action
        document.getElementById('contextMenuDelete')?.addEventListener('click', () => {
            if (contextMenuSpreadsheet) {
                confirmDeleteSpreadsheet(contextMenuSpreadsheet);
            }
            hideSpreadsheetContextMenu();
        });
    }
    
    function showSpreadsheetContextMenu(e, spreadsheet) {
        const menu = document.getElementById('spreadsheetContextMenu');
        if (!menu) return;
        
        contextMenuSpreadsheet = spreadsheet;
        
        // Position menu near cursor
        let x = e.clientX;
        let y = e.clientY;
        
        // Show temporarily to get dimensions
        menu.style.left = x + 'px';
        menu.style.top = y + 'px';
        menu.classList.add('visible');
        
        // Adjust if menu goes off screen
        const rect = menu.getBoundingClientRect();
        if (rect.right > window.innerWidth) {
            x = window.innerWidth - rect.width - 10;
        }
        if (rect.bottom > window.innerHeight) {
            y = window.innerHeight - rect.height - 10;
        }
        
        menu.style.left = x + 'px';
        menu.style.top = y + 'px';
        
        // Disable delete for "default" spreadsheet
        const deleteItem = document.getElementById('contextMenuDelete');
        if (deleteItem) {
            if (spreadsheet.id === 'default') {
                deleteItem.style.opacity = '0.4';
                deleteItem.style.pointerEvents = 'none';
            } else {
                deleteItem.style.opacity = '1';
                deleteItem.style.pointerEvents = 'auto';
            }
        }
    }
    
    function hideSpreadsheetContextMenu() {
        const menu = document.getElementById('spreadsheetContextMenu');
        if (menu) {
            menu.classList.remove('visible');
        }
        contextMenuSpreadsheet = null;
    }
    
    function promptRenameSpreadsheet(spreadsheet) {
        // If the spreadsheet panel is open and it's the same spreadsheet, focus the title input
        if (appState.currentSpreadsheet?.id === spreadsheet.id) {
            const titleInput = document.querySelector('.spreadsheet-title-input');
            if (titleInput) {
                titleInput.focus();
                titleInput.select();
                return;
            }
        }
        
        // Otherwise, open the spreadsheet panel first and then focus the title
        openSpreadsheetPanel(spreadsheet);
        
        // Wait for panel to open, then focus and select the title input
        setTimeout(() => {
            const titleInput = document.querySelector('.spreadsheet-title-input');
            if (titleInput) {
                titleInput.focus();
                titleInput.select();
            }
        }, 100);
    }
    
    function openEditSpreadsheetModal(spreadsheet) {
        // Populate modal with existing values
        const modal = document.getElementById('spreadsheetModal');
        const form = document.getElementById('spreadsheetForm');
        const titleEl = modal.querySelector('.unified-modal-title h2');
        const subtitleEl = modal.querySelector('.unified-modal-title .subtitle');
        const submitBtn = modal.querySelector('.unified-btn-primary');
        
        // Update modal title
        if (titleEl) titleEl.innerHTML = '<i class=\"fas fa-palette\"></i> Edit Spreadsheet';
        if (subtitleEl) subtitleEl.textContent = 'Update icon, color, and visibility';
        if (submitBtn) submitBtn.innerHTML = '<i class=\"fas fa-check\"></i> Save Changes';
        
        // Hide name and type fields and remove required validation (can't change these after creation)
        const nameField = modal.querySelector('#spreadsheetName')?.closest('.unified-form-field');
        const nameInput = document.getElementById('spreadsheetName');
        const typeField = modal.querySelector('#typeSelectRow')?.closest('.unified-form-field');
        if (nameField) nameField.style.display = 'none';
        if (nameInput) nameInput.removeAttribute('required');
        if (typeField) typeField.style.display = 'none';
        
        // Set icon
        const iconButtons = modal.querySelectorAll('.unified-icon-option');
        iconButtons.forEach(btn => {
            const isSelected = btn.dataset.icon === spreadsheet.icon;
            btn.classList.toggle('selected', isSelected);
        });
        document.getElementById('spreadsheetIcon').value = spreadsheet.icon || 'fa-table';
        
        // Set color
        const colorButtons = modal.querySelectorAll('.unified-color-option');
        colorButtons.forEach(btn => {
            const isSelected = btn.dataset.color === spreadsheet.color;
            btn.classList.toggle('selected', isSelected);
        });
        document.getElementById('spreadsheetColor').value = spreadsheet.color || '#0070f3';
        
        // Set visibility
        const visibilityToggle = modal.querySelector('.visibility-toggle[data-target="spreadsheetVisibility"]');
        setVisibilitySelection(visibilityToggle, spreadsheet.visibility || 'team');
        
        // Store spreadsheet ID for editing
        form.dataset.editingSpreadsheetId = spreadsheet.id;
        
        openModal('spreadsheetModal');
    }
    
    async function confirmDeleteSpreadsheet(spreadsheet) {
        if (spreadsheet.id === 'default') {
            showToast('Cannot delete the default spreadsheet', 'error');
            return;
        }
        
        // Check permissions
        if (appState.currentTeamData && !isAdmin(appState.currentTeamData)) {
            if (spreadsheet.createdBy !== currentAuthUser?.uid) {
                showToast('You can only delete spreadsheets you created', 'error');
                return;
            }
        }
        
        // Get task count
        const taskCount = appState.tasks.filter(t => t.spreadsheetId === spreadsheet.id).length;
        const message = taskCount > 0 
            ? `Delete "${spreadsheet.name}"? This will also delete ${taskCount} task(s) in this spreadsheet.`
            : `Delete "${spreadsheet.name}"?`;
        
        const confirmed = await showConfirmModal(message, {
            title: 'Delete Spreadsheet',
            confirmText: 'Delete',
            type: 'danger'
        });
        if (!confirmed) return;
        
        try {
            // Delete from Firestore
            if (db && appState.currentTeamId) {
                const { doc, deleteDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
                await deleteDoc(doc(db, 'teams', appState.currentTeamId, 'spreadsheets', spreadsheet.id));
                
                // Also delete tasks in this spreadsheet
                if (taskCount > 0) {
                    const tasksToDelete = appState.tasks.filter(t => t.spreadsheetId === spreadsheet.id);
                    for (const task of tasksToDelete) {
                        await deleteDoc(doc(db, 'teams', appState.currentTeamId, 'tasks', task.id));
                    }
                    // Remove from local state
                    appState.tasks = appState.tasks.filter(t => t.spreadsheetId !== spreadsheet.id);
                }
            }
            
            // Remove from local state
            appState.spreadsheets = appState.spreadsheets.filter(s => s.id !== spreadsheet.id);
            
            // Close panel if this spreadsheet was open
            if (appState.currentSpreadsheet?.id === spreadsheet.id) {
                closeSpreadsheetPanel();
            }
            
            renderSpreadsheetCards();
            showToast('Spreadsheet deleted', 'success');
        } catch (error) {
            console.error('Error deleting spreadsheet:', error);
            showToast('Failed to delete spreadsheet', 'error');
        }
    }
    
    // Expose functions
    window.initSpreadsheetContextMenu = initSpreadsheetContextMenu;

    // ===================================
    // SPREADSHEET PANEL
    // ===================================
    async function openSpreadsheetPanel(spreadsheet) {
        // Close doc panel if open to prevent overlay issues
        if (appState.activeDocId && window.closeDocPanel) {
            await window.closeDocPanel();
        }
        
        appState.currentSpreadsheet = spreadsheet;
        
        const panel = document.getElementById('spreadsheetPanel');
        const tasksSection = document.getElementById('tasks-section');
        if (!panel || !tasksSection) return;

        // Determine if this is a leads table
        const isLeadsTable = spreadsheet.type === 'leads';
        const firstCol = isLeadsTable ? 'leadName' : 'title';
        
        // Ensure first column is present and columns are valid
        if (!spreadsheet.columns) {
            // Set default columns based on table type
            if (isLeadsTable) {
                spreadsheet.columns = ['leadName', 'status', 'source', 'value', 'contact', 'createdAt', 'notes'];
            } else {
                spreadsheet.columns = ['title', 'status', 'assignee', 'priority', 'dueDate', 'progress'];
            }
        } else {
            // Ensure first column is present
            if (!spreadsheet.columns.includes(firstCol)) {
                spreadsheet.columns.unshift(firstCol);
            }
            // Remove duplicate columns
            spreadsheet.columns = [...new Set(spreadsheet.columns)];
            // For leads tables, filter out task-only columns that don't apply
            if (isLeadsTable) {
                const validLeadsCols = ['leadName', 'status', 'source', 'value', 'contact', 'createdAt', 'notes'];
                spreadsheet.columns = spreadsheet.columns.filter(col => 
                    validLeadsCols.includes(col) || col.startsWith('custom_')
                );
            }
        }

        // Reset state
        spreadsheetState.selectedTasks.clear();
        spreadsheetState.searchQuery = '';
        spreadsheetState.filters = { status: '', priority: '', assignee: '' };
        updateBatchActionsBar();

        // Set title and icon
        const titleInput = panel.querySelector('.spreadsheet-title-input');
        const iconPreview = document.getElementById('spreadsheetIconPreview');
        if (titleInput) {
            titleInput.value = spreadsheet.name;
        }
        if (iconPreview) {
            // Validate icon class - must be a valid FontAwesome class
            const iconClass = (spreadsheet.icon || 'fa-table').replace(/[^a-zA-Z0-9-]/g, '');
            iconPreview.innerHTML = `<i class="fas ${iconClass}"></i>`;
            iconPreview.style.background = `${spreadsheet.color}15`;
            iconPreview.style.color = spreadsheet.color;
        }

        // Populate column toggles
        populateColumnToggles(spreadsheet);
        
        // Populate filter assignee dropdown
        populateFilterAssigneeDropdown();

        // Clear search
        const searchInput = document.getElementById('spreadsheetSearch');
        if (searchInput) searchInput.value = '';

        // Render the table
        renderSpreadsheetTable(spreadsheet);

        // Show panel by adding class to tasks section (hides cards, shows panel)
        tasksSection.classList.add('spreadsheet-open');
    }

    // Close spreadsheet panel
    window.closeSpreadsheetPanel = function() {
        const tasksSection = document.getElementById('tasks-section');
        if (tasksSection) {
            tasksSection.classList.remove('spreadsheet-open');
            appState.currentSpreadsheet = null;
            spreadsheetState.selectedTasks.clear();
        }
    };

    // ===================================
    // COLUMN TOGGLES
    // ===================================
    // COLUMN TOGGLES - With Drag Reorder
    // Toggle switch + drag handle for reordering
    // ===================================
    function populateColumnToggles(spreadsheet) {
        // Built-in columns based on spreadsheet type
        // For tasks: excludes 'title' (always shown)
        // For leads: excludes 'leadName' (always shown)
        const isLeadsTable = spreadsheet?.type === 'leads';
        
        const taskColumns = [
            { id: 'status', label: 'Status' },
            { id: 'assignee', label: 'Assignee' },
            { id: 'priority', label: 'Priority' },
            { id: 'dueDate', label: 'Due Date' },
            { id: 'progress', label: 'Progress' },
            { id: 'budget', label: 'Budget' },
            { id: 'estimatedTime', label: 'Est. Time' }
        ];
        
        const leadsColumns = [
            { id: 'status', label: 'Status' },
            { id: 'source', label: 'Source' },
            { id: 'value', label: 'Value' },
            { id: 'contact', label: 'Contact' },
            { id: 'createdAt', label: 'Created' },
            { id: 'notes', label: 'Notes' }
        ];
        
        const allColumns = isLeadsTable ? leadsColumns : taskColumns;

        const container = document.getElementById('columnToggles');
        if (!container) return;

        container.innerHTML = '';
        
        // Close any existing context menu
        document.querySelectorAll('.column-context-menu').forEach(m => m.remove());
        
        // Sort columns: active ones first in their saved order, then inactive
        const sortedColumns = [...allColumns].sort((a, b) => {
            const aIndex = spreadsheet.columns.indexOf(a.id);
            const bIndex = spreadsheet.columns.indexOf(b.id);
            if (aIndex === -1 && bIndex === -1) return 0;
            if (aIndex === -1) return 1;
            if (bIndex === -1) return -1;
            return aIndex - bIndex;
        });

        let draggedItem = null;
        let isDragging = false;

        // Helper function to create column item with improved drag handling
        function createColumnItem(col, isCustom = false) {
            const colId = col.id;
            const colLabel = isCustom ? col.name : col.label;
            const isActive = spreadsheet.columns.includes(colId);
            
            const item = document.createElement('div');
            item.className = `column-toggle-item ${isActive ? 'active' : ''} ${isCustom ? 'custom-column' : ''}`;
            item.dataset.columnId = colId;
            item.dataset.isCustom = isCustom ? 'true' : 'false';
            
            // Clean minimal design: drag handle, toggle, label
            item.innerHTML = `
                <div class="column-drag-handle" draggable="true"><i class="fas fa-grip-vertical"></i></div>
                <span class="column-toggle-switch"></span>
                <span class="column-toggle-label">${escapeHtml(colLabel)}</span>
                <input type="checkbox" ${isActive ? 'checked' : ''} data-column="${colId}">
            `;
            
            // Right-click context menu for custom columns
            if (isCustom) {
                item.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showColumnContextMenu(e, colId, colLabel, spreadsheet);
                });
            }

            const dragHandle = item.querySelector('.column-drag-handle');
            const toggleSwitch = item.querySelector('.column-toggle-switch');

            // Toggle switch click - separate from drag
            toggleSwitch.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                if (isDragging) return; // Don't toggle if dragging
                
                // Permission check for column visibility toggle
                if (appState.currentTeamData && !isAdmin(appState.currentTeamData)) {
                    showToast('Only team owners and admins can modify columns', 'error');
                    return;
                }
                
                const checkbox = item.querySelector('input');
                checkbox.checked = !checkbox.checked;
                
                if (checkbox.checked) {
                    if (!spreadsheet.columns.includes(colId)) {
                        spreadsheet.columns.push(colId);
                    }
                    item.classList.add('active');
                } else {
                    spreadsheet.columns = spreadsheet.columns.filter(c => c !== colId);
                    item.classList.remove('active');
                }
                
                saveSpreadsheetToFirestore(spreadsheet);
                renderSpreadsheetTable(spreadsheet);
            });
            
            // Also allow clicking the label to toggle
            item.querySelector('.column-toggle-label').addEventListener('click', (e) => {
                if (isDragging) return;
                toggleSwitch.click();
            });

            // Drag events - only on drag handle
            dragHandle.addEventListener('dragstart', (e) => {
                // Permission check for drag reorder
                if (appState.currentTeamData && !isAdmin(appState.currentTeamData)) {
                    e.preventDefault();
                    showToast('Only team owners and admins can reorder columns', 'error');
                    return;
                }
                
                isDragging = true;
                draggedItem = item;
                item.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', colId);
            });

            dragHandle.addEventListener('dragend', () => {
                isDragging = false;
                item.classList.remove('dragging');
                container.querySelectorAll('.column-toggle-item').forEach(el => {
                    el.classList.remove('drag-over', 'drag-over-top', 'drag-over-bottom');
                });
                draggedItem = null;
            });

            // Drop zone events on the item itself
            item.addEventListener('dragover', (e) => {
                e.preventDefault();
                if (draggedItem && draggedItem !== item) {
                    const rect = item.getBoundingClientRect();
                    const midY = rect.top + rect.height / 2;
                    item.classList.remove('drag-over-top', 'drag-over-bottom');
                    if (e.clientY < midY) {
                        item.classList.add('drag-over-top');
                    } else {
                        item.classList.add('drag-over-bottom');
                    }
                }
            });

            item.addEventListener('dragleave', (e) => {
                if (!item.contains(e.relatedTarget)) {
                    item.classList.remove('drag-over', 'drag-over-top', 'drag-over-bottom');
                }
            });

            item.addEventListener('drop', (e) => {
                e.preventDefault();
                const insertBefore = item.classList.contains('drag-over-top');
                item.classList.remove('drag-over', 'drag-over-top', 'drag-over-bottom');
                
                if (draggedItem && draggedItem !== item) {
                    const draggedId = draggedItem.dataset.columnId;
                    const targetId = item.dataset.columnId;
                    
                    // Determine first column based on spreadsheet type
                    const isLeadsTable = spreadsheet?.type === 'leads';
                    const firstCol = isLeadsTable ? 'leadName' : 'title';
                    
                    // Can't reorder the first column
                    if (draggedId === firstCol) return;
                    
                    // Perform DOM move first for immediate visual feedback
                    if (insertBefore) {
                        container.insertBefore(draggedItem, item);
                    } else {
                        container.insertBefore(draggedItem, item.nextSibling);
                    }
                    
                    // Now read the new order from DOM
                    const allItems = Array.from(container.querySelectorAll('.column-toggle-item'));
                    const newColumnOrder = [];
                    
                    // Always include first column at the beginning
                    if (spreadsheet.columns.includes(firstCol)) {
                        newColumnOrder.push(firstCol);
                    }
                    
                    // Add columns in their new DOM order (only if they were active)
                    allItems.forEach(el => {
                        const id = el.dataset.columnId;
                        if (spreadsheet.columns.includes(id) && id !== firstCol) {
                            newColumnOrder.push(id);
                        }
                    });
                    
                    // Update spreadsheet columns
                    spreadsheet.columns = newColumnOrder;
                    saveSpreadsheetToFirestore(spreadsheet);
                    renderSpreadsheetTable(spreadsheet);
                }
            });

            return item;
        }

        // Create built-in column items
        sortedColumns.forEach(col => {
            container.appendChild(createColumnItem(col, false));
        });
        
        // Also render custom columns
        if (spreadsheet.customColumns && spreadsheet.customColumns.length > 0) {
            // Sort custom columns by their position in spreadsheet.columns
            const sortedCustom = [...spreadsheet.customColumns].sort((a, b) => {
                const aIndex = spreadsheet.columns.indexOf(a.id);
                const bIndex = spreadsheet.columns.indexOf(b.id);
                if (aIndex === -1 && bIndex === -1) return 0;
                if (aIndex === -1) return 1;
                if (bIndex === -1) return -1;
                return aIndex - bIndex;
            });
            
            sortedCustom.forEach(customCol => {
                container.appendChild(createColumnItem(customCol, true));
            });
        }
    }
    
    // Show context menu for custom columns (right-click or menu button)
    function showColumnContextMenu(e, columnId, columnName, spreadsheet) {
        // Close any existing menu
        document.querySelectorAll('.column-context-menu').forEach(m => m.remove());
        
        // Permission check
        if (appState.currentTeamData && !isAdmin(appState.currentTeamData)) {
            showToast('Only team owners and admins can modify columns', 'error');
            return;
        }
        
        const menu = document.createElement('div');
        menu.className = 'column-context-menu';
        menu.innerHTML = `
            <div class="column-context-menu-item edit-column" data-column-id="${columnId}">
                <i class="fas fa-pen"></i>
                <span>Edit Column</span>
            </div>
            <div class="column-context-menu-divider"></div>
            <div class="column-context-menu-item danger delete-column" data-column-id="${columnId}">
                <i class="fas fa-trash"></i>
                <span>Delete Column</span>
            </div>
        `;
        
        // Position menu
        const x = e.clientX || e.pageX;
        const y = e.clientY || e.pageY;
        menu.style.left = x + 'px';
        menu.style.top = y + 'px';
        
        document.body.appendChild(menu);
        
        // Adjust if off screen
        const rect = menu.getBoundingClientRect();
        if (rect.right > window.innerWidth) {
            menu.style.left = (window.innerWidth - rect.width - 10) + 'px';
        }
        if (rect.bottom > window.innerHeight) {
            menu.style.top = (window.innerHeight - rect.height - 10) + 'px';
        }
        
        // Edit column handler
        menu.querySelector('.edit-column').addEventListener('click', () => {
            menu.remove();
            if (window.openColumnEditModal) {
                window.openColumnEditModal(columnId, false);
            }
        });
        
        // Delete column handler
        menu.querySelector('.delete-column').addEventListener('click', async () => {
            menu.remove();
            
            // Confirm deletion
            const confirmed = await showConfirmModal(`Delete column "${columnName}"? This will remove the column and all its data from tasks.`, {
                title: 'Delete Column',
                confirmText: 'Delete',
                type: 'danger'
            });
            if (!confirmed) return;
            
            try {
                // Remove from customColumns array
                if (spreadsheet.customColumns) {
                    spreadsheet.customColumns = spreadsheet.customColumns.filter(c => c.id !== columnId);
                }
                
                // Remove from active columns
                spreadsheet.columns = spreadsheet.columns.filter(c => c !== columnId);
                
                // Remove custom field data from all tasks
                appState.tasks.forEach(task => {
                    if (task.customFields && task.customFields[columnId] !== undefined) {
                        delete task.customFields[columnId];
                    }
                });
                
                // Save to Firestore
                await saveSpreadsheetToFirestore(spreadsheet);
                
                // Re-render
                populateColumnToggles(spreadsheet);
                renderSpreadsheetTable(spreadsheet);
                
                showToast(`Column "${columnName}" deleted`, 'success');
            } catch (error) {
                console.error('Error deleting column:', error);
                showToast('Failed to delete column', 'error');
            }
        });
        
        // Close menu on outside click
        setTimeout(() => {
            document.addEventListener('click', function closeMenu(e) {
                if (!menu.contains(e.target)) {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                }
            });
        }, 10);
    }

    // ===================================
    // CUSTOM COLUMN MODAL
    // Create and manage custom columns with color support
    // ===================================
    
    // Track editing state for column modal
    let editingColumnId = null; // null = create mode, string = edit mode
    let editingColumnIsBuiltIn = false;
    
    function initCustomColumnModal() {
        console.log('ðŸ”§ initCustomColumnModal called');
        const addColumnBtn = document.getElementById('addColumnBtn');
        const modal = document.getElementById('customColumnModal');
        const closeBtn = document.getElementById('closeCustomColumnModal');
        const cancelBtn = document.getElementById('cancelCustomColumn');
        const createBtn = document.getElementById('createCustomColumn');
        const nameInput = document.getElementById('customColumnName');
        const nameError = document.getElementById('columnNameError');
        const typeSelector = document.getElementById('inputTypeSelector');
        const dropdownGroup = document.getElementById('dropdownOptionsGroup');
        const sliderGroup = document.getElementById('sliderConfigGroup');
        const addOptionBtn = document.getElementById('addDropdownOption');
        const addRangeBtn = document.getElementById('addColorRange');
        const iconPicker = document.getElementById('iconPicker');
        const optionsList = document.getElementById('dropdownOptionsList');
        const colorRangesList = document.getElementById('sliderColorRanges');
        
        console.log('ðŸ”§ addColumnBtn:', addColumnBtn);
        console.log('ðŸ”§ modal:', modal);

        let selectedType = 'dropdown';
        let selectedIcon = 'fa-tag';

        // Open modal for creating new column
        if (addColumnBtn) {
            console.log('ðŸ”§ Adding click listener to addColumnBtn');
            addColumnBtn.addEventListener('click', () => {
                console.log('ðŸ”§ Add column button clicked!');
                
                // Check role-based permissions - only owner/admin can add columns
                if (appState.currentTeamData && !isAdmin(appState.currentTeamData)) {
                    showToast('Only team owners and admins can add columns', 'error');
                    return;
                }
                
                editingColumnId = null;
                editingColumnIsBuiltIn = false;
                resetCustomColumnModal();
                updateModalTitle('Create Column');
                openModal('customColumnModal');
            });
        } else {
            console.warn('âš ï¸ addColumnBtn not found!');
        }

        // Close modal
        if (closeBtn) closeBtn.addEventListener('click', () => closeModal('customColumnModal'));
        if (cancelBtn) cancelBtn.addEventListener('click', () => closeModal('customColumnModal'));

        // Delete column button handler
        const deleteColumnBtn = document.getElementById('deleteColumnBtn');
        if (deleteColumnBtn) {
            deleteColumnBtn.addEventListener('click', async () => {
                // Only protect the primary identifier columns (title for tasks, leadName for leads)
                const protectedColumns = ['title', 'leadName'];
                if (!editingColumnId || protectedColumns.includes(editingColumnId)) {
                    showToast('Cannot delete the primary identifier column', 'error');
                    return;
                }
                
                // Check permissions
                if (appState.currentTeamData && !isAdmin(appState.currentTeamData)) {
                    showToast('Only team owners and admins can delete columns', 'error');
                    return;
                }
                
                const columnName = nameInput?.value || editingColumnId;
                
                // Show confirmation
                const confirmed = await showConfirmModal(
                    `Are you sure you want to delete the column "${columnName}"? This will permanently remove the column and all its data from tasks. This action cannot be undone.`, 
                    {
                        title: 'Delete Column',
                        confirmText: 'Delete Permanently',
                        type: 'danger'
                    }
                );
                
                if (!confirmed) return;
                
                try {
                    const spreadsheet = appState.currentSpreadsheet;
                    if (!spreadsheet) {
                        showToast('No spreadsheet selected', 'error');
                        return;
                    }
                    
                    const isCustomColumn = editingColumnId.startsWith('custom_');
                    
                    if (isCustomColumn) {
                        // Remove from customColumns array
                        if (spreadsheet.customColumns) {
                            spreadsheet.customColumns = spreadsheet.customColumns.filter(c => c.id !== editingColumnId);
                        }
                        
                        // Remove custom field data from all tasks
                        appState.tasks.forEach(task => {
                            if (task.customFields && task.customFields[editingColumnId] !== undefined) {
                                delete task.customFields[editingColumnId];
                            }
                        });
                    } else {
                        // For built-in columns, remove any custom settings
                        if (spreadsheet.columnSettings && spreadsheet.columnSettings[editingColumnId]) {
                            delete spreadsheet.columnSettings[editingColumnId];
                        }
                        
                        // Clear field data from tasks for this built-in column
                        appState.tasks.forEach(task => {
                            if (task[editingColumnId] !== undefined) {
                                delete task[editingColumnId];
                            }
                        });
                    }
                    
                    // Remove from active columns
                    spreadsheet.columns = spreadsheet.columns.filter(c => c !== editingColumnId);
                    
                    // Save to Firestore
                    await saveSpreadsheetToFirestore(spreadsheet);
                    
                    // Update currentSpreadsheet to ensure state is in sync
                    appState.currentSpreadsheet = spreadsheet;
                    
                    // Re-render sidebar and table
                    populateColumnToggles(spreadsheet);
                    renderSpreadsheetTable(spreadsheet);
                    
                    closeModal('customColumnModal');
                    showToast(`Column "${columnName}" deleted permanently`, 'success');
                } catch (error) {
                    console.error('Error deleting column:', error);
                    showToast('Failed to delete column', 'error');
                }
            });
        }

        // Type selector - supports both old and new class names
        if (typeSelector) {
            typeSelector.querySelectorAll('.type-option, .unified-segmented-option').forEach(btn => {
                btn.addEventListener('click', () => {
                    // Don't allow type change for assignee column (its options are teammates)
                    if (editingColumnIsBuiltIn && editingColumnId === 'assignee') return;
                    
                    typeSelector.querySelectorAll('.type-option, .unified-segmented-option').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    selectedType = btn.dataset.type;

                    // Show/hide type-specific options (but not for assignee)
                    if (editingColumnId !== 'assignee') {
                        if (dropdownGroup) dropdownGroup.style.display = selectedType === 'dropdown' ? 'flex' : 'none';
                        if (sliderGroup) sliderGroup.style.display = selectedType === 'slider' ? 'flex' : 'none';
                    }
                });
            });
        }

        // Icon picker - supports both old and new class names
        if (iconPicker) {
            iconPicker.querySelectorAll('.icon-option, .unified-icon-option').forEach(btn => {
                btn.addEventListener('click', () => {
                    iconPicker.querySelectorAll('.icon-option, .unified-icon-option').forEach(b => b.classList.remove('active', 'selected'));
                    btn.classList.add('active');
                    btn.classList.add('selected');
                    selectedIcon = btn.dataset.icon;
                });
            });
        }

        // Add dropdown option with color picker
        if (addOptionBtn) {
            addOptionBtn.addEventListener('click', () => {
                addDropdownOptionInput();
            });
        }
        
        // Add color range for slider
        if (addRangeBtn) {
            addRangeBtn.addEventListener('click', () => {
                addColorRangeInput();
            });
        }

        // Delegated click handler for color swatches and remove buttons
        if (optionsList) {
            optionsList.addEventListener('click', (e) => {
                // Remove option button
                if (e.target.closest('.remove-option-btn')) {
                    const item = e.target.closest('.dropdown-option-item');
                    if (optionsList.children.length > 1) {
                        item.remove();
                    }
                }
                // Color swatch click
                if (e.target.closest('.color-swatch')) {
                    const swatch = e.target.closest('.color-swatch');
                    const picker = swatch.closest('.option-color-picker');
                    picker.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                    swatch.classList.add('active');
                }
            });
        }
        
        // Delegated click handler for color ranges
        if (colorRangesList) {
            colorRangesList.addEventListener('click', (e) => {
                // Remove range button
                if (e.target.closest('.remove-range-btn')) {
                    const item = e.target.closest('.color-range-item');
                    if (colorRangesList.children.length > 1) {
                        item.remove();
                    }
                }
                // Color swatch click
                if (e.target.closest('.color-swatch')) {
                    const swatch = e.target.closest('.color-swatch');
                    const picker = swatch.closest('.range-color-picker');
                    picker.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                    swatch.classList.add('active');
                }
            });
        }

        // Create/Update column button
        if (createBtn) {
            createBtn.addEventListener('click', async () => {
                // Double-check permissions before saving
                if (appState.currentTeamData && !isAdmin(appState.currentTeamData)) {
                    showToast('Only team owners and admins can modify columns', 'error');
                    closeModal('customColumnModal');
                    return;
                }
                
                const name = nameInput.value.trim();
                
                // Validate
                if (!name) {
                    nameError.textContent = 'Please enter a column name';
                    nameInput.focus();
                    return;
                }
                nameError.textContent = '';

                // Get dropdown options with colors if applicable
                let options = [];
                if (selectedType === 'dropdown') {
                    const items = optionsList.querySelectorAll('.dropdown-option-item');
                    items.forEach(item => {
                        const input = item.querySelector('.dropdown-option-input');
                        const activeSwatch = item.querySelector('.color-swatch.active');
                        const val = input.value.trim();
                        if (val) {
                            options.push({
                                label: val,
                                color: activeSwatch?.dataset.color || '#9CA3AF'
                            });
                        }
                    });
                    if (options.length < 1) {
                        showToast('Please add at least one dropdown option', 'warning');
                        return;
                    }
                }

                // Get slider config with color ranges if applicable
                let sliderMin = 0, sliderMax = 100, colorRanges = [];
                if (selectedType === 'slider') {
                    sliderMin = parseInt(document.getElementById('sliderMin').value) || 0;
                    sliderMax = parseInt(document.getElementById('sliderMax').value) || 100;
                    if (sliderMax <= sliderMin) {
                        showToast('Max must be greater than Min', 'warning');
                        return;
                    }
                    
                    // Get color ranges
                    const rangeItems = colorRangesList.querySelectorAll('.color-range-item');
                    rangeItems.forEach(item => {
                        const minInput = item.querySelector('.range-min-input');
                        const maxInput = item.querySelector('.range-max-input');
                        const activeSwatch = item.querySelector('.color-swatch.active');
                        colorRanges.push({
                            min: parseInt(minInput.value) || 0,
                            max: parseInt(maxInput.value) || 100,
                            color: activeSwatch?.dataset.color || '#9CA3AF'
                        });
                    });
                }

                // Update existing column or create new
                if (editingColumnId) {
                    // EDIT MODE
                    if (editingColumnIsBuiltIn) {
                        // Built-in column: update all customizable properties (stored in spreadsheet.columnSettings)
                        if (!appState.currentSpreadsheet.columnSettings) {
                            appState.currentSpreadsheet.columnSettings = {};
                        }
                        
                        const settings = {
                            label: name,
                            icon: selectedIcon,
                            type: selectedType
                        };
                        
                        // Add type-specific settings (not for assignee - its options are teammates)
                        if (editingColumnId !== 'assignee') {
                            if (selectedType === 'dropdown') {
                                settings.options = options;
                            } else if (selectedType === 'slider') {
                                settings.min = sliderMin;
                                settings.max = sliderMax;
                                settings.colorRanges = colorRanges;
                            }
                        }
                        
                        appState.currentSpreadsheet.columnSettings[editingColumnId] = settings;
                    } else {
                        // Custom column: update all properties including type change
                        const customCol = appState.currentSpreadsheet.customColumns?.find(c => c.id === editingColumnId);
                        if (customCol) {
                            customCol.name = name;
                            customCol.icon = selectedIcon;
                            customCol.type = selectedType;
                            
                            // Clear old type-specific data and set new
                            customCol.options = selectedType === 'dropdown' ? options : null;
                            customCol.min = selectedType === 'slider' ? sliderMin : null;
                            customCol.max = selectedType === 'slider' ? sliderMax : null;
                            customCol.colorRanges = selectedType === 'slider' ? colorRanges : null;
                        }
                    }
                    
                    await saveSpreadsheetToFirestore(appState.currentSpreadsheet);
                    populateColumnToggles(appState.currentSpreadsheet);
                    renderSpreadsheetTable(appState.currentSpreadsheet);
                    showToast(`Column "${name}" updated`, 'success');
                } else {
                    // CREATE MODE
                    const customColumn = {
                        id: 'custom_' + Date.now(),
                        name: name,
                        type: selectedType,
                        icon: selectedIcon,
                        options: selectedType === 'dropdown' ? options : null,
                        min: selectedType === 'slider' ? sliderMin : null,
                        max: selectedType === 'slider' ? sliderMax : null,
                        colorRanges: selectedType === 'slider' ? colorRanges : null,
                        createdAt: Date.now()
                    };

                    // Add to current spreadsheet
                    if (appState.currentSpreadsheet) {
                        if (!appState.currentSpreadsheet.customColumns) {
                            appState.currentSpreadsheet.customColumns = [];
                        }
                        appState.currentSpreadsheet.customColumns.push(customColumn);
                        
                        // Add to active columns
                        appState.currentSpreadsheet.columns.push(customColumn.id);

                        await saveSpreadsheetToFirestore(appState.currentSpreadsheet);
                        populateColumnToggles(appState.currentSpreadsheet);
                        renderSpreadsheetTable(appState.currentSpreadsheet);
                        showToast(`Column "${name}" created`, 'success');
                    }
                }
                
                closeModal('customColumnModal');
            });
        }
        
        // Update modal title
        function updateModalTitle(title) {
            const headerH2 = modal?.querySelector('.modal-header h2') || modal?.querySelector('.unified-modal-title h2');
            if (headerH2) {
                headerH2.innerHTML = `<i class="fas fa-columns"></i> ${title}`;
            }
            // Update button text
            if (createBtn) {
                createBtn.innerHTML = editingColumnId 
                    ? '<i class="fas fa-check"></i> Save' 
                    : '<i class="fas fa-plus"></i> Create';
            }
            
            // Show/hide delete button (only in edit mode, hide for protected columns)
            const deleteBtn = document.getElementById('deleteColumnBtn');
            const protectedColumns = ['title', 'leadName'];
            if (deleteBtn) {
                deleteBtn.style.display = (editingColumnId && !protectedColumns.includes(editingColumnId)) ? 'inline-flex' : 'none';
            }
        }

        // Reset modal to defaults (for create mode)
        function resetCustomColumnModal() {
            if (nameInput) nameInput.value = '';
            if (nameError) nameError.textContent = '';
            
            // Hide delete button in create mode
            const deleteBtn = document.getElementById('deleteColumnBtn');
            if (deleteBtn) deleteBtn.style.display = 'none';
            
            // Enable type selector
            if (typeSelector) {
                typeSelector.style.opacity = '1';
                typeSelector.style.pointerEvents = 'auto';
            }
            
            // Reset type selector - supports both old and new class names
            selectedType = 'dropdown';
            if (typeSelector) {
                typeSelector.querySelectorAll('.type-option, .unified-segmented-option').forEach(b => b.classList.remove('active'));
                typeSelector.querySelector('[data-type="dropdown"]')?.classList.add('active');
            }
            if (dropdownGroup) dropdownGroup.style.display = 'flex';
            if (sliderGroup) sliderGroup.style.display = 'none';

            // Reset dropdown options with color pickers
            if (optionsList) {
                optionsList.innerHTML = createDropdownOptionHTML(1) + createDropdownOptionHTML(2);
            }
            
            // Reset slider color ranges
            if (colorRangesList) {
                colorRangesList.innerHTML = `
                    ${createColorRangeHTML(0, 33, '#9CA3AF')}
                    ${createColorRangeHTML(34, 66, '#EAB308')}
                    ${createColorRangeHTML(67, 100, '#22C55E')}
                `;
            }

            // Reset slider config
            const sliderMinInput = document.getElementById('sliderMin');
            const sliderMaxInput = document.getElementById('sliderMax');
            if (sliderMinInput) sliderMinInput.value = '0';
            if (sliderMaxInput) sliderMaxInput.value = '100';

            // Reset icon picker - supports both old and new class names
            selectedIcon = 'fa-tag';
            if (iconPicker) {
                iconPicker.querySelectorAll('.icon-option, .unified-icon-option').forEach(b => b.classList.remove('active', 'selected'));
                const tagIcon = iconPicker.querySelector('[data-icon="fa-tag"]');
                if (tagIcon) {
                    tagIcon.classList.add('active');
                    tagIcon.classList.add('selected');
                }
            }
        }
        
        // Create dropdown option HTML with color picker
        function createDropdownOptionHTML(num, label = '', color = '#9CA3AF') {
            const colors = ['#9CA3AF', '#3B82F6', '#22C55E', '#EAB308', '#F97316', '#EF4444', '#A855F7'];
            return `
                <div class="dropdown-option-item">
                    <input type="text" class="dropdown-option-input" placeholder="Option ${num}" maxlength="25" value="${escapeHtml(label)}">
                    <div class="option-color-picker">
                        ${colors.map(c => `<button type="button" class="color-swatch ${c === color ? 'active' : ''}" data-color="${c}" style="background: ${c}" title="${getColorName(c)}"></button>`).join('')}
                    </div>
                    <button type="button" class="remove-option-btn" title="Remove">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `;
        }
        
        // Create color range HTML for slider
        function createColorRangeHTML(min, max, color = '#9CA3AF') {
            const colors = ['#9CA3AF', '#3B82F6', '#22C55E', '#EAB308', '#F97316', '#EF4444', '#A855F7'];
            return `
                <div class="color-range-item">
                    <input type="number" class="range-min-input" value="${min}" min="0" placeholder="Min">
                    <span class="range-separator">â€“</span>
                    <input type="number" class="range-max-input" value="${max}" placeholder="Max">
                    <div class="range-color-picker">
                        ${colors.map(c => `<button type="button" class="color-swatch ${c === color ? 'active' : ''}" data-color="${c}" style="background: ${c}" title="${getColorName(c)}"></button>`).join('')}
                    </div>
                    <button type="button" class="remove-range-btn" title="Remove range">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `;
        }
        
        // Get color name from hex
        function getColorName(hex) {
            const names = {
                '#9CA3AF': 'Grey', '#3B82F6': 'Blue', '#22C55E': 'Green',
                '#EAB308': 'Yellow', '#F97316': 'Orange', '#EF4444': 'Red', '#A855F7': 'Purple'
            };
            return names[hex] || 'Color';
        }

        function addDropdownOptionInput() {
            const count = optionsList.children.length + 1;
            optionsList.insertAdjacentHTML('beforeend', createDropdownOptionHTML(count));
            optionsList.lastElementChild.querySelector('input').focus();
        }
        
        function addColorRangeInput() {
            const lastRange = colorRangesList.lastElementChild;
            const lastMax = lastRange ? parseInt(lastRange.querySelector('.range-max-input').value) || 0 : 0;
            colorRangesList.insertAdjacentHTML('beforeend', createColorRangeHTML(lastMax + 1, lastMax + 33));
        }
        
        // Expose function to open modal in edit mode (called when clicking column header)
        window.openColumnEditModal = function(columnId, isBuiltIn = false) {
            // Block editing of 'title' and 'leadName' columns entirely (first column)
            if (columnId === 'title') {
                showToast('The Task column cannot be edited', 'info');
                return;
            }
            if (columnId === 'leadName') {
                showToast('The Lead column cannot be edited', 'info');
                return;
            }
            
            // Check role-based permissions - only owner/admin can edit columns
            if (appState.currentTeamData && !isAdmin(appState.currentTeamData)) {
                showToast('Only team owners and admins can edit columns', 'error');
                return;
            }
            
            editingColumnId = columnId;
            editingColumnIsBuiltIn = isBuiltIn;
            
            // Built-in column definitions with default options
            // Includes both Task columns and Lead columns
            const builtInColumns = {
                // === TASK COLUMNS ===
                'title': { label: 'Title', icon: 'fa-heading', type: 'text' },
                'status': { 
                    label: 'Status', icon: 'fa-circle-notch', type: 'dropdown',
                    defaultOptions: appState.currentSpreadsheet?.type === 'leads' 
                        ? [
                            { label: 'New', color: '#007AFF' },
                            { label: 'Contacted', color: '#5856D6' },
                            { label: 'Qualified', color: '#FF9500' },
                            { label: 'Won', color: '#34C759' },
                            { label: 'Lost', color: '#FF3B30' }
                        ]
                        : [
                            { label: 'To Do', color: '#9CA3AF' },
                            { label: 'In Progress', color: '#3B82F6' },
                            { label: 'Review', color: '#EAB308' },
                            { label: 'Done', color: '#22C55E' }
                        ]
                },
                'assignee': { label: 'Assignee', icon: 'fa-user', type: 'dropdown' },
                'priority': { 
                    label: 'Priority', icon: 'fa-flag', type: 'dropdown',
                    defaultOptions: [
                        { label: 'Low', color: '#22C55E' },
                        { label: 'Medium', color: '#EAB308' },
                        { label: 'High', color: '#F97316' },
                        { label: 'Critical', color: '#EF4444' }
                    ]
                },
                'dueDate': { label: 'Due Date', icon: 'fa-calendar', type: 'date' },
                'progress': { 
                    label: 'Progress', icon: 'fa-chart-line', type: 'slider',
                    defaultColorRanges: [
                        { min: 0, max: 33, color: '#EF4444' },
                        { min: 34, max: 66, color: '#EAB308' },
                        { min: 67, max: 100, color: '#22C55E' }
                    ]
                },
                'budget': { label: 'Budget', icon: 'fa-dollar-sign', type: 'number' },
                'estimatedTime': { label: 'Est. Time', icon: 'fa-clock', type: 'number' },
                
                // === LEAD COLUMNS ===
                'leadName': { label: 'Lead Name', icon: 'fa-user', type: 'text' },
                'source': { 
                    label: 'Source', icon: 'fa-globe', type: 'dropdown',
                    defaultOptions: [
                        { label: 'Website', color: '#007AFF' },
                        { label: 'Referral', color: '#34C759' },
                        { label: 'Ad Campaign', color: '#FF9500' },
                        { label: 'Social Media', color: '#5856D6' },
                        { label: 'Other', color: '#8E8E93' }
                    ]
                },
                'value': { label: 'Value', icon: 'fa-dollar-sign', type: 'number' },
                'contact': { label: 'Contact', icon: 'fa-phone', type: 'text' },
                'createdAt': { label: 'Created', icon: 'fa-calendar-plus', type: 'date' },
                'notes': { label: 'Notes', icon: 'fa-sticky-note', type: 'text' }
            };
            
            if (isBuiltIn) {
                const colDef = builtInColumns[columnId];
                if (!colDef) return;
                
                const customSettings = appState.currentSpreadsheet?.columnSettings?.[columnId] || {};
                
                // Populate form with built-in column data (using custom settings if available)
                if (nameInput) nameInput.value = customSettings.label || colDef.label;
                selectedIcon = customSettings.icon || colDef.icon;
                selectedType = customSettings.type || colDef.type;
                
                // Select icon
                if (iconPicker) {
                    iconPicker.querySelectorAll('.icon-option').forEach(b => b.classList.remove('active'));
                    iconPicker.querySelector(`[data-icon="${selectedIcon}"]`)?.classList.add('active');
                }
                
                // For assignee column - disable type selector (it must stay as dropdown with teammate options)
                if (columnId === 'assignee') {
                    if (typeSelector) {
                        typeSelector.style.opacity = '0.5';
                        typeSelector.style.pointerEvents = 'none';
                        typeSelector.querySelectorAll('.type-option').forEach(b => b.classList.remove('active'));
                        typeSelector.querySelector(`[data-type="dropdown"]`)?.classList.add('active');
                    }
                    if (dropdownGroup) dropdownGroup.style.display = 'none';
                    if (sliderGroup) sliderGroup.style.display = 'none';
                } else {
                    // Enable type selector for other built-in columns (they can change type now)
                    if (typeSelector) {
                        typeSelector.style.opacity = '1';
                        typeSelector.style.pointerEvents = 'auto';
                        typeSelector.querySelectorAll('.type-option').forEach(b => b.classList.remove('active'));
                        typeSelector.querySelector(`[data-type="${selectedType}"]`)?.classList.add('active');
                    }
                    
                    // Show type-specific options based on current type
                    if (dropdownGroup) dropdownGroup.style.display = selectedType === 'dropdown' ? 'flex' : 'none';
                    if (sliderGroup) sliderGroup.style.display = selectedType === 'slider' ? 'flex' : 'none';
                    
                    // Populate dropdown options with colors
                    if (selectedType === 'dropdown' && optionsList) {
                        optionsList.innerHTML = '';
                        // Always prioritize saved options from columnSettings over defaults
                        const opts = customSettings.options || colDef.defaultOptions || [];
                        if (opts.length > 0) {
                            opts.forEach((opt, i) => {
                                const label = typeof opt === 'string' ? opt : opt.label;
                                const color = typeof opt === 'string' ? '#9CA3AF' : (opt.color || '#9CA3AF');
                                optionsList.insertAdjacentHTML('beforeend', createDropdownOptionHTML(i + 1, label, color));
                            });
                        } else {
                            // Only show default empty options if no saved options exist
                            optionsList.innerHTML = createDropdownOptionHTML(1) + createDropdownOptionHTML(2);
                        }
                    }
                    
                    // Populate slider config with color ranges
                    if (selectedType === 'slider') {
                        const sliderMinInput = document.getElementById('sliderMin');
                        const sliderMaxInput = document.getElementById('sliderMax');
                        if (sliderMinInput) sliderMinInput.value = customSettings.min || 0;
                        if (sliderMaxInput) sliderMaxInput.value = customSettings.max || 100;
                        
                        if (colorRangesList) {
                            colorRangesList.innerHTML = '';
                            const ranges = customSettings.colorRanges || colDef.defaultColorRanges || [
                                { min: 0, max: 33, color: '#9CA3AF' },
                                { min: 34, max: 66, color: '#EAB308' },
                                { min: 67, max: 100, color: '#22C55E' }
                            ];
                            ranges.forEach(r => {
                                colorRangesList.insertAdjacentHTML('beforeend', createColorRangeHTML(r.min, r.max, r.color));
                            });
                        }
                    }
                }
                
            } else {
                // Custom column editing
                const customCol = appState.currentSpreadsheet?.customColumns?.find(c => c.id === columnId);
                if (!customCol) return;
                
                if (nameInput) nameInput.value = customCol.name;
                selectedType = customCol.type;
                selectedIcon = customCol.icon;
                
                // Enable type selector for custom columns (allow type changes)
                if (typeSelector) {
                    typeSelector.style.opacity = '1';
                    typeSelector.style.pointerEvents = 'auto';
                    typeSelector.querySelectorAll('.type-option').forEach(b => b.classList.remove('active'));
                    typeSelector.querySelector(`[data-type="${selectedType}"]`)?.classList.add('active');
                }
                
                // Select icon
                if (iconPicker) {
                    iconPicker.querySelectorAll('.icon-option').forEach(b => b.classList.remove('active'));
                    iconPicker.querySelector(`[data-icon="${selectedIcon}"]`)?.classList.add('active');
                }
                
                // Show type-specific options
                if (dropdownGroup) dropdownGroup.style.display = selectedType === 'dropdown' ? 'flex' : 'none';
                if (sliderGroup) sliderGroup.style.display = selectedType === 'slider' ? 'flex' : 'none';
                
                // Populate dropdown options with colors
                if (selectedType === 'dropdown' && optionsList) {
                    optionsList.innerHTML = '';
                    const opts = customCol.options || [];
                    opts.forEach((opt, i) => {
                        // Handle both old format (string) and new format (object with label/color)
                        const label = typeof opt === 'string' ? opt : opt.label;
                        const color = typeof opt === 'string' ? '#9CA3AF' : (opt.color || '#9CA3AF');
                        optionsList.insertAdjacentHTML('beforeend', createDropdownOptionHTML(i + 1, label, color));
                    });
                    if (opts.length === 0) {
                        optionsList.innerHTML = createDropdownOptionHTML(1) + createDropdownOptionHTML(2);
                    }
                }
                
                // Populate slider config with color ranges
                if (selectedType === 'slider') {
                    const sliderMinInput = document.getElementById('sliderMin');
                    const sliderMaxInput = document.getElementById('sliderMax');
                    if (sliderMinInput) sliderMinInput.value = customCol.min || 0;
                    if (sliderMaxInput) sliderMaxInput.value = customCol.max || 100;
                    
                    if (colorRangesList) {
                        colorRangesList.innerHTML = '';
                        const ranges = customCol.colorRanges || [
                            { min: 0, max: 33, color: '#9CA3AF' },
                            { min: 34, max: 66, color: '#EAB308' },
                            { min: 67, max: 100, color: '#22C55E' }
                        ];
                        ranges.forEach(r => {
                            colorRangesList.insertAdjacentHTML('beforeend', createColorRangeHTML(r.min, r.max, r.color));
                        });
                    }
                }
            }
            
            updateModalTitle('Edit Column');
            openModal('customColumnModal');
        };
    }

    // ===================================
    // SPREADSHEET TABLE RENDERING
    // =================================== 
    // ===================================
    // OPTIMIZED TABLE RENDERING
    // Uses DocumentFragment and batch DOM operations for speed
    // ===================================
    function renderSpreadsheetTable(spreadsheet) {
        const tableContainer = document.getElementById('tableContainer');
        if (!tableContainer) return;

        // Get filtered and sorted tasks for this spreadsheet
        const tasks = getFilteredAndSortedTasks();
        
        // Get all tasks for this spreadsheet (without search/filter applied)
        const spreadsheetTasks = getTasksForSpreadsheet(spreadsheet);
        
        // Determine if this is a leads table
        const isLeadsTable = spreadsheet.type === 'leads';
        const itemName = isLeadsTable ? 'lead' : 'task';
        const itemNamePlural = isLeadsTable ? 'leads' : 'tasks';

        if (tasks.length === 0 && spreadsheetTasks.length === 0) {
            tableContainer.innerHTML = `
                <div class="spreadsheet-empty-wrapper">
                    <button class="add-row-btn empty-state-add-btn" onclick="openAddItemModal()">
                        <i class="fas fa-plus"></i> Add new ${isLeadsTable ? 'lead' : 'task'}
                    </button>
                    <div class="spreadsheet-empty">
                        <i class="fas fa-${isLeadsTable ? 'user-plus' : 'clipboard-list'}"></i>
                        <h4>No ${itemNamePlural} yet</h4>
                        <p>Create your first ${itemName} to get started</p>
                    </div>
                </div>
            `;
            return;
        }

        if (tasks.length === 0) {
            tableContainer.innerHTML = `
                <div class="spreadsheet-empty">
                    <i class="fas fa-search"></i>
                    <h4>No matching ${itemNamePlural}</h4>
                    <p>Try adjusting your search or filters</p>
                    <button class="btn-secondary empty-state-btn" onclick="clearFilters()">
                        <i class="fas fa-times"></i> Clear Filters
                    </button>
                </div>
            `;
            return;
        }

        // Deduplicate and set default columns
        let visibleColumns = spreadsheet.columns;
        if (!visibleColumns || visibleColumns.length === 0) {
            visibleColumns = isLeadsTable 
                ? ['leadName', 'status', 'source', 'value', 'contact', 'createdAt', 'notes']
                : ['title', 'status', 'assignee', 'priority', 'dueDate'];
        } else {
            visibleColumns = [...new Set(visibleColumns)];
        }
        const firstColHeader = isLeadsTable ? 'Lead' : 'Task';
        
        // Pre-compute column metadata once
        const columnMeta = visibleColumns.map(col => ({
            id: col,
            isCustom: col.startsWith('custom_'),
            icon: getColumnIcon(col, spreadsheet),
            label: getColumnLabel(col, spreadsheet),
            isFirstCol: col === 'title' || col === 'leadName'
        }));

        // Build header row efficiently
        const headerCells = columnMeta.map(meta => {
            const clickableClass = meta.isFirstCol ? '' : 'column-header-clickable';
            return `<th title="${meta.label}" class="${clickableClass}" data-column-id="${meta.id}" data-is-custom="${meta.isCustom}">
                ${meta.isFirstCol ? firstColHeader : `<i class="fas ${meta.icon} column-header-icon"></i>`}
            </th>`;
        }).join('');
        
        // Build all rows in a single pass using array join (faster than string concatenation)
        const rowsHTML = tasks.map(task => {
            const isCompleted = task.status === 'done';
            const cells = visibleColumns.map(col => renderTableCell(task, col, spreadsheet)).join('');
            return `<tr class="${isCompleted ? 'row-completed' : ''}" data-task-id="${task.id}">
                ${cells}
                <td>
                    <div class="row-actions">
                        <button class="row-action-btn" onclick="editTask(appState.tasks.find(t => t.id === '${task.id}'))" data-tooltip="Edit">
                            <i class="fas fa-pen"></i>
                        </button>
                        <button class="row-action-btn delete" onclick="deleteTask('${task.id}', event)" data-tooltip="Delete">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </td>
            </tr>`;
        }).join('');

        // Single DOM write
        tableContainer.innerHTML = `
            <table class="spreadsheet-table">
                <thead><tr>${headerCells}<th title="Actions"><i class="fas fa-ellipsis-h"></i></th></tr></thead>
                <tbody>${rowsHTML}</tbody>
            </table>
            <button class="add-row-btn" onclick="openAddItemModal()">
                <i class="fas fa-plus"></i> Add new ${isLeadsTable ? 'lead' : 'task'}
            </button>
        `;

        // Defer event listener initialization to next frame
        requestAnimationFrame(() => initTableEventListeners(spreadsheet));
    }

    // Initialize table event listeners
    function initTableEventListeners(spreadsheet) {
        const tableContainer = document.getElementById('tableContainer');
        if (!tableContainer) return;
        
        // ===================================
        // COLUMN HEADER CLICK TO EDIT
        // Click on column header icon to open edit popup
        // ===================================
        tableContainer.querySelectorAll('.column-header-clickable').forEach(header => {
            header.addEventListener('click', (e) => {
                e.stopPropagation();
                const columnId = header.dataset.columnId;
                const isCustom = header.dataset.isCustom === 'true';
                // Open column edit modal
                if (window.openColumnEditModal) {
                    window.openColumnEditModal(columnId, !isCustom);
                }
            });
        });
        
        // ===================================
        // INLINE EDITING IMPLEMENTATION PLAN:
        // 1. Title: Click cell â†’ text input, Enter/blur saves
        // 2. Due Date: Click cell â†’ date picker, change saves  
        // 3. Budget: Click cell â†’ number input with $, blur saves
        // 4. Est. Time: Click cell â†’ number input, blur saves
        // 5. Progress: Existing drag-to-edit functionality
        // 6. Priority/Assignee: Existing dropdown functionality
        // ===================================
        
        // Initialize inline text editing (title, budget, est time, date)
        initInlineTextEditing(tableContainer);
        
        // ===================================
        // INLINE EDITING: Progress Bar Drag
        // ===================================
        initInlineProgressEditing(tableContainer);
        
        // ===================================
        // INLINE EDITING: Priority Dropdown
        // ===================================
        initInlinePriorityEditing(tableContainer);
        
        // ===================================
        // INLINE EDITING: Assignee Dropdown
        // ===================================
        initInlineAssigneeEditing(tableContainer);
        
        // ===================================
        // INLINE EDITING: Custom Columns
        // ===================================
        initCustomColumnEditing(tableContainer, spreadsheet);
        
        // ===================================
        // INLINE EDITING: Built-in Dropdowns (Status/Priority with custom settings)
        // ===================================
        initBuiltInDropdownEditing(tableContainer, spreadsheet);
    }
    
    // ===================================
    // BUILT-IN DROPDOWN EDITING (Status/Priority with columnSettings)
    // Handles .custom-dropdown-cell.built-in-dropdown cells
    // ===================================
    function initBuiltInDropdownEditing(container, spreadsheet) {
        container.querySelectorAll('.custom-dropdown-cell.built-in-dropdown').forEach(cell => {
            cell.addEventListener('click', (e) => {
                e.stopPropagation();
                const taskId = cell.dataset.taskId;
                const columnId = cell.dataset.columnId; // 'status' or 'priority'
                const task = appState.tasks.find(t => t.id === taskId);
                if (!task) return;
                
                closeAllInlineDropdowns();
                showBuiltInDropdown(cell, task, columnId, spreadsheet);
            });
        });
    }
    
    function showBuiltInDropdown(cell, task, columnId, spreadsheet) {
        const dropdown = document.createElement('div');
        dropdown.className = 'inline-edit-dropdown built-in-col-dropdown';
        
        // Get settings from spreadsheet columnSettings
        const settings = spreadsheet?.columnSettings?.[columnId];
        const options = settings?.options || [];
        
        // Get current value based on column type
        let currentValue = '';
        if (columnId === 'status') {
            // For leads, status is stored as-is (New, Contacted, etc.)
            // For tasks, status uses codes (todo, inprogress, done)
            const taskStatusMap = { todo: 'To Do', inprogress: 'In Progress', done: 'Done' };
            currentValue = taskStatusMap[task.status] || task.status;
        } else if (columnId === 'priority') {
            currentValue = (task.priority || 'medium').charAt(0).toUpperCase() + (task.priority || 'medium').slice(1);
        } else if (columnId === 'source') {
            currentValue = task.source || '';
        }
        
        // Build options HTML
        let optionsHTML = '';
        options.forEach(opt => {
            const label = typeof opt === 'string' ? opt : opt.label;
            const color = typeof opt === 'string' ? '#9CA3AF' : (opt.color || '#9CA3AF');
            const isActive = currentValue === label;
            optionsHTML += `
                <div class="inline-dropdown-option ${isActive ? 'active' : ''}" data-value="${escapeHtml(label)}" data-color="${color}">
                    <span class="option-color-dot" style="background: ${color}"></span>
                    <span>${escapeHtml(label)}</span>
                    ${isActive ? '<i class="fas fa-check"></i>' : ''}
                </div>
            `;
        });
        
        dropdown.innerHTML = optionsHTML;
        
        positionInlineDropdown(dropdown, cell);
        
        // Append to spreadsheet container for proper scrolling
        const spreadsheetContainer = document.querySelector('.spreadsheet-table-area') || document.body;
        spreadsheetContainer.appendChild(dropdown);
        
        requestAnimationFrame(() => dropdown.classList.add('visible'));
        
        dropdown.querySelectorAll('.inline-dropdown-option').forEach(option => {
            option.addEventListener('click', async () => {
                const newValue = option.dataset.value;
                const newColor = option.dataset.color || '#9CA3AF';
                await updateBuiltInDropdownValue(task, columnId, newValue, newColor, cell);
                closeAllInlineDropdowns();
            });
        });
        
        setTimeout(() => {
            document.addEventListener('click', closeDropdownOnOutsideClick);
        }, 10);
    }
    
    async function updateBuiltInDropdownValue(task, columnId, newDisplayValue, newColor, cell) {
        // Convert display value to internal value
        let newValue = newDisplayValue;
        if (columnId === 'status') {
            // Check if this is a task status (has mapping) or lead status (store as-is)
            const statusMap = { 'To Do': 'todo', 'In Progress': 'inprogress', 'Done': 'done' };
            // Only use map if the display value is a task status
            if (statusMap[newDisplayValue]) {
                newValue = statusMap[newDisplayValue];
            } else {
                // For leads or custom statuses, store as-is
                newValue = newDisplayValue;
            }
        } else if (columnId === 'priority') {
            newValue = newDisplayValue.toLowerCase();
        } else if (columnId === 'source') {
            // For source, store as-is
            newValue = newDisplayValue;
        }
        
        const oldValue = task[columnId];
        if (oldValue === newValue) return;
        
        // Update local state
        task[columnId] = newValue;
        
        // Update cell visual with colored pill
        const pillSpan = cell.querySelector('.custom-dropdown-pill');
        if (pillSpan) {
            pillSpan.style.background = `${newColor}20`;
            pillSpan.style.color = newColor;
            const dotSpan = pillSpan.querySelector('.pill-dot');
            if (dotSpan) dotSpan.style.background = newColor;
            pillSpan.childNodes.forEach(node => {
                if (node.nodeType === Node.TEXT_NODE || (node.nodeType === Node.ELEMENT_NODE && !node.classList.contains('pill-dot'))) {
                    if (node.nodeType === Node.TEXT_NODE) {
                        node.textContent = newDisplayValue;
                    }
                }
            });
            // Find and update text content
            const textContent = Array.from(pillSpan.childNodes).find(n => n.nodeType === Node.TEXT_NODE);
            if (textContent) {
                textContent.textContent = '\n                                ' + newDisplayValue + '\n                            ';
            } else {
                // Rebuild pill inner content
                pillSpan.innerHTML = `<span class="pill-dot" style="background: ${newColor}"></span>${escapeHtml(newDisplayValue)}`;
            }
        }
        
        // Show save feedback
        showInlineSaveFeedback(cell.closest('td'));
        
        // Save to Firestore
        if (db && currentAuthUser && appState.currentTeamId) {
            try {
                const { doc, updateDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
                const taskRef = doc(db, 'teams', appState.currentTeamId, 'tasks', String(task.id));
                await updateDoc(taskRef, { 
                    [columnId]: newValue,
                    updatedAt: serverTimestamp()
                });
                debugLog(`âœ… Task ${columnId} updated:`, task.id, newValue);
            } catch (error) {
                console.error(`Error updating task ${columnId}:`, error);
                task[columnId] = oldValue;
            }
        }
        
        saveToLocalStorage('tasks', appState.tasks);
        
        // Update metrics if needed
        if (typeof aggregateAndRenderMetrics === 'function') {
            aggregateAndRenderMetrics();
        }
    }
    
    // ===================================
    // INLINE TEXT EDITING (Title, Date, Budget, Est. Time, Leads fields)
    // Click cell â†’ input field â†’ Enter/blur saves, Escape cancels
    // ===================================
    function initInlineTextEditing(container) {
        // Title cells (also handles leadName since both use .cell-title-editable)
        container.querySelectorAll('.cell-title-editable').forEach(cell => {
            cell.addEventListener('click', (e) => {
                e.stopPropagation();
                // Check if this is a leads spreadsheet by looking for leadName in the task
                const taskId = cell.dataset.taskId;
                const task = appState.tasks.find(t => t.id === taskId);
                const field = task?.leadName !== undefined ? 'leadName' : 'title';
                startInlineEdit(cell, field, 'text');
            });
        });
        
        // Date cells
        container.querySelectorAll('.cell-date-editable').forEach(cell => {
            cell.addEventListener('click', (e) => {
                e.stopPropagation();
                startInlineEdit(cell, 'dueDate', 'date');
            });
        });
        
        // Budget cells
        container.querySelectorAll('.cell-budget-editable').forEach(cell => {
            cell.addEventListener('click', (e) => {
                e.stopPropagation();
                startInlineEdit(cell, 'budget', 'number');
            });
        });
        
        // Est. Time cells
        container.querySelectorAll('.cell-time-editable').forEach(cell => {
            cell.addEventListener('click', (e) => {
                e.stopPropagation();
                startInlineEdit(cell, 'estimatedTime', 'number');
            });
        });
        
        // Source cells (leads)
        container.querySelectorAll('.cell-source-editable').forEach(cell => {
            cell.addEventListener('click', (e) => {
                e.stopPropagation();
                startInlineEdit(cell, 'source', 'text');
            });
        });
        
        // Value cells (leads)
        container.querySelectorAll('.cell-value-editable').forEach(cell => {
            cell.addEventListener('click', (e) => {
                e.stopPropagation();
                startInlineEdit(cell, 'value', 'currency');
            });
        });
        
        // Contact cells (leads)
        container.querySelectorAll('.cell-contact-editable').forEach(cell => {
            cell.addEventListener('click', (e) => {
                e.stopPropagation();
                startInlineEdit(cell, 'contact', 'text');
            });
        });
        
        // Notes cells (leads)
        container.querySelectorAll('.cell-notes-editable').forEach(cell => {
            cell.addEventListener('click', (e) => {
                e.stopPropagation();
                startInlineEdit(cell, 'notes', 'text');
            });
        });
    }
    
    function startInlineEdit(cell, field, inputType) {
        // Don't start if already editing
        if (cell.querySelector('.inline-edit-input')) return;
        
        const taskId = cell.dataset.taskId;
        const task = appState.tasks.find(t => t.id === taskId);
        if (!task) return;
        
        const originalValue = task[field];
        const displayValue = cell.textContent.trim();
        
        // Store original HTML for cancel
        const originalHTML = cell.innerHTML;
        
        // Create input based on type
        let input;
        if (inputType === 'date') {
            input = document.createElement('input');
            input.type = 'date';
            input.className = 'inline-edit-input inline-edit-date';
            // Format date for input
            if (originalValue) {
                const d = new Date(originalValue);
                input.value = d.toISOString().split('T')[0];
            }
        } else if (inputType === 'number') {
            input = document.createElement('input');
            input.type = 'number';
            input.className = 'inline-edit-input inline-edit-number';
            input.min = '0';
            input.step = field === 'budget' ? '0.01' : '0.5';
            input.value = originalValue || '';
            input.placeholder = field === 'budget' ? '0.00' : '0';
        } else if (inputType === 'currency') {
            // Currency input for lead value
            input = document.createElement('input');
            input.type = 'number';
            input.className = 'inline-edit-input inline-edit-currency';
            input.min = '0';
            input.step = '1';
            input.value = originalValue || '';
            input.placeholder = '0';
        } else {
            input = document.createElement('input');
            input.type = 'text';
            input.className = 'inline-edit-input inline-edit-text';
            input.value = originalValue || '';
            input.placeholder = field === 'source' ? 'e.g., Website, Referral...' : 
                               field === 'contact' ? 'Email or phone...' :
                               field === 'leadName' ? 'Lead name...' :
                               field === 'notes' ? 'Add notes...' : 'Enter value...';
            
            // Add real-time 20-word limit for title/leadName
            if (field === 'title' || field === 'leadName') {
                input.addEventListener('input', (e) => {
                    const MAX_WORDS = 20;
                    const words = e.target.value.split(/\s+/).filter(word => word.length > 0);
                    if (words.length > MAX_WORDS) {
                        e.target.value = words.slice(0, MAX_WORDS).join(' ');
                    }
                });
            }
        }
        
        // Replace cell content with input
        cell.innerHTML = '';
        cell.classList.add('editing');
        cell.appendChild(input);
        input.focus();
        input.select();
        
        // Handle save on blur
        input.addEventListener('blur', () => {
            saveInlineEdit(cell, task, field, input.value, originalValue, originalHTML);
        });
        
        // Handle Enter to save, Escape to cancel
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                input.blur();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                cancelInlineEdit(cell, originalHTML);
            }
        });
    }
    
    async function saveInlineEdit(cell, task, field, newValue, originalValue, originalHTML) {
        cell.classList.remove('editing');
        
        // Parse value based on field type
        let parsedValue = newValue;
        if (field === 'budget') {
            parsedValue = newValue ? parseFloat(newValue) : null;
            if (parsedValue !== null && parsedValue < 0) parsedValue = 0;
        } else if (field === 'estimatedTime') {
            parsedValue = newValue ? parseFloat(newValue) : null;
            if (parsedValue !== null && parsedValue < 0) parsedValue = 0;
        } else if (field === 'value') {
            // Lead value (currency)
            parsedValue = newValue ? parseFloat(newValue) : null;
            if (parsedValue !== null && parsedValue < 0) parsedValue = 0;
        } else if (field === 'dueDate') {
            parsedValue = newValue ? new Date(newValue).getTime() : null;
        } else if (field === 'title' || field === 'leadName') {
            parsedValue = newValue.trim();
            if (!parsedValue) {
                // Title/leadName is required, revert
                cancelInlineEdit(cell, originalHTML);
                return;
            }
            // 20 word limit
            const wordCount = parsedValue.split(/\s+/).filter(word => word.length > 0).length;
            if (wordCount > 20) {
                parsedValue = parsedValue.split(/\s+/).slice(0, 20).join(' ');
                showToast('Name limited to 20 words', 'warning');
            }
        } else if (field === 'source' || field === 'contact' || field === 'notes') {
            // Leads text fields
            parsedValue = newValue.trim() || null;
        }
        
        // Check if value actually changed
        if (parsedValue === originalValue || 
            (parsedValue === null && originalValue === null) ||
            (parsedValue === '' && !originalValue)) {
            // Restore original display
            cell.innerHTML = originalHTML;
            return;
        }
        
        // Update local state
        task[field] = parsedValue;
        
        // Update cell display
        updateCellDisplay(cell, task, field);
        
        // Show save feedback
        showInlineSaveFeedback(cell);
        
        // Save to Firestore
        if (db && currentAuthUser && appState.currentTeamId) {
            try {
                const { doc, updateDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
                const taskRef = doc(db, 'teams', appState.currentTeamId, 'tasks', String(task.id));
                await updateDoc(taskRef, { 
                    [field]: parsedValue,
                    updatedAt: serverTimestamp()
                });
                debugLog(`âœ… Task ${field} updated:`, task.id, parsedValue);
            } catch (error) {
                const path = `teams/${appState.currentTeamId}/tasks/${task.id}`;
                logFirestoreError(`saveInlineEdit(${field})`, path, { [field]: parsedValue }, {
                    uid: currentAuthUser?.uid,
                    teamId: appState.currentTeamId,
                    taskId: task.id,
                    taskCreatedBy: task.createdBy,
                    userRole: appState.currentTeamData?.members?.[currentAuthUser?.uid]?.role
                }, error);
                // Revert on error
                task[field] = originalValue;
                cell.innerHTML = originalHTML;
            }
        }
        
        // Update local storage
        saveToLocalStorage('tasks', appState.tasks);
    }
    
    function cancelInlineEdit(cell, originalHTML) {
        cell.classList.remove('editing');
        cell.innerHTML = originalHTML;
    }
    
    function updateCellDisplay(cell, task, field) {
        switch (field) {
            case 'title':
                cell.innerHTML = escapeHtml(task.title || '');
                break;
            case 'leadName':
                cell.innerHTML = escapeHtml(task.leadName || '');
                break;
            case 'dueDate':
                if (!task.dueDate) {
                    cell.innerHTML = 'â€”';
                    cell.className = 'cell-date-editable cell-editable date-cell';
                } else {
                    const date = new Date(task.dueDate);
                    const formatted = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const dueDate = new Date(date);
                    dueDate.setHours(0, 0, 0, 0);
                    const diff = Math.ceil((dueDate - today) / (1000 * 60 * 60 * 24));
                    let dateClass = '';
                    if (task.status !== 'done') {
                        if (diff < 0) dateClass = 'overdue';
                        else if (diff === 0) dateClass = 'today';
                    }
                    cell.innerHTML = formatted;
                    cell.className = `cell-date-editable cell-editable date-cell ${dateClass}`;
                }
                break;
            case 'budget':
                cell.innerHTML = task.budget ? '$' + parseFloat(task.budget).toFixed(2) : 'â€”';
                break;
            case 'estimatedTime':
                cell.innerHTML = task.estimatedTime ? task.estimatedTime + 'h' : 'â€”';
                break;
            case 'source':
                cell.innerHTML = escapeHtml(task.source || 'â€”');
                break;
            case 'value':
                cell.innerHTML = task.value ? '$' + parseFloat(task.value).toLocaleString() : 'â€”';
                break;
            case 'contact':
                cell.innerHTML = escapeHtml(task.contact || 'â€”');
                break;
            case 'notes':
                cell.innerHTML = escapeHtml(task.notes || 'â€”');
                break;
        }
        cell.dataset.taskId = task.id;
    }

    // ===================================
    // INLINE PROGRESS EDITING - Clean Range Input
    // Simple input[type=range] with real-time updates
    // ===================================
    function initInlineProgressEditing(container) {
        container.querySelectorAll('.progress-cell-inline').forEach(cell => {
            const taskId = cell.dataset.taskId;
            const slider = cell.querySelector('.progress-range-slider');
            const text = cell.querySelector('.progress-text');
            
            if (!slider || !taskId) return;
            
            // Update visual on input (while dragging)
            slider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                text.textContent = value + '%';
                slider.style.setProperty('--progress', value + '%');
                
                if (value === 100) {
                    slider.classList.add('complete');
                } else {
                    slider.classList.remove('complete');
                }
            });
            
            // Save on change (when released)
            slider.addEventListener('change', async (e) => {
                const newProgress = parseInt(e.target.value);
                const task = appState.tasks.find(t => t.id === taskId);
                if (!task) return;
                
                const oldProgress = task.progress || 0;
                if (oldProgress === newProgress) return;
                
                // Update local state
                task.progress = newProgress;
                
                // Auto-update status based on progress (ONLY valid status enums: todo, inprogress, done)
                let newStatus = task.status;
                if (newProgress === 100) {
                    newStatus = 'done';
                } else if (newProgress > 0 && newProgress < 100) {
                    newStatus = 'inprogress';
                }
                // Don't auto-change from 'inprogress' to 'todo' when progress goes to 0
                // User may want to keep it inprogress
                
                if (newStatus !== task.status) {
                    task.status = newStatus;
                }
                
                // Show save feedback
                showInlineSaveFeedback(cell);
                
                // Save to Firestore
                if (db && currentAuthUser && appState.currentTeamId) {
                    try {
                        const { doc, updateDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
                        const taskRef = doc(db, 'teams', appState.currentTeamId, 'tasks', String(taskId));
                        const payload = { 
                            progress: newProgress, 
                            status: newStatus,
                            updatedAt: serverTimestamp() 
                        };
                        await updateDoc(taskRef, payload);
                        debugLog('âœ… Task progress and status updated:', taskId, newProgress, newStatus);
                        
                        // Refresh the spreadsheet to show updated status badge
                        const currentSpreadsheet = appState.spreadsheets.find(s => s.id === appState.currentSpreadsheetId);
                        if (currentSpreadsheet) {
                            renderSpreadsheet(currentSpreadsheet);
                        }
                    } catch (error) {
                        const path = `teams/${appState.currentTeamId}/tasks/${taskId}`;
                        logFirestoreError('updateTaskProgress', path, { progress: newProgress, status: newStatus }, {
                            uid: currentAuthUser?.uid,
                            teamId: appState.currentTeamId,
                            taskId: taskId,
                            taskCreatedBy: task.createdBy,
                            taskAssignee: task.assignee,
                            taskAssigneeId: task.assigneeId,
                            userRole: appState.currentTeamData?.members?.[currentAuthUser?.uid]?.role
                        }, error);
                    }
                }
            });
        });
    }

    // ===================================
    // INLINE PRIORITY EDITING
    // Apple-like floating dropdown
    // ===================================
    function initInlinePriorityEditing(container) {
        container.querySelectorAll('.priority-badge-inline').forEach(badge => {
            badge.addEventListener('click', (e) => {
                e.stopPropagation();
                const taskId = badge.dataset.taskId;
                const task = appState.tasks.find(t => t.id === taskId);
                if (!task) return;
                
                // Close any existing dropdowns
                closeAllInlineDropdowns();
                
                // Create and show dropdown
                showPriorityDropdown(badge, task);
            });
        });
    }
    
    function showPriorityDropdown(badge, task) {
        const dropdown = document.createElement('div');
        dropdown.className = 'inline-edit-dropdown priority-dropdown';
        dropdown.innerHTML = `
            <div class="inline-dropdown-option ${task.priority === 'low' ? 'active' : ''}" data-value="low">
                <span class="priority-dot low"></span>
                <span>Low</span>
                ${task.priority === 'low' ? '<i class="fas fa-check"></i>' : ''}
            </div>
            <div class="inline-dropdown-option ${task.priority === 'medium' ? 'active' : ''}" data-value="medium">
                <span class="priority-dot medium"></span>
                <span>Medium</span>
                ${task.priority === 'medium' ? '<i class="fas fa-check"></i>' : ''}
            </div>
            <div class="inline-dropdown-option ${task.priority === 'high' ? 'active' : ''}" data-value="high">
                <span class="priority-dot high"></span>
                <span>High</span>
                ${task.priority === 'high' ? '<i class="fas fa-check"></i>' : ''}
            </div>
        `;
        
        // Position dropdown
        positionInlineDropdown(dropdown, badge);
        
        // Add animation class
        requestAnimationFrame(() => dropdown.classList.add('visible'));
        
        // Handle option selection
        dropdown.querySelectorAll('.inline-dropdown-option').forEach(option => {
            option.addEventListener('click', async () => {
                const newPriority = option.dataset.value;
                await updateTaskPriority(task, newPriority, badge);
                closeAllInlineDropdowns();
            });
        });
        
        // Close on outside click
        setTimeout(() => {
            document.addEventListener('click', closeDropdownOnOutsideClick);
        }, 10);
    }
    
    async function updateTaskPriority(task, newPriority, badge) {
        const oldPriority = task.priority;
        if (oldPriority === newPriority) return;
        
        // Update local state
        task.priority = newPriority;
        
        // Update badge visual
        const priorityLabel = newPriority.charAt(0).toUpperCase() + newPriority.slice(1);
        badge.className = `priority-badge priority-badge-inline ${newPriority}`;
        badge.innerHTML = priorityLabel;
        badge.dataset.taskId = task.id;
        
        // Show save feedback
        showInlineSaveFeedback(badge.closest('td'));
        
        // Save to Firestore
        if (db && currentAuthUser && appState.currentTeamId) {
            try {
                const { doc, updateDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
                const taskRef = doc(db, 'teams', appState.currentTeamId, 'tasks', String(task.id));
                await updateDoc(taskRef, { 
                    priority: newPriority,
                    updatedAt: serverTimestamp()
                });
                debugLog('âœ… Task priority updated:', task.id, newPriority);
            } catch (error) {
                const path = `teams/${appState.currentTeamId}/tasks/${task.id}`;
                logFirestoreError('updateTaskPriority', path, { priority: newPriority }, {
                    uid: currentAuthUser?.uid,
                    teamId: appState.currentTeamId,
                    taskId: task.id,
                    taskCreatedBy: task.createdBy,
                    taskAssignee: task.assignee,
                    userRole: appState.currentTeamData?.members?.[currentAuthUser?.uid]?.role
                }, error);
                task.priority = oldPriority;
            }
        }
        
        saveToLocalStorage('tasks', appState.tasks);
    }

    // ===================================
    // INLINE ASSIGNEE EDITING
    // Teammate dropdown similar to chat mentions
    // ===================================
    function initInlineAssigneeEditing(container) {
        container.querySelectorAll('.assignee-cell-inline').forEach(cell => {
            cell.addEventListener('click', (e) => {
                e.stopPropagation();
                const taskId = cell.dataset.taskId;
                const task = appState.tasks.find(t => t.id === taskId);
                if (!task) return;
                
                // Close any existing dropdowns
                closeAllInlineDropdowns();
                
                // Create and show dropdown
                showAssigneeDropdown(cell, task);
            });
        });
    }
    
    function showAssigneeDropdown(cell, task) {
        const dropdown = document.createElement('div');
        dropdown.className = 'inline-edit-dropdown assignee-dropdown';
        
        let optionsHTML = `
            <div class="inline-dropdown-option ${!task.assigneeId ? 'active' : ''}" data-value="">
                <div class="assignee-option-avatar" style="background: #8E8E93">?</div>
                <span>Unassigned</span>
                ${!task.assigneeId ? '<i class="fas fa-check"></i>' : ''}
            </div>
        `;
        
        // Add Team option with team icon
        const isTeamActive = task.assigneeId === 'team';
        optionsHTML += `
            <div class="inline-dropdown-option ${isTeamActive ? 'active' : ''}" data-value="team" data-name="Team">
                <div class="assignee-option-avatar team-avatar">
                    <i class="fas fa-users"></i>
                </div>
                <span>Team</span>
                ${isTeamActive ? '<i class="fas fa-check"></i>' : ''}
            </div>
        `;
        
        appState.teammates.forEach(member => {
            const isActive = task.assigneeId === member.id;
            // Use unified identity resolver for consistent display
            const identity = getIdentity(member.id, member.name || member.email);
            const initials = identity.initials;
            const color = identity.avatarColor;
            const displayName = identity.displayName;
            optionsHTML += `
                <div class="inline-dropdown-option ${isActive ? 'active' : ''}" data-value="${member.id}" data-name="${escapeHtml(displayName)}">
                    <div class="assignee-option-avatar" style="background: ${color}">${initials}</div>
                    <span>${escapeHtml(displayName)}</span>
                    ${isActive ? '<i class="fas fa-check"></i>' : ''}
                </div>
            `;
        });
        
        dropdown.innerHTML = optionsHTML;
        
        // Position dropdown
        positionInlineDropdown(dropdown, cell);
        
        // Add animation class
        requestAnimationFrame(() => dropdown.classList.add('visible'));
        
        // Handle option selection
        dropdown.querySelectorAll('.inline-dropdown-option').forEach(option => {
            option.addEventListener('click', async () => {
                const newAssigneeId = option.dataset.value;
                const newAssigneeName = option.dataset.name || '';
                await updateTaskAssignee(task, newAssigneeId, newAssigneeName, cell);
                closeAllInlineDropdowns();
            });
        });
        
        // Close on outside click
        setTimeout(() => {
            document.addEventListener('click', closeDropdownOnOutsideClick);
        }, 10);
    }
    
    async function updateTaskAssignee(task, newAssigneeId, newAssigneeName, cell) {
        const oldAssigneeId = task.assigneeId;
        if (oldAssigneeId === newAssigneeId) return;
        
        // Update local state
        task.assigneeId = newAssigneeId || null;
        task.assignee = newAssigneeName || 'Unassigned';
        
        // Handle Team assignee specially with team icon
        let avatarHTML;
        let fullName;
        let firstName;
        
        if (newAssigneeId === 'team') {
            fullName = 'Team';
            firstName = 'Team';
            avatarHTML = `<div class="assignee-avatar dropdown-assignee-avatar team-avatar"><i class="fas fa-users"></i></div>`;
        } else if (newAssigneeId) {
            // Update cell visual using unified identity resolver
            const identity = getIdentity(newAssigneeId, newAssigneeName);
            fullName = identity.displayName;
            firstName = fullName.split(' ')[0];
            const initials = identity.initials;
            const color = identity.avatarColor;
            avatarHTML = `<div class="assignee-avatar" style="background: ${color}">${initials}</div>`;
        } else {
            fullName = 'Unassigned';
            firstName = 'Unassigned';
            avatarHTML = `<div class="assignee-avatar" style="background: #8E8E93">?</div>`;
        }
        
        cell.innerHTML = `
            ${avatarHTML}
            <span class="assignee-name">${escapeHtml(firstName)}</span>
        `;
        cell.title = fullName;
        
        // Show save feedback
        showInlineSaveFeedback(cell.closest('td'));
        
        // Save to Firestore
        if (db && currentAuthUser && appState.currentTeamId) {
            try {
                const { doc, updateDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
                const taskRef = doc(db, 'teams', appState.currentTeamId, 'tasks', String(task.id));
                await updateDoc(taskRef, { 
                    assigneeId: newAssigneeId || null,
                    assignee: newAssigneeName || 'Unassigned',
                    updatedAt: serverTimestamp()
                });
                debugLog('âœ… Task assignee updated:', task.id, newAssigneeName);
            } catch (error) {
                const path = `teams/${appState.currentTeamId}/tasks/${task.id}`;
                logFirestoreError('updateTaskAssignee', path, { assigneeId: newAssigneeId, assignee: newAssigneeName }, {
                    uid: currentAuthUser?.uid,
                    teamId: appState.currentTeamId,
                    taskId: task.id,
                    taskCreatedBy: task.createdBy,
                    userRole: appState.currentTeamData?.members?.[currentAuthUser?.uid]?.role
                }, error);
                task.assigneeId = oldAssigneeId;
            }
        }
        
        saveToLocalStorage('tasks', appState.tasks);
    }

    // ===================================
    // INLINE EDIT HELPERS
    // ===================================
    function positionInlineDropdown(dropdown, trigger) {
        const triggerRect = trigger.getBoundingClientRect();
        
        // Append dropdown to body for proper viewport-based positioning
        // This prevents cutoff issues from container overflow
        if (dropdown.parentElement !== document.body) {
            document.body.appendChild(dropdown);
        }
        
        // Use fixed positioning relative to viewport
        dropdown.style.position = 'fixed';
        dropdown.style.zIndex = '100001';
        
        // Get viewport dimensions
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        
        // Get dropdown dimensions (render first to measure)
        dropdown.style.visibility = 'hidden';
        dropdown.style.display = 'block';
        const dropdownRect = dropdown.getBoundingClientRect();
        const dropdownHeight = dropdownRect.height || 200;
        const dropdownWidth = dropdownRect.width || 200;
        dropdown.style.visibility = '';
        
        // Default: position below the trigger
        let top = triggerRect.bottom + 4;
        let left = triggerRect.left;
        
        // Check if dropdown would go off bottom of viewport
        if (top + dropdownHeight > viewportHeight - 20) {
            // Position above the trigger instead
            top = triggerRect.top - dropdownHeight - 4;
            // If still off-screen (trigger near top), position at top of viewport
            if (top < 20) {
                top = 20;
            }
        }
        
        // Check if dropdown would go off right of viewport
        if (left + dropdownWidth > viewportWidth - 20) {
            left = viewportWidth - dropdownWidth - 20;
        }
        
        // Check if dropdown would go off left of viewport
        if (left < 20) {
            left = 20;
        }
        
        dropdown.style.top = top + 'px';
        dropdown.style.left = left + 'px';
    }
    
    function closeAllInlineDropdowns() {
        document.querySelectorAll('.inline-edit-dropdown').forEach(d => d.remove());
        document.removeEventListener('click', closeDropdownOnOutsideClick);
    }
    
    function closeDropdownOnOutsideClick(e) {
        if (!e.target.closest('.inline-edit-dropdown') && !e.target.closest('.priority-badge-inline') && !e.target.closest('.assignee-cell-inline') && !e.target.closest('.custom-dropdown-cell')) {
            closeAllInlineDropdowns();
        }
    }
    
    // ===================================
    // INLINE EDITING: Custom Columns
    // ===================================
    function initCustomColumnEditing(container, spreadsheet) {
        if (!spreadsheet?.customColumns?.length) return;
        
        // Custom Dropdown cells
        container.querySelectorAll('.custom-dropdown-cell').forEach(cell => {
            cell.addEventListener('click', (e) => {
                e.stopPropagation();
                const taskId = cell.dataset.taskId;
                const columnId = cell.dataset.columnId;
                const task = appState.tasks.find(t => t.id === taskId);
                const customCol = spreadsheet.customColumns.find(cc => cc.id === columnId);
                if (!task || !customCol) return;
                
                closeAllInlineDropdowns();
                showCustomDropdown(cell, task, customCol);
            });
        });
        
        // Custom Slider cells with color ranges
        container.querySelectorAll('.custom-slider-cell').forEach(cell => {
            const taskId = cell.dataset.taskId;
            const columnId = cell.dataset.columnId;
            const slider = cell.querySelector('.custom-slider-input');
            const valueBadge = cell.querySelector('.custom-slider-badge') || cell.querySelector('.custom-slider-value');
            
            if (!slider || !taskId || !columnId) return;
            
            const customCol = spreadsheet.customColumns.find(cc => cc.id === columnId);
            if (!customCol) return;
            
            const min = customCol.min || 0;
            const max = customCol.max || 100;
            const colorRanges = customCol.colorRanges || [];
            
            // Helper to get color for a value
            function getSliderColor(val) {
                for (const range of colorRanges) {
                    if (val >= range.min && val <= range.max) {
                        return range.color;
                    }
                }
                return '#9CA3AF';
            }
            
            slider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                valueBadge.textContent = value;
                const pct = ((value - min) / (max - min)) * 100;
                slider.style.setProperty('--progress', pct + '%');
                
                // Update color based on ranges
                const color = getSliderColor(value);
                slider.style.setProperty('--slider-color', color);
                valueBadge.style.background = color;
            });
            
            slider.addEventListener('change', async (e) => {
                const newValue = parseInt(e.target.value);
                const task = appState.tasks.find(t => t.id === taskId);
                if (!task) return;
                
                if (!task.customFields) task.customFields = {};
                task.customFields[columnId] = newValue;
                
                showInlineSaveFeedback(cell.closest('td'));
                
                await saveCustomFieldValue(taskId, columnId, newValue);
            });
        });
        
        // Custom Number cells
        container.querySelectorAll('.custom-number-input').forEach(input => {
            const taskId = input.dataset.taskId;
            const columnId = input.dataset.columnId;
            if (!taskId || !columnId) return;
            
            input.addEventListener('blur', async () => {
                const task = appState.tasks.find(t => t.id === taskId);
                if (!task) return;
                
                const newValue = input.value ? parseFloat(input.value) : null;
                if (!task.customFields) task.customFields = {};
                
                if (task.customFields[columnId] === newValue) return;
                
                task.customFields[columnId] = newValue;
                showInlineSaveFeedback(input.closest('td'));
                await saveCustomFieldValue(taskId, columnId, newValue);
            });
            
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    input.blur();
                }
            });
        });
        
        // Custom Text cells - click to edit
        container.querySelectorAll('.custom-text-cell').forEach(cell => {
            const taskId = cell.dataset.taskId;
            const columnId = cell.dataset.columnId;
            if (!taskId || !columnId) return;
            
            cell.addEventListener('click', (e) => {
                e.stopPropagation();
                if (cell.querySelector('.custom-text-input')) return; // Already editing
                
                const task = appState.tasks.find(t => t.id === taskId);
                if (!task) return;
                
                const currentValue = task.customFields?.[columnId] || '';
                const valueSpan = cell.querySelector('.custom-text-value');
                
                // Create input
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'custom-text-input';
                input.value = currentValue;
                input.placeholder = 'Enter text...';
                
                // Replace value span with input
                if (valueSpan) valueSpan.style.display = 'none';
                cell.appendChild(input);
                input.focus();
                input.select();
                
                // Save on blur
                input.addEventListener('blur', async () => {
                    const newValue = input.value.trim();
                    if (!task.customFields) task.customFields = {};
                    
                    task.customFields[columnId] = newValue || null;
                    
                    // Update display
                    if (valueSpan) {
                        valueSpan.innerHTML = newValue ? escapeHtml(newValue) : '<span class="text-placeholder">â€”</span>';
                        valueSpan.style.display = '';
                    }
                    input.remove();
                    
                    showInlineSaveFeedback(cell.closest('td'));
                    await saveCustomFieldValue(taskId, columnId, newValue || null);
                });
                
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        input.blur();
                    } else if (e.key === 'Escape') {
                        if (valueSpan) valueSpan.style.display = '';
                        input.remove();
                    }
                });
            });
        });
        
        // Custom Link cells - click to edit
        container.querySelectorAll('.custom-link-cell').forEach(cell => {
            const taskId = cell.dataset.taskId;
            const columnId = cell.dataset.columnId;
            if (!taskId || !columnId) return;
            
            // Click on empty cell or edit button to edit link
            const handleEditLink = (e) => {
                e.stopPropagation();
                e.preventDefault();
                
                const task = appState.tasks.find(t => t.id === taskId);
                if (!task) return;
                
                const currentUrl = task.customFields?.[columnId] || '';
                showLinkInputPopup(cell, task, columnId, currentUrl);
            };
            
            // Empty cell click
            if (cell.classList.contains('empty')) {
                cell.addEventListener('click', handleEditLink);
            }
            
            // Edit button click
            const editBtn = cell.querySelector('.link-edit-btn');
            if (editBtn) {
                editBtn.addEventListener('click', handleEditLink);
            }
        });
    }
    
    // Show link input popup for editing URLs
    function showLinkInputPopup(cell, task, columnId, currentUrl) {
        // Close any existing popup
        document.querySelectorAll('.link-input-popup').forEach(p => p.remove());
        
        const popup = document.createElement('div');
        popup.className = 'link-input-popup';
        popup.innerHTML = `
            <input type="url" placeholder="https://example.com" value="${escapeHtml(currentUrl)}">
            <div class="link-input-actions">
                <button class="link-cancel-btn">Cancel</button>
                <button class="link-save-btn">Save</button>
            </div>
        `;
        
        // Position popup
        const rect = cell.getBoundingClientRect();
        popup.style.position = 'fixed';
        popup.style.top = (rect.bottom + 5) + 'px';
        popup.style.left = rect.left + 'px';
        
        document.body.appendChild(popup);
        
        const input = popup.querySelector('input');
        input.focus();
        input.select();
        
        const saveLink = async () => {
            const newUrl = input.value.trim();
            if (!task.customFields) task.customFields = {};
            
            task.customFields[columnId] = newUrl || null;
            popup.remove();
            
            // Re-render the table to show updated link
            if (appState.currentSpreadsheet) {
                renderSpreadsheetTable(appState.currentSpreadsheet);
            }
            
            await saveCustomFieldValue(task.id, columnId, newUrl || null);
        };
        
        popup.querySelector('.link-save-btn').addEventListener('click', saveLink);
        popup.querySelector('.link-cancel-btn').addEventListener('click', () => popup.remove());
        
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                saveLink();
            } else if (e.key === 'Escape') {
                popup.remove();
            }
        });
        
        // Close on outside click
        setTimeout(() => {
            document.addEventListener('click', function closePopup(e) {
                if (!popup.contains(e.target) && !cell.contains(e.target)) {
                    popup.remove();
                    document.removeEventListener('click', closePopup);
                }
            });
        }, 10);
    }
    
    function showCustomDropdown(cell, task, customCol) {
        const dropdown = document.createElement('div');
        dropdown.className = 'inline-edit-dropdown custom-col-dropdown';
        
        const currentValue = task.customFields?.[customCol.id] || '';
        
        // Build options HTML with color support
        let optionsHTML = `
            <div class="inline-dropdown-option ${!currentValue ? 'active' : ''}" data-value="">
                <span>â€”</span>
                ${!currentValue ? '<i class="fas fa-check"></i>' : ''}
            </div>
        `;
        
        (customCol.options || []).forEach(opt => {
            // Support both old string format and new object format with colors
            const label = typeof opt === 'string' ? opt : opt.label;
            const color = typeof opt === 'string' ? '#9CA3AF' : (opt.color || '#9CA3AF');
            const isActive = currentValue === label;
            optionsHTML += `
                <div class="inline-dropdown-option ${isActive ? 'active' : ''}" data-value="${escapeHtml(label)}" data-color="${color}">
                    <span class="option-color-dot" style="background: ${color}"></span>
                    <span>${escapeHtml(label)}</span>
                    ${isActive ? '<i class="fas fa-check"></i>' : ''}
                </div>
            `;
        });
        
        dropdown.innerHTML = optionsHTML;
        
        positionInlineDropdown(dropdown, cell);
        
        requestAnimationFrame(() => dropdown.classList.add('visible'));
        
        dropdown.querySelectorAll('.inline-dropdown-option').forEach(option => {
            option.addEventListener('click', async () => {
                const newValue = option.dataset.value || null;
                const newColor = option.dataset.color || '#9CA3AF';
                await updateCustomDropdownValue(task, customCol.id, newValue, newColor, cell, customCol);
                closeAllInlineDropdowns();
            });
        });
        
        setTimeout(() => {
            document.addEventListener('click', closeDropdownOnOutsideClick);
        }, 10);
    }
    
    async function updateCustomDropdownValue(task, columnId, newValue, newColor, cell, customCol) {
        if (!task.customFields) task.customFields = {};
        
        const oldValue = task.customFields[columnId];
        if (oldValue === newValue) return;
        
        task.customFields[columnId] = newValue;
        
        // Update cell visual with colored pill
        const dropdownCell = cell.querySelector('.custom-dropdown-cell') || cell;
        if (newValue) {
            // Find color from options if not provided
            let color = newColor || '#9CA3AF';
            if (customCol && customCol.options) {
                const opt = customCol.options.find(o => 
                    (typeof o === 'string' ? o : o.label) === newValue
                );
                if (opt && typeof opt === 'object') {
                    color = opt.color || color;
                }
            }
            
            // Replace content with colored pill
            const existingPill = dropdownCell.querySelector('.custom-dropdown-pill');
            const existingValue = dropdownCell.querySelector('.custom-dropdown-value');
            
            const pillHTML = `<span class="custom-dropdown-pill" style="background: ${color}20; color: ${color}">
                <span class="pill-dot" style="background: ${color}"></span>
                ${escapeHtml(newValue)}
            </span>`;
            
            if (existingPill) {
                existingPill.outerHTML = pillHTML;
            } else if (existingValue) {
                existingValue.outerHTML = pillHTML;
            }
        } else {
            // Empty value - show placeholder
            const existingPill = dropdownCell.querySelector('.custom-dropdown-pill');
            if (existingPill) {
                existingPill.outerHTML = `<span class="custom-dropdown-value">â€”</span>`;
            } else {
                const existingValue = dropdownCell.querySelector('.custom-dropdown-value');
                if (existingValue) existingValue.textContent = 'â€”';
            }
        }
        
        showInlineSaveFeedback(cell.closest('td'));
        
        await saveCustomFieldValue(task.id, columnId, newValue);
    }
    
    async function saveCustomFieldValue(taskId, columnId, value) {
        if (db && currentAuthUser && appState.currentTeamId) {
            try {
                const { doc, updateDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
                const taskRef = doc(db, 'teams', appState.currentTeamId, 'tasks', String(taskId));
                await updateDoc(taskRef, { 
                    [`customFields.${columnId}`]: value 
                });
                debugLog('âœ… Custom field updated:', taskId, columnId, value);
            } catch (error) {
                console.error('Error updating custom field:', error);
            }
        }
        
        saveToLocalStorage('tasks', appState.tasks);
    }

    function showInlineSaveFeedback(cell) {
        if (!cell) return;
        
        // Add saved indicator
        const indicator = document.createElement('span');
        indicator.className = 'inline-save-indicator';
        indicator.innerHTML = '<i class="fas fa-check"></i>';
        cell.style.position = 'relative';
        cell.appendChild(indicator);
        
        // Animate and remove
        requestAnimationFrame(() => {
            indicator.classList.add('visible');
            setTimeout(() => {
                indicator.classList.remove('visible');
                setTimeout(() => indicator.remove(), 200);
            }, 800);
        });
    }

    // Update row selection visuals
    function updateRowSelections() {
        const tableContainer = document.getElementById('tableContainer');
        if (!tableContainer) return;

        tableContainer.querySelectorAll('[data-task-checkbox]').forEach(cb => {
            const taskId = cb.dataset.taskCheckbox;
            const isSelected = spreadsheetState.selectedTasks.has(taskId);
            cb.checked = isSelected;
            cb.closest('tr').classList.toggle('selected', isSelected);
        });
    }

    // Update batch actions bar visibility
    function updateBatchActionsBar() {
        const bar = document.getElementById('batchActionsBar');
        const countEl = document.getElementById('selectedCount');
        const labelEl = document.getElementById('selectedItemsLabel');
        if (!bar || !countEl) return;

        const count = spreadsheetState.selectedTasks.size;
        countEl.textContent = count;
        
        // Update label based on spreadsheet type
        if (labelEl) {
            const isLeads = appState.currentSpreadsheet?.type === 'leads';
            labelEl.textContent = isLeads ? 'leads' : 'tasks';
        }
        
        bar.classList.toggle('active', count > 0);
    }

    // Helper: get tasks for a specific spreadsheet
    function getTasksForSpreadsheet(spreadsheet) {
        if (!spreadsheet || spreadsheet.id === 'default') {
            // "All Tasks" shows all tasks EXCEPT leads (leads have different presets)
            // SECURITY: Also filter out tasks from private/admins-only spreadsheets the user can't access
            // Get all spreadsheet IDs that are of type 'leads'
            const leadsSpreadsheetIds = (appState.spreadsheets || [])
                .filter(s => s.type === 'leads')
                .map(s => s.id);
            
            // Get current user's role for permission checks
            const currentUserRole = appState.currentTeamData?.members?.[currentAuthUser?.uid]?.role || 'member';
            const isAdminOrOwner = currentUserRole === 'admin' || currentUserRole === 'owner';
            
            // Filter out tasks that:
            // 1. Belong to leads spreadsheets
            // 2. Belong to private spreadsheets not created by current user
            // 3. Belong to admins-only spreadsheets if user is not admin/owner
            return appState.tasks.filter(t => {
                // Exclude leads
                if (leadsSpreadsheetIds.includes(t.spreadsheetId)) return false;
                
                // Find the spreadsheet this task belongs to
                const taskSpreadsheet = appState.spreadsheets.find(s => s.id === t.spreadsheetId);
                if (!taskSpreadsheet) return true; // If spreadsheet not found, show task (legacy tasks)
                
                // Check visibility
                const visibility = taskSpreadsheet.visibility || 'team';
                
                // Private: only show if current user is creator
                if (visibility === 'private') {
                    return taskSpreadsheet.createdBy === currentAuthUser?.uid;
                }
                
                // Admins: only show if user is admin/owner or creator
                if (visibility === 'admins') {
                    return isAdminOrOwner || taskSpreadsheet.createdBy === currentAuthUser?.uid;
                }
                
                // Team: show to everyone
                return true;
            });
        }
        // Other spreadsheets only show tasks assigned to them
        return appState.tasks.filter(t => t.spreadsheetId === spreadsheet.id);
    }

    // Get filtered and sorted tasks for the current spreadsheet
    function getFilteredAndSortedTasks() {
        // Start with tasks for current spreadsheet
        let tasks = getTasksForSpreadsheet(appState.currentSpreadsheet);

        // Apply search
        if (spreadsheetState.searchQuery) {
            const query = spreadsheetState.searchQuery.toLowerCase();
            tasks = tasks.filter(t => 
                t.title.toLowerCase().includes(query) ||
                (t.description && t.description.toLowerCase().includes(query)) ||
                (t.assignee && t.assignee.toLowerCase().includes(query))
            );
        }

        // Apply filters
        if (spreadsheetState.filters.status) {
            tasks = tasks.filter(t => t.status === spreadsheetState.filters.status);
        }
        if (spreadsheetState.filters.priority) {
            tasks = tasks.filter(t => t.priority === spreadsheetState.filters.priority);
        }
        if (spreadsheetState.filters.assignee) {
            tasks = tasks.filter(t => t.assigneeId === spreadsheetState.filters.assignee);
        }

        // Hide completed tasks by default (unless showCompleted is true)
        // Completed = status === 'done' OR status === 'won' (for leads)
        if (!spreadsheetState.showCompleted) {
            tasks = tasks.filter(t => t.status !== 'done' && t.status !== 'won');
        }

        // Sort: completed tasks at the bottom, active tasks sorted by due date
        tasks.sort((a, b) => {
            const aCompleted = a.status === 'done' || a.status === 'won';
            const bCompleted = b.status === 'done' || b.status === 'won';
            
            // If both completed or both active, sort by due date
            if (aCompleted === bCompleted) {
                const aVal = a.dueDate || Infinity;
                const bVal = b.dueDate || Infinity;
                return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
            }
            
            // Active tasks come before completed tasks
            return aCompleted ? 1 : -1;
        });

        return tasks;
    }

    // Render individual table cell
    // Updated for FULL inline editing support (all fields)
    function renderTableCell(task, column, spreadsheet) {
        // Check if this is a custom column
        if (column.startsWith('custom_')) {
            const customCol = (spreadsheet?.customColumns || []).find(cc => cc.id === column);
            if (!customCol) return `<td>â€”</td>`;
            
            const value = task.customFields?.[column];
            
            switch (customCol.type) {
                case 'dropdown':
                    // Find the option with color (supports both old string format and new object format)
                    const displayValue = value || 'â€”';
                    let optionColor = '#9CA3AF'; // default grey
                    if (value && customCol.options) {
                        const option = customCol.options.find(opt => 
                            (typeof opt === 'string' ? opt : opt.label) === value
                        );
                        if (option && typeof option === 'object') {
                            optionColor = option.color || '#9CA3AF';
                        }
                    }
                    // Render colored pill with dot indicator
                    const hasValue = value && value !== 'â€”';
                    return `<td class="cell-editable">
                        <div class="custom-dropdown-cell" data-task-id="${task.id}" data-column-id="${column}">
                            ${hasValue 
                                ? `<span class="custom-dropdown-pill" style="background: ${optionColor}20; color: ${optionColor}">
                                    <span class="pill-dot" style="background: ${optionColor}"></span>
                                    ${escapeHtml(displayValue)}
                                   </span>`
                                : `<span class="custom-dropdown-value">${escapeHtml(displayValue)}</span>`
                            }
                            <i class="fas fa-chevron-down custom-dropdown-icon"></i>
                        </div>
                    </td>`;
                
                case 'slider':
                    const sliderValue = value !== undefined ? value : customCol.min || 0;
                    const min = customCol.min || 0;
                    const max = customCol.max || 100;
                    const pct = ((sliderValue - min) / (max - min)) * 100;
                    
                    // Find color based on ranges
                    let sliderColor = '#9CA3AF'; // default grey
                    if (customCol.colorRanges && customCol.colorRanges.length > 0) {
                        for (const range of customCol.colorRanges) {
                            if (sliderValue >= range.min && sliderValue <= range.max) {
                                sliderColor = range.color;
                                break;
                            }
                        }
                    }
                    
                    return `<td class="cell-editable">
                        <div class="custom-slider-cell" data-task-id="${task.id}" data-column-id="${column}" data-color-ranges='${JSON.stringify(customCol.colorRanges || [])}'>
                            <input type="range" class="progress-range-slider custom-slider-input" min="${min}" max="${max}" value="${sliderValue}" style="--progress: ${pct}%; --slider-color: ${sliderColor}">
                            <span class="custom-slider-badge" style="background: ${sliderColor}">${sliderValue}</span>
                        </div>
                    </td>`;
                
                case 'number':
                    const numValue = value !== undefined ? value : '';
                    return `<td class="cell-editable">
                        <input type="number" class="custom-number-input" data-task-id="${task.id}" data-column-id="${column}" value="${numValue}" placeholder="â€”">
                    </td>`;
                
                case 'text':
                    const textValue = value || '';
                    return `<td class="cell-editable">
                        <div class="custom-text-cell" data-task-id="${task.id}" data-column-id="${column}">
                            <span class="custom-text-value">${textValue ? escapeHtml(textValue) : '<span class="text-placeholder">â€”</span>'}</span>
                        </div>
                    </td>`;
                
                case 'link':
                    const linkValue = value || '';
                    if (linkValue) {
                        // Extract domain for display
                        let displayText = linkValue;
                        try {
                            const url = new URL(linkValue);
                            displayText = url.hostname.replace('www.', '');
                        } catch (e) {
                            displayText = linkValue.substring(0, 20) + (linkValue.length > 20 ? '...' : '');
                        }
                        return `<td class="cell-editable">
                            <div class="custom-link-cell" data-task-id="${task.id}" data-column-id="${column}" data-url="${escapeHtml(linkValue)}">
                                <a href="${escapeHtml(linkValue)}" target="_blank" rel="noopener noreferrer" class="custom-link-pill" onclick="event.stopPropagation()">
                                    <i class="fas fa-external-link-alt"></i>
                                    <span>${escapeHtml(displayText)}</span>
                                </a>
                                <button class="link-edit-btn" title="Edit link">
                                    <i class="fas fa-pen"></i>
                                </button>
                            </div>
                        </td>`;
                    }
                    return `<td class="cell-editable">
                        <div class="custom-link-cell empty" data-task-id="${task.id}" data-column-id="${column}">
                            <span class="link-placeholder">+ Link</span>
                        </div>
                    </td>`;
                
                default:
                    return `<td>â€”</td>`;
            }
        }
        
        switch (column) {
            case 'title':
                // INLINE EDITABLE: Click to edit title directly
                return `<td class="cell-title-editable cell-editable" data-task-id="${task.id}">${escapeHtml(task.title)}</td>`;
            
            case 'status':
                // Check for custom settings with colors
                const statusSettings = spreadsheet?.columnSettings?.status;
                if (statusSettings?.options && statusSettings.options.length > 0) {
                    // Use custom dropdown rendering with colors
                    // For leads, status is stored directly (New, Contacted, etc.)
                    // For tasks, status uses codes (todo, inprogress, done)
                    const taskStatusMap = { todo: 'To Do', inprogress: 'In Progress', done: 'Done' };
                    const statusValue = taskStatusMap[task.status] || task.status;
                    const statusOption = statusSettings.options.find(opt => opt.label === statusValue);
                    const statusColor = statusOption?.color || '#9CA3AF';
                    return `<td class="cell-editable">
                        <div class="custom-dropdown-cell built-in-dropdown" data-task-id="${task.id}" data-column-id="status">
                            <span class="custom-dropdown-pill" style="background: ${statusColor}20; color: ${statusColor}">
                                <span class="pill-dot" style="background: ${statusColor}"></span>
                                ${escapeHtml(statusValue)}
                            </span>
                            <i class="fas fa-chevron-down custom-dropdown-icon"></i>
                        </div>
                    </td>`;
                }
                // Default status rendering (task mode)
                const statusClass = task.status;
                const statusLabel = { todo: 'To Do', inprogress: 'In Progress', done: 'Done' }[task.status] || task.status;
                return `<td><span class="status-badge ${statusClass}"><span class="dot"></span>${statusLabel}</span></td>`;
            
            case 'assignee':
                // INLINE EDITABLE: Assignee cell with click-to-edit
                // Use unified identity resolver for consistent display
                const assigneeIdentity = task.assigneeId ? getIdentity(task.assigneeId, task.assignee) : { displayName: 'Unassigned', avatarColor: '#8E8E93', initials: '?' };
                const fullName = assigneeIdentity.displayName;
                const firstName = fullName.split(' ')[0];
                const initials = assigneeIdentity.initials;
                const color = assigneeIdentity.avatarColor;
                const isTeamAssignee = task.assigneeId === 'team';
                const avatarClasses = isTeamAssignee ? 'assignee-avatar dropdown-assignee-avatar team-avatar' : 'assignee-avatar';
                const avatarContent = isTeamAssignee ? '<i class="fas fa-users"></i>' : initials;
                const avatarBg = isTeamAssignee ? '#000' : color;
                return `<td class="cell-editable"><div class="assignee-cell assignee-cell-inline" data-task-id="${task.id}" title="${escapeHtml(fullName)}"><div class="${avatarClasses}" style="background: ${avatarBg}">${avatarContent}</div><span class="assignee-name">${escapeHtml(firstName)}</span></div></td>`;
            
            case 'priority':
                // Check for custom settings with colors
                const prioritySettings = spreadsheet?.columnSettings?.priority;
                if (prioritySettings?.options && prioritySettings.options.length > 0) {
                    // Use custom dropdown rendering with colors
                    const priorityValue = (task.priority || 'medium').charAt(0).toUpperCase() + (task.priority || 'medium').slice(1);
                    const priorityOption = prioritySettings.options.find(opt => opt.label.toLowerCase() === (task.priority || 'medium'));
                    const priorityColor = priorityOption?.color || '#9CA3AF';
                    return `<td class="cell-editable">
                        <div class="custom-dropdown-cell built-in-dropdown" data-task-id="${task.id}" data-column-id="priority">
                            <span class="custom-dropdown-pill" style="background: ${priorityColor}20; color: ${priorityColor}">
                                <span class="pill-dot" style="background: ${priorityColor}"></span>
                                ${escapeHtml(priorityValue)}
                            </span>
                            <i class="fas fa-chevron-down custom-dropdown-icon"></i>
                        </div>
                    </td>`;
                }
                // Default priority rendering
                const priorityClass = task.priority || 'medium';
                const priorityLabel = (task.priority || 'medium').charAt(0).toUpperCase() + (task.priority || 'medium').slice(1);
                return `<td class="cell-editable"><span class="priority-badge priority-badge-inline ${priorityClass}" data-task-id="${task.id}">${priorityLabel}</span></td>`;
            
            case 'dueDate':
                // INLINE EDITABLE: Click to edit date
                // FIX: Robust date parsing to prevent "Invalid Date" bug
                if (!task.dueDate) {
                    return `<td class="cell-date-editable cell-editable date-cell" data-task-id="${task.id}">â€”</td>`;
                }
                // Normalize date: handle Firestore Timestamp, milliseconds, ISO string, or Date object
                const date = normalizeTaskDate(task.dueDate);
                if (!date || isNaN(date.getTime())) {
                    // Defensive fallback - never show "Invalid Date"
                    console.warn('Invalid dueDate for task:', task.id, task.dueDate);
                    return `<td class="cell-date-editable cell-editable date-cell" data-task-id="${task.id}">â€”</td>`;
                }
                const formatted = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const dueDate = new Date(date);
                dueDate.setHours(0, 0, 0, 0);
                const diff = Math.ceil((dueDate - today) / (1000 * 60 * 60 * 24));
                let chipClass = '';
                if (task.status !== 'done') {
                    if (diff < 0) {
                        chipClass = 'date-chip-overdue';
                    } else if (diff === 0) {
                        chipClass = 'date-chip-today';
                    } else if (diff === 1) {
                        chipClass = 'date-chip-tomorrow';
                    } else if (diff === 2) {
                        chipClass = 'date-chip-soon';
                    }
                }
                // Show recurring icon if task has recurrence
                const recurringIcon = task.isRecurring ? ' <i class="fas fa-redo" style="font-size: 10px; opacity: 0.6;" title="Recurring task"></i>' : '';
                const chipHtml = chipClass ? `<span class="date-chip ${chipClass}">${formatted}${recurringIcon}</span>` : `${formatted}${recurringIcon}`;
                return `<td class="cell-date-editable cell-editable date-cell" data-task-id="${task.id}">${chipHtml}</td>`;
            
            case 'progress':
                // Check for custom settings with color ranges
                const progressSettings = spreadsheet?.columnSettings?.progress;
                const progress = task.progress || (task.status === 'done' ? 100 : task.status === 'inprogress' ? 50 : 0);
                
                if (progressSettings?.colorRanges && progressSettings.colorRanges.length > 0) {
                    // Use custom slider rendering with color ranges
                    const pMin = progressSettings.min || 0;
                    const pMax = progressSettings.max || 100;
                    const pPct = ((progress - pMin) / (pMax - pMin)) * 100;
                    
                    // Find color based on ranges
                    let progressColor = '#9CA3AF';
                    for (const range of progressSettings.colorRanges) {
                        if (progress >= range.min && progress <= range.max) {
                            progressColor = range.color;
                            break;
                        }
                    }
                    
                    return `<td class="cell-editable">
                        <div class="custom-slider-cell" data-task-id="${task.id}" data-column-id="progress" data-color-ranges='${JSON.stringify(progressSettings.colorRanges)}'>
                            <input type="range" class="progress-range-slider custom-slider-input" min="${pMin}" max="${pMax}" value="${progress}" style="--progress: ${pPct}%; --slider-color: ${progressColor}">
                            <span class="custom-slider-badge" style="background: ${progressColor}">${progress}%</span>
                        </div>
                    </td>`;
                }
                
                // Default progress rendering
                const completeClass = progress === 100 ? 'complete' : '';
                return `<td class="cell-editable"><div class="progress-cell-inline" data-task-id="${task.id}"><input type="range" class="progress-range-slider ${completeClass}" min="0" max="100" value="${progress}" style="--progress: ${progress}%"><span class="progress-text">${progress}%</span></div></td>`;
            
            case 'budget':
                // INLINE EDITABLE: Click to edit budget
                return `<td class="cell-budget-editable cell-editable budget-cell" data-task-id="${task.id}">${task.budget ? '$' + parseFloat(task.budget).toFixed(2) : 'â€”'}</td>`;
            
            case 'estimatedTime':
                // INLINE EDITABLE: Click to edit estimated time
                return `<td class="cell-time-editable cell-editable" data-task-id="${task.id}">${task.estimatedTime ? task.estimatedTime + 'h' : 'â€”'}</td>`;
            
            // ===================================
            // LEADS COLUMNS
            // ===================================
            case 'leadName':
                // INLINE EDITABLE: Click to edit lead name directly
                return `<td class="cell-title-editable cell-editable" data-task-id="${task.id}">${escapeHtml(task.leadName || task.title || '')}</td>`;
            
            case 'source':
                // Lead source - check for custom settings with colors
                const sourceSettings = spreadsheet?.columnSettings?.source;
                if (sourceSettings?.options && sourceSettings.options.length > 0) {
                    // Use custom dropdown rendering with colors
                    const sourceValue = task.source || 'â€”';
                    const sourceOption = sourceSettings.options.find(opt => opt.label === sourceValue);
                    const sourceColor = sourceOption?.color || '#9CA3AF';
                    const hasValue = sourceValue && sourceValue !== 'â€”';
                    return `<td class="cell-editable">
                        <div class="custom-dropdown-cell built-in-dropdown" data-task-id="${task.id}" data-column-id="source">
                            ${hasValue 
                                ? `<span class="custom-dropdown-pill" style="background: ${sourceColor}20; color: ${sourceColor}">
                                    <span class="pill-dot" style="background: ${sourceColor}"></span>
                                    ${escapeHtml(sourceValue)}
                                   </span>`
                                : `<span class="custom-dropdown-value">${escapeHtml(sourceValue)}</span>`
                            }
                            <i class="fas fa-chevron-down custom-dropdown-icon"></i>
                        </div>
                    </td>`;
                }
                // Default text rendering
                return `<td class="cell-source-editable cell-editable" data-task-id="${task.id}">${escapeHtml(task.source || 'â€”')}</td>`;
            
            case 'value':
                // Lead value (monetary) - inline editable
                return `<td class="cell-value-editable cell-editable value-cell" data-task-id="${task.id}">${task.value ? '$' + parseFloat(task.value).toLocaleString() : 'â€”'}</td>`;
            
            case 'contact':
                // Contact info - inline editable text
                return `<td class="cell-contact-editable cell-editable" data-task-id="${task.id}">${escapeHtml(task.contact || 'â€”')}</td>`;
            
            case 'createdAt':
                // Created date - readonly
                if (!task.createdAt) {
                    return `<td class="date-cell">â€”</td>`;
                }
                const createdDate = new Date(task.createdAt);
                const createdFormatted = createdDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                return `<td class="date-cell">${createdFormatted}</td>`;
            
            case 'notes':
                // Notes - inline editable text
                return `<td class="cell-notes-editable cell-editable" data-task-id="${task.id}">${escapeHtml(task.notes || 'â€”')}</td>`;
            
            default:
                return `<td>â€”</td>`;
        }
    }

    // Get column label
    function getColumnLabel(column, spreadsheet) {
        // Check for custom column
        if (column.startsWith('custom_')) {
            const customCol = (spreadsheet?.customColumns || []).find(cc => cc.id === column);
            return customCol?.name || column;
        }
        
        // Check for custom settings on built-in columns
        const customSettings = spreadsheet?.columnSettings?.[column];
        if (customSettings?.label) {
            return customSettings.label;
        }
        
        const labels = {
            title: 'Title',
            status: 'Status',
            assignee: 'Assignee',
            priority: 'Priority',
            dueDate: 'Due Date',
            progress: 'Progress',
            budget: 'Budget',
            estimatedTime: 'Est. Time',
            // Leads columns
            leadName: 'Lead Name',
            source: 'Source',
            value: 'Value',
            contact: 'Contact',
            createdAt: 'Created',
            notes: 'Notes'
        };
        return labels[column] || column;
    }

    // Get column icon
    function getColumnIcon(column, spreadsheet) {
        // Check for custom column
        if (column.startsWith('custom_')) {
            const customCol = (spreadsheet?.customColumns || []).find(cc => cc.id === column);
            return customCol?.icon || 'fa-columns';
        }
        
        // Check for custom settings on built-in columns
        const customSettings = spreadsheet?.columnSettings?.[column];
        if (customSettings?.icon) {
            return customSettings.icon;
        }
        
        const icons = {
            title: 'fa-heading',
            status: 'fa-circle-notch',
            assignee: 'fa-user',
            priority: 'fa-flag',
            dueDate: 'fa-calendar',
            progress: 'fa-chart-line',
            budget: 'fa-dollar-sign',
            estimatedTime: 'fa-clock',
            // Leads columns
            leadName: 'fa-user-tie',
            source: 'fa-bullhorn',
            value: 'fa-hand-holding-dollar',
            contact: 'fa-address-book',
            createdAt: 'fa-calendar-plus',
            notes: 'fa-sticky-note'
        };
        return icons[column] || 'fa-columns';
    }

    // ===================================
    // BATCH ACTIONS
    // ===================================
    window.batchMarkDone = async function() {
        const taskIds = Array.from(spreadsheetState.selectedTasks);
        for (const taskId of taskIds) {
            await updateTaskStatus(taskId, 'done');
        }
        spreadsheetState.selectedTasks.clear();
        updateBatchActionsBar();
        showToast(`${taskIds.length} tasks marked as done`, 'success');
    };

    window.batchChangeStatus = function() {
        // VALID STATUS ENUMS: Only these three values are allowed
        // - 'todo': To Do
        // - 'inprogress': In Progress  
        // - 'done': Done
        // DO NOT use 'complete' or 'in-progress' (legacy values, now normalized)
        const statuses = ['todo', 'inprogress', 'done'];
        const statusLabels = { todo: 'To Do', inprogress: 'In Progress', done: 'Done' };
        
        // Simple modal for status selection
        const html = `
            <div class="modal active" id="batchStatusModal">
                <div class="modal-content" style="max-width: 300px;">
                    <div class="modal-header">
                        <h2>Change Status</h2>
                        <button class="modal-close" onclick="closeModal('batchStatusModal')">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label>New Status</label>
                            <select id="batchStatusSelect">
                                ${statuses.map(s => `<option value="${s}">${statusLabels[s]}</option>`).join('')}
                            </select>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn-secondary" onclick="closeModal('batchStatusModal')">Cancel</button>
                        <button class="btn-primary" onclick="applyBatchStatus()">Apply</button>
                    </div>
                </div>
            </div>
        `;
        document.body.insertAdjacentHTML('beforeend', html);
    };

    window.applyBatchStatus = async function() {
        const status = document.getElementById('batchStatusSelect').value;
        const taskIds = Array.from(spreadsheetState.selectedTasks);
        for (const taskId of taskIds) {
            await updateTaskStatus(taskId, status);
        }
        spreadsheetState.selectedTasks.clear();
        updateBatchActionsBar();
        closeModal('batchStatusModal');
        showToast(`${taskIds.length} tasks updated`, 'success');
    };

    window.batchDelete = async function() {
        const taskIds = Array.from(spreadsheetState.selectedTasks);
        const confirmed = await showConfirmModal(`Are you sure you want to delete ${taskIds.length} tasks?`, {
            title: 'Delete Tasks',
            confirmText: 'Delete',
            type: 'danger'
        });
        if (!confirmed) return;
        
        for (const taskId of taskIds) {
            await deleteTask(taskId);
        }
        spreadsheetState.selectedTasks.clear();
        updateBatchActionsBar();
        showToast(`${taskIds.length} tasks deleted`, 'success');
    };

    window.clearSelection = function() {
        spreadsheetState.selectedTasks.clear();
        updateRowSelections();
        updateBatchActionsBar();
    };

    // ===================================
    // FILTER & SEARCH
    // ===================================
    window.applyFilters = function() {
        spreadsheetState.filters.status = document.getElementById('filterStatus').value;
        spreadsheetState.filters.priority = document.getElementById('filterPriority').value;
        spreadsheetState.filters.assignee = document.getElementById('filterAssignee').value;
        
        if (appState.currentSpreadsheet) {
            renderSpreadsheetTable(appState.currentSpreadsheet);
        }
        
        // Close dropdown
        document.getElementById('filterDropdown').classList.remove('active');
    };

    window.clearFilters = function() {
        spreadsheetState.filters = { status: '', priority: '', assignee: '' };
        spreadsheetState.searchQuery = '';
        
        document.getElementById('filterStatus').value = '';
        document.getElementById('filterPriority').value = '';
        document.getElementById('filterAssignee').value = '';
        
        const searchInput = document.getElementById('spreadsheetSearch');
        if (searchInput) searchInput.value = '';
        
        if (appState.currentSpreadsheet) {
            renderSpreadsheetTable(appState.currentSpreadsheet);
        }
        
        document.getElementById('filterDropdown').classList.remove('active');
    };

    function populateFilterAssigneeDropdown() {
        const select = document.getElementById('filterAssignee');
        if (!select) return;
        
        select.innerHTML = '<option value="">All</option>';
        appState.teammates.forEach(member => {
            // Use unified identity resolver for consistent display
            const identity = getIdentity(member.id, member.email);
            const option = document.createElement('option');
            option.value = member.id;
            option.textContent = identity.displayName;
            select.appendChild(option);
        });
    }

    // Toggle task complete from checkbox
    window.toggleTaskComplete = function(taskId, isComplete) {
        updateTaskStatus(taskId, isComplete ? 'done' : 'todo');
    };

    // View task details - opens task in edit modal
    window.viewTaskDetails = function(taskId) {
        const task = appState.tasks.find(t => t.id === taskId || String(t.id) === String(taskId));
        if (task) {
            window.editTask(task);
        } else {
            console.warn('Task not found for viewTaskDetails:', taskId);
        }
    };

    // Edit task function
    window.editTask = function(task) {
        // Populate modal with task data for editing
        document.getElementById('taskTitle').value = task.title;
        document.getElementById('taskDescription').value = task.description || '';
        
        if (task.dueDate) {
            const date = new Date(task.dueDate);
            // Check if date is valid before calling toISOString
            if (!isNaN(date.getTime())) {
                document.getElementById('taskDueDate').value = date.toISOString().split('T')[0];
            } else {
                document.getElementById('taskDueDate').value = '';
                console.warn('Invalid dueDate value:', task.dueDate);
            }
        }
        
        document.getElementById('taskBudget').value = task.budget || '';
        document.getElementById('taskEstimatedTime').value = task.estimatedTime || '';
        
        // Set Show on Calendar toggle (default to true for backward compatibility)
        const showOnCalendarCheckbox = document.getElementById('taskShowOnCalendar');
        if (showOnCalendarCheckbox) {
            showOnCalendarCheckbox.checked = task.showOnCalendar !== false;
        }
        
        // Update progress bar (range slider + number input + fill + badge)
        const progressInput = document.getElementById('taskProgress');
        const progressSlider = document.getElementById('taskProgressSlider');
        const progressFill = document.getElementById('taskProgressFill');
        const progressBadge = document.getElementById('taskProgressBadge');
        if (progressInput) {
            const progress = task.progress || 0;
            progressInput.value = progress;
            if (progressSlider) {
                progressSlider.value = progress;
                progressSlider.style.setProperty('--progress', progress + '%');
            }
            if (progressFill) {
                progressFill.style.width = progress + '%';
            }
            if (progressBadge) {
                progressBadge.textContent = progress + '%';
            }
        }

        populateTaskAssigneeDropdown();
        populateTaskSpreadsheetDropdown(task.spreadsheetId); // Populate and select current spreadsheet
        
        // Set custom dropdown values
        setTimeout(() => {
            // Set Assignee
            setCustomDropdownValue('taskAssignee', task.assigneeId || '', (value, option) => {
                const avatar = option?.querySelector('.dropdown-assignee-avatar');
                const name = option?.dataset.name || option?.querySelector('span')?.textContent || 'Unassigned';
                if (avatar) {
                    return `
                        <div class="dropdown-assignee-avatar" style="${avatar.getAttribute('style')}">${avatar.textContent}</div>
                        <span>${name}</span>
                    `;
                }
                return `<span class="dropdown-placeholder">Select...</span>`;
            });
            
            // Set Priority
            setCustomDropdownValue('taskPriority', task.priority || 'medium', (value, option) => {
                const label = option?.querySelector('span:not(.priority-dot)')?.textContent || value;
                return `
                    <span class="priority-dot ${value}"></span>
                    <span>${label}</span>
                `;
            });
            
            // Set Status
            setCustomDropdownValue('taskStatus', task.status || 'todo', (value, option) => {
                const label = option?.querySelector('span:not(.status-dot)')?.textContent || value;
                return `
                    <span class="status-dot ${value}"></span>
                    <span>${label}</span>
                `;
            });
        }, 100);
        
        // Update word counter
        const counter = document.getElementById('taskTitleCounter');
        if (counter) {
            const words = (task.title || '').split(/\s+/).filter(word => word.length > 0);
            counter.textContent = `${words.length}/20 words`;
            counter.classList.remove('warning', 'limit');
            if (words.length >= 20) {
                counter.classList.add('limit');
            } else if (words.length >= 15) {
                counter.classList.add('warning');
            }
        }

        // Store task ID for editing
        document.getElementById('taskForm').dataset.editingTaskId = task.id;
        const titleEl = document.querySelector('#taskModal .unified-modal-title h2');
        const submitBtn = document.querySelector('#taskModal .unified-btn-primary');
        if (titleEl) titleEl.innerHTML = '<i class="fas fa-edit"></i> Edit Task';
        if (submitBtn) submitBtn.innerHTML = '<i class="fas fa-check"></i> Save Changes';
        
        openModal('taskModal');
    };
    
    // Helper function to set custom dropdown value
    function setCustomDropdownValue(inputId, value, getTriggerContent) {
        const trigger = document.getElementById(inputId + 'Trigger');
        const menu = document.getElementById(inputId + 'Menu');
        const hiddenInput = document.getElementById(inputId);
        
        if (!trigger || !menu || !hiddenInput) return;
        
        hiddenInput.value = value;
        
        // Update active state
        menu.querySelectorAll('.dropdown-menu-option').forEach(opt => {
            opt.classList.remove('active');
            const check = opt.querySelector('.fa-check');
            if (check) check.remove();
        });
        
        const selectedOption = menu.querySelector(`[data-value="${value}"]`);
        if (selectedOption) {
            selectedOption.classList.add('active');
            if (!selectedOption.querySelector('.fa-check')) {
                selectedOption.innerHTML += '<i class="fas fa-check"></i>';
            }
            
            // Update trigger content
            const triggerContent = trigger.querySelector('.dropdown-trigger-content') || trigger.querySelector('.unified-dropdown-value');
            if (getTriggerContent && triggerContent) {
                triggerContent.innerHTML = getTriggerContent(value, selectedOption);
            }
        }
    }

    // Make displayTasks available globally
    window.displayTasks = displayTasks;

    // Initialize spreadsheet modal
    function initSpreadsheetModal() {
        // Add back button handler for spreadsheet panel
        const backBtn = document.querySelector('.spreadsheet-panel .back-btn');
        if (backBtn) {
            backBtn.addEventListener('click', window.closeSpreadsheetPanel);
        }

        // Handle title editing in spreadsheet panel
        const titleInput = document.querySelector('.spreadsheet-title-input');
        if (titleInput) {
            const saveSpreadsheetName = async () => {
                if (appState.currentSpreadsheet && titleInput.value.trim()) {
                    const newName = titleInput.value.trim();
                    
                    // Skip if name hasn't changed
                    if (appState.currentSpreadsheet.name === newName) return;
                    
                    appState.currentSpreadsheet.name = newName;
                    
                    // Also update in appState.spreadsheets array
                    const spreadsheetIndex = appState.spreadsheets.findIndex(s => s.id === appState.currentSpreadsheet.id);
                    if (spreadsheetIndex !== -1) {
                        appState.spreadsheets[spreadsheetIndex].name = newName;
                    }
                    
                    // Save to Firestore
                    try {
                        await saveSpreadsheetToFirestore(appState.currentSpreadsheet);
                        console.log('Spreadsheet name saved:', newName);
                    } catch (error) {
                        console.error('Failed to save spreadsheet name:', error);
                        showToast('Failed to save name', 'error');
                    }
                    
                    // Update cards
                    renderSpreadsheetCards();
                }
            };
            
            titleInput.addEventListener('change', saveSpreadsheetName);
            titleInput.addEventListener('blur', saveSpreadsheetName);
        }

        // Handle settings button
        const settingsBtn = document.querySelector('.spreadsheet-panel .panel-action-btn:not(.primary)');
        if (settingsBtn) {
            settingsBtn.addEventListener('click', () => {
                showToast('Settings coming soon!', 'info');
            });
        }

        // Create spreadsheet modal HTML dynamically - Unified Modern Style
        const modalHTML = `
            <div class="unified-modal" id="spreadsheetModal">
                <div class="unified-modal-container">
                    <div class="unified-modal-header">
                        <div class="unified-modal-title">
                            <h2><i class="fas fa-table-cells"></i> New Spreadsheet</h2>
                            <p class="subtitle">Create a new spreadsheet for your team</p>
                        </div>
                        <button class="unified-modal-close" onclick="closeModal('spreadsheetModal')">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <form id="spreadsheetForm">
                        <div class="unified-modal-body">
                            <div class="unified-form-grid">
                                <!-- Name - Full Width -->
                                <div class="unified-form-field full-width">
                                    <label class="unified-form-label">
                                        Name <span class="required">*</span>
                                    </label>
                                    <input type="text" class="unified-input" id="spreadsheetName" placeholder="My Tasks" required>
                                </div>
                                
                                <!-- Type Selector - Full Width -->
                                <div class="unified-form-field full-width">
                                    <label class="unified-form-label">
                                        <i class="fas fa-shapes"></i> Type
                                    </label>
                                    <div class="unified-segmented" id="typeSelectRow">
                                        <button type="button" class="unified-segmented-option active" data-type="tasks">
                                            <i class="fas fa-tasks"></i>
                                            <span>Tasks</span>
                                        </button>
                                        <button type="button" class="unified-segmented-option" data-type="leads">
                                            <i class="fas fa-user-plus"></i>
                                            <span>Leads</span>
                                        </button>
                                    </div>
                                    <input type="hidden" id="spreadsheetType" value="tasks">
                                </div>
                                
                                <!-- Icon -->
                                <div class="unified-form-field">
                                    <label class="unified-form-label">
                                        <i class="fas fa-icons"></i> Icon
                                    </label>
                                    <div class="unified-icon-grid" id="iconSelectGrid">
                                        <button type="button" class="unified-icon-option selected" data-icon="fa-table"><i class="fas fa-table"></i></button>
                                        <button type="button" class="unified-icon-option" data-icon="fa-list-check"><i class="fas fa-list-check"></i></button>
                                        <button type="button" class="unified-icon-option" data-icon="fa-clipboard-list"><i class="fas fa-clipboard-list"></i></button>
                                        <button type="button" class="unified-icon-option" data-icon="fa-folder"><i class="fas fa-folder"></i></button>
                                        <button type="button" class="unified-icon-option" data-icon="fa-calendar"><i class="fas fa-calendar"></i></button>
                                        <button type="button" class="unified-icon-option" data-icon="fa-star"><i class="fas fa-star"></i></button>
                                        <button type="button" class="unified-icon-option" data-icon="fa-briefcase"><i class="fas fa-briefcase"></i></button>
                                        <button type="button" class="unified-icon-option" data-icon="fa-bolt"><i class="fas fa-bolt"></i></button>
                                    </div>
                                    <input type="hidden" id="spreadsheetIcon" value="fa-table">
                                </div>
                                
                                <!-- Color -->
                                <div class="unified-form-field">
                                    <label class="unified-form-label">
                                        <i class="fas fa-palette"></i> Color
                                    </label>
                                    <div class="unified-color-grid" id="colorSelectGrid">
                                        <button type="button" class="unified-color-option selected" data-color="#0070f3" style="background: #0070f3;"></button>
                                        <button type="button" class="unified-color-option" data-color="#34c759" style="background: #34c759;"></button>
                                        <button type="button" class="unified-color-option" data-color="#ff9500" style="background: #ff9500;"></button>
                                        <button type="button" class="unified-color-option" data-color="#ff3b30" style="background: #ff3b30;"></button>
                                        <button type="button" class="unified-color-option" data-color="#af52de" style="background: #af52de;"></button>
                                        <button type="button" class="unified-color-option" data-color="#5856d6" style="background: #5856d6;"></button>
                                        <button type="button" class="unified-color-option" data-color="#00c7be" style="background: #00c7be;"></button>
                                        <button type="button" class="unified-color-option" data-color="#ff2d55" style="background: #ff2d55;"></button>
                                    </div>
                                    <input type="hidden" id="spreadsheetColor" value="#0070f3">
                                </div>
                                
                                <!-- Visibility - Full Width -->
                                <div class="unified-form-field full-width">
                                    <label class="unified-form-label">
                                        <i class="fas fa-eye"></i> Visibility
                                    </label>
                                    <div class="calendar-view-toggle visibility-toggle" data-target="spreadsheetVisibility">
                                        <input type="hidden" name="spreadsheetVisibility" value="team">
                                        <button type="button" class="view-toggle-btn active" data-visibility="team">
                                            <i class="fas fa-users"></i>
                                            <span>Team</span>
                                        </button>
                                        <button type="button" class="view-toggle-btn" data-visibility="private">
                                            <i class="fas fa-lock"></i>
                                            <span>Private</span>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="unified-modal-footer">
                            <button type="button" class="unified-btn unified-btn-secondary" onclick="closeModal('spreadsheetModal')">Cancel</button>
                            <button type="submit" class="unified-btn unified-btn-primary">
                                <i class="fas fa-plus"></i> Create Spreadsheet
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        `;

        // Only add if doesn't exist
        if (!document.getElementById('spreadsheetModal')) {
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        // Handle icon selection
        const iconGrid = document.getElementById('iconSelectGrid');
        const iconInput = document.getElementById('spreadsheetIcon');
        if (iconGrid && iconInput) {
            iconGrid.addEventListener('click', (e) => {
                const btn = e.target.closest('.unified-icon-option');
                if (btn) {
                    iconGrid.querySelectorAll('.unified-icon-option').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    iconInput.value = btn.dataset.icon;
                }
            });
        }

        // Handle color selection
        const colorGrid = document.getElementById('colorSelectGrid');
        const colorInput = document.getElementById('spreadsheetColor');
        if (colorGrid && colorInput) {
            colorGrid.addEventListener('click', (e) => {
                const btn = e.target.closest('.unified-color-option');
                if (btn) {
                    colorGrid.querySelectorAll('.unified-color-option').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    colorInput.value = btn.dataset.color;
                }
            });
        }

        // Handle type selection
        const typeSelectRow = document.getElementById('typeSelectRow');
        const typeInput = document.getElementById('spreadsheetType');
        if (typeSelectRow && typeInput) {
            typeSelectRow.addEventListener('click', (e) => {
                const btn = e.target.closest('.unified-segmented-option');
                if (btn) {
                    typeSelectRow.querySelectorAll('.unified-segmented-option').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    typeInput.value = btn.dataset.type;
                    // Update placeholder based on type
                    const nameInput = document.getElementById('spreadsheetName');
                    if (nameInput) {
                        nameInput.placeholder = btn.dataset.type === 'leads' ? 'My Leads' : 'My Tasks';
                    }
                }
            });
        }

        // Handle visibility selection
        initVisibilityToggles(document.querySelectorAll('#spreadsheetModal .visibility-toggle'));

        // Handle form submission
        const form = document.getElementById('spreadsheetForm');
        if (form) {
            form.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const editingSpreadsheetId = form.dataset.editingSpreadsheetId;
                
                if (editingSpreadsheetId) {
                    // EDIT MODE - Update existing spreadsheet
                    const spreadsheet = appState.spreadsheets.find(s => s.id === editingSpreadsheetId);
                    if (!spreadsheet) {
                        showToast('Spreadsheet not found', 'error');
                        return;
                    }
                    
                    const icon = document.getElementById('spreadsheetIcon').value;
                    const color = document.getElementById('spreadsheetColor').value;
                    const visibility = getActiveVisibilityValue('spreadsheetVisibility');
                    
                    // Update spreadsheet properties
                    spreadsheet.icon = icon;
                    spreadsheet.color = color;
                    spreadsheet.visibility = visibility;
                    
                    // Save to Firestore
                    await saveSpreadsheetToFirestore(spreadsheet);
                    
                    renderSpreadsheetCards();
                    
                    // Reset form
                    form.reset();
                    delete form.dataset.editingSpreadsheetId;
                    
                    // Reset modal to create mode
                    const titleEl = document.querySelector('#spreadsheetModal .unified-modal-title h2');
                    const subtitleEl = document.querySelector('#spreadsheetModal .unified-modal-title .subtitle');
                    const submitBtn = document.querySelector('#spreadsheetModal .unified-btn-primary');
                    if (titleEl) titleEl.innerHTML = '<i class=\"fas fa-table-cells\"></i> New Spreadsheet';
                    if (subtitleEl) subtitleEl.textContent = 'Create a new spreadsheet for your team';
                    if (submitBtn) submitBtn.innerHTML = '<i class=\"fas fa-plus\"></i> Create Spreadsheet';
                    
                    // Show hidden fields and restore required validation
                    const nameField = document.querySelector('#spreadsheetName')?.closest('.unified-form-field');
                    const nameInput = document.getElementById('spreadsheetName');
                    const typeField = document.querySelector('#typeSelectRow')?.closest('.unified-form-field');
                    if (nameField) nameField.style.display = '';
                    if (nameInput) nameInput.setAttribute('required', '');
                    if (typeField) typeField.style.display = '';
                    if (nameInput) nameInput.setAttribute('required', '');
                    if (typeField) typeField.style.display = '';
                    
                    closeModal('spreadsheetModal');
                    showToast(`Spreadsheet updated!`, 'success');
                    
                } else {
                    // CREATE MODE - New spreadsheet
                    const name = document.getElementById('spreadsheetName').value.trim();
                    const icon = document.getElementById('spreadsheetIcon').value;
                    const color = document.getElementById('spreadsheetColor').value;
                    const visibility = getActiveVisibilityValue('spreadsheetVisibility');
                    const type = document.getElementById('spreadsheetType').value || 'tasks';

                    if (!name) {
                        showToast('Please enter a spreadsheet name', 'error');
                        return;
                    }

                    if (!appState.spreadsheets) {
                        appState.spreadsheets = [];
                    }

                    // Check for duplicate names (to avoid metrics conflicts)
                    const existingWithSameName = appState.spreadsheets.find(s => 
                        s.name.toLowerCase() === name.toLowerCase()
                    );
                    if (existingWithSameName) {
                        showToast('A spreadsheet with this name already exists. Please choose a different name.', 'warning');
                        return;
                    }

                    // Use preset based on type
                const preset = type === 'leads' ? LEADS_TABLE_PRESET : TASKS_TABLE_PRESET;

                // Generate unique ID with type prefix for reliable type detection on reload
                // leads_ prefix allows type detection even if type field is lost
                const idPrefix = type === 'leads' ? 'leads_' : 'tasks_';
                const uniqueId = idPrefix + Date.now().toString();

                const newSpreadsheet = {
                    id: uniqueId,
                    name: name,
                    type: type, // 'tasks' or 'leads'
                    icon: icon,
                    color: color,
                    visibility: visibility,
                    createdBy: currentAuthUser?.uid || null,
                    columns: [...preset.columns],
                    columnSettings: JSON.parse(JSON.stringify(preset.columnSettings))
                    // Don't set createdAt here - let saveSpreadsheetToFirestore handle it with serverTimestamp()
                };

                appState.spreadsheets.push(newSpreadsheet);
                
                // Save to Firestore
                await saveSpreadsheetToFirestore(newSpreadsheet);
                
                renderSpreadsheetCards();
                
                // Reset form and selections
                form.reset();
                iconGrid.querySelectorAll('.unified-icon-option').forEach((b, i) => b.classList.toggle('selected', i === 0));
                colorGrid.querySelectorAll('.unified-color-option').forEach((b, i) => b.classList.toggle('selected', i === 0));
                typeSelectRow.querySelectorAll('.unified-segmented-option').forEach((b, i) => b.classList.toggle('active', i === 0));
                visibilityOptions.forEach((o, i) => o.classList.toggle('selected', i === 0));
                document.getElementById('spreadsheetIcon').value = 'fa-table';
                document.getElementById('spreadsheetColor').value = '#0070f3';
                document.getElementById('spreadsheetType').value = 'tasks';
                
                closeModal('spreadsheetModal');
                
                showToast(`Spreadsheet "${name}" created!`, 'success');
                }
            });
        }
    }

    // Initialize spreadsheet panel handlers
    function initSpreadsheetPanelHandlers() {
        // Back button - use ID for reliable selection
        const backBtn = document.getElementById('spreadsheetBackBtn');
        if (backBtn) {
            backBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                window.closeSpreadsheetPanel();
            });
        }

        // Title input
        const titleInput = document.querySelector('.spreadsheet-title-input');
        if (titleInput) {
            const saveSpreadsheetName = async () => {
                if (appState.currentSpreadsheet && titleInput.value.trim()) {
                    const newName = titleInput.value.trim();
                    appState.currentSpreadsheet.name = newName;
                    
                    // Also update in the spreadsheets array
                    const idx = appState.spreadsheets.findIndex(s => s.id === appState.currentSpreadsheet.id);
                    if (idx !== -1) {
                        appState.spreadsheets[idx].name = newName;
                    }
                    
                    await saveSpreadsheetToFirestore(appState.currentSpreadsheet);
                    renderSpreadsheetCards();
                }
            };
            titleInput.addEventListener('change', saveSpreadsheetName);
            titleInput.addEventListener('blur', saveSpreadsheetName);
        }

        // Filter button
        const filterBtn = document.getElementById('filterBtn');
        const filterDropdown = document.getElementById('filterDropdown');
        if (filterBtn && filterDropdown) {
            filterBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                filterDropdown.classList.toggle('active');
            });

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!filterDropdown.contains(e.target) && e.target !== filterBtn) {
                    filterDropdown.classList.remove('active');
                }
            });
        }

        // Batch action buttons
        const batchDeleteBtn = document.getElementById('batchDeleteBtn');
        const batchStatusBtn = document.getElementById('batchStatusBtn');
        
        if (batchDeleteBtn) {
            batchDeleteBtn.addEventListener('click', window.batchDelete);
        }
        if (batchStatusBtn) {
            batchStatusBtn.addEventListener('click', window.batchChangeStatus);
        }

        // Sidebar toggle (close button inside sidebar)
        const toggleSidebar = document.getElementById('toggleSidebar');
        const columnSidebar = document.getElementById('columnSidebar');
        const openSidebarBtn = document.getElementById('openSidebarBtn');
        
        function updateSidebarVisibility() {
            const isCollapsed = columnSidebar && columnSidebar.classList.contains('collapsed');
            if (openSidebarBtn) {
                openSidebarBtn.style.display = isCollapsed ? 'flex' : 'none';
            }
        }
        
        if (toggleSidebar && columnSidebar) {
            toggleSidebar.addEventListener('click', () => {
                columnSidebar.classList.add('collapsed');
                updateSidebarVisibility();
            });
        }
        
        if (openSidebarBtn && columnSidebar) {
            openSidebarBtn.addEventListener('click', () => {
                columnSidebar.classList.remove('collapsed');
                updateSidebarVisibility();
            });
        }
        
        // Initialize sidebar button visibility
        updateSidebarVisibility();

        // Settings button
        const settingsBtn = document.getElementById('spreadsheetSettingsBtn');
        if (settingsBtn) {
            settingsBtn.addEventListener('click', () => {
                showToast('Settings coming soon!', 'info');
            });
        }
        
        // Add task/lead button in panel header
        const addTaskPanelBtn = document.getElementById('addTaskPanelBtn');
        if (addTaskPanelBtn) {
            addTaskPanelBtn.addEventListener('click', () => {
                // Check if current spreadsheet is leads type
                if (appState.currentSpreadsheet?.type === 'leads') {
                    openAddLeadModal();
                    return;
                }
                
                // Reset form for new task
                document.getElementById('taskForm').reset();
                delete document.getElementById('taskForm').dataset.editingTaskId;
                const titleEl = document.querySelector('#taskModal .unified-modal-title h2');
                const submitBtn = document.querySelector('#taskModal .unified-btn-primary');
                if (titleEl) titleEl.innerHTML = '<i class="fas fa-plus-circle"></i> New Task';
                if (submitBtn) submitBtn.innerHTML = '<i class="fas fa-check"></i> Create Task';
                
                populateTaskAssigneeDropdown();
                // Default to current spreadsheet when adding from panel
                const currentSpreadsheetId = appState.currentSpreadsheet?.id || 'default';
                populateTaskSpreadsheetDropdown(currentSpreadsheetId);
                
                // Set minimum date to today
                const taskDueDateInput = document.getElementById('taskDueDate');
                if (taskDueDateInput) {
                    const today = new Date().toISOString().split('T')[0];
                    taskDueDateInput.setAttribute('min', today);
                }
                
                openModal('taskModal');
            });
        }
        
        // Toggle completed tasks visibility button
        const toggleCompletedBtn = document.getElementById('toggleCompletedBtn');
        const toggleCompletedText = document.getElementById('toggleCompletedText');
        if (toggleCompletedBtn && toggleCompletedText) {
            // Initialize button text based on current state
            updateToggleCompletedButton();
            
            toggleCompletedBtn.addEventListener('click', () => {
                // Toggle state
                spreadsheetState.showCompleted = !spreadsheetState.showCompleted;
                
                // Persist to localStorage
                localStorage.setItem('showCompletedTasks', spreadsheetState.showCompleted.toString());
                
                // Update button appearance
                updateToggleCompletedButton();
                
                // Re-render table with new filter
                if (appState.currentSpreadsheet) {
                    renderSpreadsheetTable(appState.currentSpreadsheet);
                }
            });
        }
        
        // Helper function to update toggle button appearance
        function updateToggleCompletedButton() {
            const toggleCompletedBtn = document.getElementById('toggleCompletedBtn');
            const toggleCompletedText = document.getElementById('toggleCompletedText');
            if (!toggleCompletedBtn || !toggleCompletedText) return;
            
            if (spreadsheetState.showCompleted) {
                toggleCompletedText.textContent = 'Hide completed';
                toggleCompletedBtn.classList.add('active');
            } else {
                toggleCompletedText.textContent = 'See all';
                toggleCompletedBtn.classList.remove('active');
            }
        }
    }

    // Helper: Check if current user can edit this spreadsheet based on visibility
    function canEditSpreadsheet(spreadsheet) {
        if (!currentAuthUser) return false;
        
        // Creator can always edit their own
        if (spreadsheet.createdBy === currentAuthUser.uid) return true;
        
        // Get user role
        const userRole = appState.currentTeamData?.members?.[currentAuthUser.uid]?.role || 'member';
        
        // Check visibility permissions
        const vis = spreadsheet.visibility || 'team';
        if (vis === 'team') return true;  // Any member can edit team sheets
        if (vis === 'admins') return userRole === 'admin' || userRole === 'owner';
        if (vis === 'private') return false;  // Already checked creator above
        
        return false;
    }

    // Save spreadsheet to Firestore
    async function saveSpreadsheetToFirestore(spreadsheet) {
        if (!appState.currentTeamId || !db) {
            console.warn('Cannot save spreadsheet: no team or db');
            return;
        }
        
        if (!currentAuthUser?.uid) {
            console.warn('Cannot save spreadsheet: no authenticated user');
            return;
        }
        
        // PERMISSION CHECK: Verify user can edit this spreadsheet
        if (!canEditSpreadsheet(spreadsheet)) {
            // Silent return to avoid console spam - user doesn't have permission
            debugLog('âš ï¸ Skipping save - no edit permission for spreadsheet:', spreadsheet.id);
            return;
        }
        
        try {
            const { doc, setDoc, updateDoc, getDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
            const spreadsheetRef = doc(db, 'teams', appState.currentTeamId, 'spreadsheets', spreadsheet.id);
            
            // Check if doc exists to determine create vs update
            // If getDoc fails (permission-denied on non-existent doc), treat as new
            let docSnap = null;
            let isNewDoc = true;
            try {
                docSnap = await getDoc(spreadsheetRef);
                isNewDoc = !docSnap.exists();
            } catch (getErr) {
                // If we can't read it, assume it doesn't exist (CREATE mode)
                console.log('ðŸ“ Cannot read doc (likely new):', getErr.code);
                isNewDoc = true;
            }
            
            console.log(`ðŸ” saveSpreadsheetToFirestore: id=${spreadsheet.id}, isNewDoc=${isNewDoc}`);
            
            // Determine default columns based on type
            const isLeadsType = spreadsheet.type === 'leads';
            const defaultColumns = isLeadsType 
                ? ['leadName', 'status', 'source', 'value', 'contact', 'createdAt', 'notes']
                : ['title', 'status', 'assignee', 'priority', 'dueDate', 'progress'];
            
            if (isNewDoc) {
                // CREATE: Full schema including immutable fields
                const createData = {
                    name: spreadsheet.name,
                    type: spreadsheet.type || 'tasks',
                    icon: spreadsheet.icon || 'fa-table',
                    color: spreadsheet.color || '#0070f3',
                    columns: spreadsheet.columns || defaultColumns,
                    visibility: spreadsheet.visibility || 'team',
                    createdBy: currentAuthUser.uid,  // IMMUTABLE: set only on create
                    teamId: appState.currentTeamId,   // IMMUTABLE: set only on create
                    createdAt: serverTimestamp(),     // IMMUTABLE: set only on create
                    updatedAt: serverTimestamp(),
                    customColumns: spreadsheet.customColumns || [],
                    columnSettings: spreadsheet.columnSettings || {}
                };
                
                console.log('ðŸ“ CREATE spreadsheet with data:', {
                    keys: Object.keys(createData),
                    hasTeamId: 'teamId' in createData,
                    hasCreatedAt: 'createdAt' in createData,
                    hasId: 'id' in createData
                });
                
                // DEBUG_PERMS logging
                if (DEBUG_PERMS) {
                    console.log('[DEBUG_PERMS] CREATE spreadsheet:', {
                        path: `teams/${appState.currentTeamId}/spreadsheets/${spreadsheet.id}`,
                        keys: Object.keys(createData),
                        uid: currentAuthUser.uid
                    });
                }
                
                await setDoc(spreadsheetRef, createData);
                spreadsheet.createdBy = currentAuthUser.uid;
                console.log('Spreadsheet CREATED in Firestore:', spreadsheet.name);
            } else {
                // UPDATE: Only mutable fields (rules use affectedKeys check)
                // NOTE: teamId, createdBy, createdAt are NOT included - they're immutable
                const updateData = {
                    name: spreadsheet.name,
                    type: spreadsheet.type || 'tasks',
                    icon: spreadsheet.icon || 'fa-table',
                    color: spreadsheet.color || '#0070f3',
                    columns: spreadsheet.columns || defaultColumns,
                    visibility: spreadsheet.visibility || 'team',
                    updatedAt: serverTimestamp(),
                    customColumns: spreadsheet.customColumns || [],
                    columnSettings: spreadsheet.columnSettings || {}
                };
                // NOTE: createdBy and createdAt are NOT included - they're immutable and not needed
                
                // DEBUG_PERMS logging
                if (DEBUG_PERMS) {
                    const existingData = docSnap.data();
                    console.log('[DEBUG_PERMS] UPDATE spreadsheet:', {
                        path: `teams/${appState.currentTeamId}/spreadsheets/${spreadsheet.id}`,
                        keysBeingSent: Object.keys(updateData),
                        existingDocKeys: Object.keys(existingData),
                        uid: currentAuthUser.uid,
                        existingCreatedBy: existingData.createdBy,
                        existingTeamId: existingData.teamId,
                        existingCreatedAt: existingData.createdAt ? 'exists' : 'MISSING'
                    });
                }
                
                await updateDoc(spreadsheetRef, updateData);
                spreadsheet.createdBy = docSnap.data().createdBy;  // Preserve existing
                console.log('Spreadsheet UPDATED in Firestore:', spreadsheet.name);
            }
        } catch (error) {
            const path = `teams/${appState.currentTeamId}/spreadsheets/${spreadsheet.id}`;
            // Log with a note that this is the INPUT object, not what was sent to Firestore
            logFirestoreError('saveSpreadsheetToFirestore', path, spreadsheet, {
                uid: currentAuthUser?.uid,
                teamId: appState.currentTeamId,
                spreadsheetName: spreadsheet.name,
                spreadsheetVisibility: spreadsheet.visibility
            }, error);
            throw error;
        }
    }

    // Load spreadsheets from Firestore
    async function loadSpreadsheetsFromFirestore() {
        if (!appState.currentTeamId || !db) {
            console.warn('Cannot load spreadsheets: no team or db');
            return;
        }
        
        try {
            const { collection, getDocs } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
            const spreadsheetsRef = collection(db, 'teams', appState.currentTeamId, 'spreadsheets');
            const snapshot = await getDocs(spreadsheetsRef);
            
            appState.spreadsheets = [];
            snapshot.forEach(docSnap => {
                const data = docSnap.data();
                const docId = docSnap.id;
                
                // ROBUST TYPE DETECTION: Check multiple sources
                // 1. First check saved type field
                // 2. Fallback to ID prefix (leads_ or tasks_)
                // 3. Last resort: check if columns contain lead-specific columns
                let spreadsheetType = data.type;
                
                if (!spreadsheetType) {
                    // Check ID prefix
                    if (docId.startsWith('leads_')) {
                        spreadsheetType = 'leads';
                    } else if (docId.startsWith('tasks_')) {
                        spreadsheetType = 'tasks';
                    } else {
                        // Check columns for lead indicators
                        const cols = data.columns || [];
                        if (cols.includes('leadName') || cols.includes('source') || cols.includes('value')) {
                            spreadsheetType = 'leads';
                        } else {
                            spreadsheetType = 'tasks';
                        }
                    }
                }
                
                const isLeadsType = spreadsheetType === 'leads';
                
                // Use type-appropriate default columns if none saved
                const defaultColumns = isLeadsType 
                    ? ['leadName', 'status', 'source', 'value', 'contact', 'createdAt', 'notes']
                    : ['title', 'status', 'assignee', 'priority', 'dueDate', 'progress'];
                
                // Ensure all column-related fields are loaded properly
                const spreadsheet = {
                    id: docSnap.id,
                    name: data.name,
                    type: spreadsheetType, // CRITICAL: Load the type!
                    icon: data.icon || 'fa-table',
                    color: data.color || '#0070f3',
                    columns: data.columns || defaultColumns,
                    visibility: data.visibility || 'team',
                    createdBy: data.createdBy,
                    createdAt: data.createdAt,
                    updatedAt: data.updatedAt,
                    // Load custom columns with all properties (type, options, colors, ranges)
                    customColumns: data.customColumns || [],
                    // Load built-in column customizations
                    columnSettings: data.columnSettings || {}
                };
                
                // Debug logging
                console.log(`ðŸ“Š Loaded spreadsheet "${spreadsheet.name}":`, {
                    id: spreadsheet.id,
                    type: spreadsheet.type,
                    savedType: data.type,
                    columns: spreadsheet.columns
                });
                
                appState.spreadsheets.push(spreadsheet);
            });
            
            // Set flag to indicate spreadsheets have been loaded from Firestore
            // This prevents race condition in renderSpreadsheetCards creating duplicate defaults
            appState._spreadsheetsLoaded = true;
            
            console.log('Loaded spreadsheets from Firestore:', appState.spreadsheets.length, 'with custom columns');
            renderSpreadsheetCards();
        } catch (error) {
            console.error('Error loading spreadsheets:', error);
            // Still set flag even on error to avoid stuck state
            appState._spreadsheetsLoaded = true;
        }
    }

    // Make loadSpreadsheetsFromFirestore available
    window.loadSpreadsheetsFromFirestore = loadSpreadsheetsFromFirestore;

    // Expose functions globally
    window.renderSpreadsheetCards = renderSpreadsheetCards;
    window.openSpreadsheetPanel = openSpreadsheetPanel;
    window.saveSpreadsheetToFirestore = saveSpreadsheetToFirestore;

    // ===================================
    // DOCS MODULE
    // Simple document storage + editing
    // ===================================
    
    /**
     * Initialize Docs feature - toggle, cards, panel, editor
     */
    function initDocsModule() {
        debugLog('ðŸ“„ Initializing Docs module...');
        
        // Initialize toggle between Sheets and Docs
        initSheetsDocsToggle();
        
        // Initialize doc cards click handlers
        initDocCards();
        
        // Initialize doc panel
        initDocPanel();
        
        // Initialize doc editor
        initDocEditor();
        
        // Initialize new features
        initDocFormatDropdown();
        initDocCommandPopover();
        initDocEmojiPicker();
    }
    
    /**
     * Initialize Sheets/Docs toggle in tasks section header
     */
    function initSheetsDocsToggle() {
        const toggleBtns = document.querySelectorAll('.sheets-docs-toggle .toggle-btn');
        
        toggleBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const view = btn.dataset.view;
                switchTasksView(view);
            });
        });
        
        // Restore last view from localStorage
        const savedView = localStorage.getItem('teamster_tasks_view') || 'sheets';
        // Don't auto-switch on init - keep default to sheets
    }
    
    /**
     * Switch between Sheets and Docs views
     */
    function switchTasksView(view) {
        appState.tasksViewMode = view;
        localStorage.setItem('teamster_tasks_view', view);
        
        // Update toggle buttons
        const toggleBtns = document.querySelectorAll('.sheets-docs-toggle .toggle-btn');
        toggleBtns.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.view === view);
        });
        
        // Show/hide the appropriate containers
        const spreadsheetHeader = document.getElementById('spreadsheetsViewHeader');
        const spreadsheetCards = document.getElementById('spreadsheetCards');
        const docsHeader = document.getElementById('docsViewHeader');
        const docCards = document.getElementById('docCards');
        
        if (view === 'sheets') {
            if (spreadsheetHeader) spreadsheetHeader.style.display = '';
            if (spreadsheetCards) spreadsheetCards.style.display = '';
            if (docsHeader) docsHeader.style.display = 'none';
            if (docCards) docCards.style.display = 'none';
        } else if (view === 'docs') {
            if (spreadsheetHeader) spreadsheetHeader.style.display = 'none';
            if (spreadsheetCards) spreadsheetCards.style.display = 'none';
            if (docsHeader) docsHeader.style.display = '';
            if (docCards) docCards.style.display = '';
            
            // Load docs if not already loaded
            if (appState.currentTeamId && appState.docs.length === 0) {
                loadDocsFromFirestore();
            }
        }
    }
    
    /**
     * Initialize doc cards click handlers
     */
    function initDocCards() {
        // Create Doc button
        const createDocBtn = document.getElementById('createDocBtn');
        if (createDocBtn) {
            createDocBtn.addEventListener('click', () => openCreateDocModal());
        }
        
        // Create Doc card
        const createDocCard = document.getElementById('createDocCard');
        if (createDocCard) {
            createDocCard.addEventListener('click', () => openCreateDocModal());
        }
    }
    
    /**
     * Initialize doc panel (back button, title, etc)
     */
    function initDocPanel() {
        const backBtn = document.getElementById('docBackBtn');
        if (backBtn) {
            backBtn.addEventListener('click', () => closeDocPanel());
        }
        
        // Title input - save on blur
        const titleInput = document.getElementById('docTitleInput');
        if (titleInput) {
            titleInput.addEventListener('blur', () => {
                if (appState.activeDocId) {
                    scheduleDocSave();
                }
            });
            titleInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    titleInput.blur();
                    document.getElementById('docEditor')?.focus();
                }
            });
        }
        
        // Insert Link button - focus editor and save selection before modal opens
        const insertLinkBtn = document.getElementById('insertLinkBtn');
        if (insertLinkBtn) {
            insertLinkBtn.addEventListener('click', (e) => {
                e.preventDefault();
                const editor = document.getElementById('docEditor');
                if (!editor) return;
                
                // Focus editor FIRST (like command button does)
                editor.focus();
                
                // NOW capture the range (while editor is focused)
                const selection = window.getSelection();
                if (selection && selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    // Only save if selection is inside the editor
                    if (editor.contains(range.commonAncestorContainer)) {
                        window._savedDocLinkRange = range.cloneRange();
                    } else {
                        // If not in editor, create range at end of editor
                        const newRange = document.createRange();
                        newRange.selectNodeContents(editor);
                        newRange.collapse(false);
                        window._savedDocLinkRange = newRange;
                    }
                } else {
                    // No selection, create range at end of editor
                    const newRange = document.createRange();
                    newRange.selectNodeContents(editor);
                    newRange.collapse(false);
                    window._savedDocLinkRange = newRange;
                }
                
                // Now open the modal with the saved range
                openLinkModal();
            });
        }
        
        // Export Document button
        const exportDocBtn = document.getElementById('exportDocBtn');
        if (exportDocBtn) {
            exportDocBtn.addEventListener('click', (e) => {
                e.preventDefault();
                exportDocument();
            });
        }
    }
    
    /**
     * Export document as a downloadable text file
     */
    function exportDocument() {
        const editor = document.getElementById('docEditor');
        const titleInput = document.getElementById('docTitleInput');
        
        if (!editor) {
            showToast('No document to export', 'error');
            return;
        }
        
        // Get document content as plain text
        const content = editor.innerText || editor.textContent || '';
        
        if (!content.trim()) {
            showToast('Document is empty', 'warning');
            return;
        }
        
        // Get document title for filename
        let filename = (titleInput?.value || 'Untitled').trim();
        // Sanitize filename: remove invalid characters
        filename = filename.replace(/[<>:"/\\|?*]/g, '_').substring(0, 100);
        filename = filename || 'Untitled';
        
        // Create blob and download
        const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        
        const link = document.createElement('a');
        link.href = url;
        link.download = `${filename}.txt`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        // Clean up
        URL.revokeObjectURL(url);
        
        showToast('Document exported successfully', 'success');
    }
    
    /**
     * Initialize doc editor with toolbar commands
     */
    function initDocEditor() {
        const editor = document.getElementById('docEditor');
        const toolbar = document.getElementById('docToolbar');
        
        if (!editor || !toolbar) return;
        
        // Prevent caret from entering chips on mousedown (unless dragging)
        editor.addEventListener('mousedown', (e) => {
            const chip = e.target.closest('.doc-chip');
            if (chip && !chip.classList.contains('dragging')) {
                e.preventDefault();
                // Move caret after the chip instead of inside it
                moveCaretAfterElement(chip);
            }
        });
        
        // ===================================
        // CHIP DRAG AND DROP FUNCTIONALITY
        // ===================================
        
        // Track the chip being dragged
        let draggedChip = null;
        let dropIndicator = null;
        
        // Create drop indicator element
        function createDropIndicator() {
            if (!dropIndicator) {
                dropIndicator = document.createElement('span');
                dropIndicator.className = 'chip-drop-indicator';
                dropIndicator.style.cssText = `
                    display: inline-block;
                    width: 2px;
                    height: 1.2em;
                    background: var(--accent, #007AFF);
                    vertical-align: middle;
                    margin: 0 1px;
                    border-radius: 1px;
                    pointer-events: none;
                    animation: chip-drop-blink 0.8s ease-in-out infinite;
                `;
            }
            return dropIndicator;
        }
        
        // Get the insertion point (text node and offset) at a position
        function getInsertionPoint(x, y, editor) {
            // Use caretPositionFromPoint or caretRangeFromPoint
            let range;
            if (document.caretPositionFromPoint) {
                const pos = document.caretPositionFromPoint(x, y);
                if (pos) {
                    range = document.createRange();
                    range.setStart(pos.offsetNode, pos.offset);
                    range.collapse(true);
                }
            } else if (document.caretRangeFromPoint) {
                range = document.caretRangeFromPoint(x, y);
            }
            
            if (range && editor.contains(range.startContainer)) {
                return range;
            }
            return null;
        }
        
        // Handle dragstart on chips
        editor.addEventListener('dragstart', (e) => {
            const chip = e.target.closest('.doc-chip');
            if (chip) {
                draggedChip = chip;
                chip.classList.add('dragging');
                
                // Set drag data
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/html', chip.outerHTML);
                e.dataTransfer.setData('text/plain', chip.textContent);
                
                // Semi-transparent drag image
                setTimeout(() => {
                    chip.style.opacity = '0.4';
                }, 0);
            }
        });
        
        // Handle dragover to show drop position
        editor.addEventListener('dragover', (e) => {
            if (!draggedChip) return;
            
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            // Get insertion point
            const insertionRange = getInsertionPoint(e.clientX, e.clientY, editor);
            if (insertionRange) {
                // Remove existing indicator
                const existingIndicator = editor.querySelector('.chip-drop-indicator');
                if (existingIndicator) {
                    existingIndicator.remove();
                }
                
                // Insert indicator at the caret position
                const indicator = createDropIndicator();
                insertionRange.insertNode(indicator);
            }
        });
        
        // Handle dragleave
        editor.addEventListener('dragleave', (e) => {
            // Only remove indicator if leaving the editor entirely
            if (!editor.contains(e.relatedTarget)) {
                const indicator = editor.querySelector('.chip-drop-indicator');
                if (indicator) {
                    indicator.remove();
                }
            }
        });
        
        // Handle drop
        editor.addEventListener('drop', (e) => {
            if (!draggedChip) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            // Remove drop indicator
            const indicator = editor.querySelector('.chip-drop-indicator');
            const indicatorParent = indicator?.parentNode;
            const indicatorNextSibling = indicator?.nextSibling;
            if (indicator) {
                indicator.remove();
            }
            
            // Get the insertion point
            let insertionRange = getInsertionPoint(e.clientX, e.clientY, editor);
            
            // If we had an indicator, use its position
            if (indicatorParent && indicatorParent !== draggedChip) {
                insertionRange = document.createRange();
                if (indicatorNextSibling) {
                    insertionRange.setStartBefore(indicatorNextSibling);
                } else {
                    insertionRange.setStartAfter(indicatorParent.lastChild || indicatorParent);
                }
                insertionRange.collapse(true);
            }
            
            if (insertionRange && !draggedChip.contains(insertionRange.startContainer)) {
                // Remove chip from original position
                const chipClone = draggedChip.cloneNode(true);
                chipClone.classList.remove('dragging');
                chipClone.style.opacity = '';
                chipClone.setAttribute('draggable', 'true');
                
                // Insert at new position
                insertionRange.insertNode(chipClone);
                
                // Add a zero-width space after the chip for caret positioning
                const spacer = document.createTextNode('\\u200B');
                if (chipClone.nextSibling) {
                    chipClone.parentNode.insertBefore(spacer, chipClone.nextSibling);
                } else {
                    chipClone.parentNode.appendChild(spacer);
                }
                
                // Remove original chip
                draggedChip.remove();
                
                // Mark as dirty and schedule save
                appState.isDocDirty = true;
                scheduleDocSave();
            }
            
            // Reset drag state
            if (draggedChip) {
                draggedChip.classList.remove('dragging');
                draggedChip.style.opacity = '';
            }
            draggedChip = null;
        });
        
        // Handle dragend (cleanup)
        editor.addEventListener('dragend', (e) => {
            // Remove any leftover indicators
            const indicator = editor.querySelector('.chip-drop-indicator');
            if (indicator) {
                indicator.remove();
            }
            
            // Reset dragged chip
            if (draggedChip) {
                draggedChip.classList.remove('dragging');
                draggedChip.style.opacity = '';
                draggedChip = null;
            }
        });
        
        // Toolbar button clicks
        toolbar.querySelectorAll('.toolbar-btn[data-command]').forEach(btn => {
            btn.addEventListener('click', () => {
                const command = btn.dataset.command;
                document.execCommand(command, false, null);
                editor.focus();
                updateToolbarState();
            });
        });
        
        // Editor input - schedule autosave
        editor.addEventListener('input', () => {
            appState.isDocDirty = true;
            scheduleDocSave();
        });
        
        // Editor keydown - keyboard shortcuts
        editor.addEventListener('keydown', (e) => {
            // Handle Backspace/Delete for chips and embeds
            if (e.key === 'Backspace' || e.key === 'Delete') {
                const selection = window.getSelection();
                if (selection.rangeCount === 0) return;
                
                const range = selection.getRangeAt(0);
                
                // Check if caret is at a position adjacent to a chip/embed
                if (range.collapsed) {
                    const container = range.startContainer;
                    const offset = range.startOffset;
                    
                    // For Backspace: check element before caret
                    if (e.key === 'Backspace') {
                        let prevElement = null;
                        
                        if (container.nodeType === Node.TEXT_NODE) {
                            // If at start of text node, check previous sibling
                            if (offset === 0) {
                                prevElement = container.previousSibling;
                            }
                        } else if (container.nodeType === Node.ELEMENT_NODE) {
                            // Check child before offset
                            if (offset > 0) {
                                prevElement = container.childNodes[offset - 1];
                            }
                        }
                        
                        // Check if previous element is a chip or embed
                        if (prevElement) {
                            const isChip = prevElement.nodeType === Node.ELEMENT_NODE && 
                                          prevElement.classList?.contains('doc-chip');
                            const isEmbed = prevElement.nodeType === Node.ELEMENT_NODE && 
                                           prevElement.classList?.contains('doc-embed');
                            
                            if (isChip || isEmbed) {
                                e.preventDefault();
                                prevElement.remove();
                                appState.isDocDirty = true;
                                scheduleDocSave();
                                return;
                            }
                        }
                    }
                    
                    // For Delete: check element after caret
                    if (e.key === 'Delete') {
                        let nextElement = null;
                        
                        if (container.nodeType === Node.TEXT_NODE) {
                            // If at end of text node, check next sibling
                            if (offset === container.textContent.length) {
                                nextElement = container.nextSibling;
                            }
                        } else if (container.nodeType === Node.ELEMENT_NODE) {
                            // Check child at offset
                            nextElement = container.childNodes[offset];
                        }
                        
                        // Check if next element is a chip or embed
                        if (nextElement) {
                            const isChip = nextElement.nodeType === Node.ELEMENT_NODE && 
                                          nextElement.classList?.contains('doc-chip');
                            const isEmbed = nextElement.nodeType === Node.ELEMENT_NODE && 
                                           nextElement.classList?.contains('doc-embed');
                            
                            if (isChip || isEmbed) {
                                e.preventDefault();
                                nextElement.remove();
                                appState.isDocDirty = true;
                                scheduleDocSave();
                                return;
                            }
                        }
                    }
                }
            }
            
            // Handle Tab key for list indentation
            if (e.key === 'Tab') {
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    const listItem = range.startContainer.nodeType === Node.TEXT_NODE 
                        ? range.startContainer.parentElement?.closest('li')
                        : range.startContainer.closest?.('li');
                    
                    if (listItem) {
                        e.preventDefault();
                        
                        if (e.shiftKey) {
                            // Shift+Tab: Outdent - move list item to parent level
                            document.execCommand('outdent', false, null);
                        } else {
                            // Tab: Indent - make this a child of the previous sibling
                            const prevSibling = listItem.previousElementSibling;
                            if (prevSibling && prevSibling.tagName === 'LI') {
                                // Use execCommand for better browser compatibility
                                document.execCommand('indent', false, null);
                            }
                        }
                        
                        appState.isDocDirty = true;
                        scheduleDocSave();
                        return;
                    }
                }
            }
            
            if ((e.ctrlKey || e.metaKey) && !e.shiftKey) {
                switch (e.key.toLowerCase()) {
                    case 'b':
                        e.preventDefault();
                        document.execCommand('bold', false, null);
                        updateToolbarState();
                        break;
                    case 'i':
                        e.preventDefault();
                        document.execCommand('italic', false, null);
                        updateToolbarState();
                        break;
                    case 'u':
                        e.preventDefault();
                        document.execCommand('underline', false, null);
                        updateToolbarState();
                        break;
                    case 's':
                        e.preventDefault();
                        saveDocNow();
                        break;
                }
            }
        });
        
        // Update toolbar state on selection change
        document.addEventListener('selectionchange', () => {
            if (document.activeElement === editor) {
                updateToolbarState();
            }
        });
        
        // Handle paste - sanitize content
        editor.addEventListener('paste', (e) => {
            e.preventDefault();
            const text = e.clipboardData?.getData('text/plain') || '';
            document.execCommand('insertText', false, text);
        });
    }
    
    /**
     * Update toolbar button active states based on current selection
     */
    function updateToolbarState() {
        const toolbar = document.getElementById('docToolbar');
        if (!toolbar) return;
        
        toolbar.querySelectorAll('.toolbar-btn[data-command]').forEach(btn => {
            const command = btn.dataset.command;
            let isActive = false;
            
            try {
                isActive = document.queryCommandState(command);
            } catch (e) {
                // Some commands don't support queryCommandState
            }
            
            btn.classList.toggle('active', isActive);
        });
    }
    
    /**
     * Load docs from Firestore with real-time listener
     */
    async function loadDocsFromFirestore() {
        if (!appState.currentTeamId || !db || !currentAuthUser) {
            console.warn('Cannot load docs: missing team, db, or user');
            return;
        }
        
        // Clean up existing listener
        if (appState.docsUnsub) {
            appState.docsUnsub();
            appState.docsUnsub = null;
        }
        
        try {
            const { collection, query, orderBy, onSnapshot } = 
                await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
            
            const docsRef = collection(db, 'teams', appState.currentTeamId, 'docs');
            const q = query(docsRef, orderBy('updatedAt', 'desc'));
            
            // Real-time listener
            appState.docsUnsub = onSnapshot(q, (snapshot) => {
                appState.docs = [];
                snapshot.forEach(doc => {
                    appState.docs.push({ id: doc.id, ...doc.data() });
                });
                
                debugLog(`ðŸ“„ Loaded ${appState.docs.length} docs`);
                renderDocCards();
            }, (error) => {
                console.error('Error loading docs:', error);
                if (error.code === 'permission-denied') {
                    showToast("You don't have permission to view docs", 'error');
                }
            });
        } catch (error) {
            console.error('Error setting up docs listener:', error);
        }
    }
    
    /**
     * Render doc cards in the grid
     */
    function renderDocCards() {
        const container = document.getElementById('docCards');
        if (!container) return;
        
        // Keep the create card
        const createCard = container.querySelector('.create-new');
        container.innerHTML = '';
        if (createCard) container.appendChild(createCard);
        
        // Check if no docs
        if (appState.docs.length === 0) {
            const emptyState = document.createElement('div');
            emptyState.className = 'doc-empty-state';
            emptyState.innerHTML = `
                <i class="fas fa-file-lines"></i>
                <h4>No documents yet</h4>
                <p>Create your first doc to get started</p>
            `;
            container.insertBefore(emptyState, createCard);
            return;
        }
        
        // Render doc cards
        appState.docs.forEach(doc => {
            const card = buildDocCard(doc);
            container.insertBefore(card, createCard);
        });
    }
    
    /**
     * Build a doc card element
     */
    function buildDocCard(doc) {
        const card = document.createElement('div');
        card.className = 'doc-card';
        card.dataset.docId = doc.id;
        
        // Extract preview text (first 80 chars of plain text)
        const preview = (doc.contentText || '').substring(0, 80) || 'Empty document';
        
        // Format updated time
        let updatedStr = '';
        if (doc.updatedAt) {
            const updatedDate = doc.updatedAt.toDate ? doc.updatedAt.toDate() : new Date(doc.updatedAt);
            updatedStr = formatRelativeTime(updatedDate);
        }
        
        // Privacy badge
        const privateBadge = doc.visibility === 'private' 
            ? '<span class="doc-private-badge" title="Private"><i class="fas fa-lock"></i></span>'
            : '';
        
        card.innerHTML = `
            <button class="doc-card-menu-btn" title="More options">
                <i class="fas fa-ellipsis-v"></i>
            </button>
            <div class="doc-card-icon">
                <i class="fas fa-file-lines"></i>
            </div>
            <div class="doc-card-content">
                <h4 class="doc-card-title">${escapeHtml(doc.title || 'Untitled')} ${privateBadge}</h4>
                <p class="doc-card-preview">${escapeHtml(preview)}</p>
            </div>
            <div class="doc-card-meta">
                <i class="fas fa-clock"></i>
                <span>${updatedStr || 'Just now'}</span>
            </div>
        `;
        
        // Click handler - open doc
        card.addEventListener('click', (e) => {
            if (e.target.closest('.doc-card-menu-btn')) return;
            openDoc(doc.id);
        });
        
        // Menu button
        const menuBtn = card.querySelector('.doc-card-menu-btn');
        if (menuBtn) {
            menuBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                showDocContextMenu(doc, menuBtn);
            });
        }
        
        return card;
    }
    
    /**
     * Format relative time (e.g., "2 hours ago")
     */
    function formatRelativeTime(date) {
        const now = new Date();
        const diff = now - date;
        const seconds = Math.floor(diff / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);
        
        if (seconds < 60) return 'Just now';
        if (minutes < 60) return `${minutes}m ago`;
        if (hours < 24) return `${hours}h ago`;
        if (days < 7) return `${days}d ago`;
        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    }
    
    /**
     * Show context menu for doc card
     */
    function showDocContextMenu(doc, anchorEl) {
        const htmlMenu = document.getElementById('docContextMenu');
        if (!htmlMenu) return;
        
        // Store doc for handlers
        htmlMenu.dataset.docId = doc.id;
        
        // Setup action handlers (replace to remove old listeners)
        const actions = [
            { id: 'docContextMenuOpen', handler: () => { closeFloatingMenu(); openDoc(doc.id); } },
            { id: 'docContextMenuRename', handler: () => { closeFloatingMenu(); renameDoc(doc); } },
            { id: 'docContextMenuPrivacy', handler: () => { closeFloatingMenu(); openDocVisibilityModal(doc); } },
            { id: 'docContextMenuDelete', handler: () => { closeFloatingMenu(); deleteDoc(doc); } }
        ];
        
        actions.forEach(({ id, handler }) => {
            const btn = document.getElementById(id);
            if (btn) {
                const newBtn = btn.cloneNode(true);
                btn.replaceWith(newBtn);
                document.getElementById(id).addEventListener('click', handler);
            }
        });
        
        // Toggle menu using unified helper
        toggleFloatingMenu(htmlMenu, anchorEl);
    }
    
    /**
     * Open Create Doc modal
     */
    function openCreateDocModal() {
        // Modern minimal create doc modal
        const modalHTML = `
            <div class="unified-modal active" id="createDocModal" style="display: flex;">
                <div class="create-doc-modal-content">
                    <button class="create-doc-close" onclick="closeCreateDocModal()">
                        <i class="fas fa-times"></i>
                    </button>
                    <div class="create-doc-header">
                        <div class="create-doc-icon">
                            <i class="fas fa-file-lines"></i>
                        </div>
                        <h2 class="create-doc-title">New Document</h2>
                    </div>
                    <input type="text" id="newDocTitle" class="create-doc-input" placeholder="Document title" autofocus>
                    <div class="create-doc-actions">
                        <button class="btn-secondary" onclick="closeCreateDocModal()">Cancel</button>
                        <button class="btn-primary" onclick="createNewDoc()">Create</button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', modalHTML);
        
        // Focus input
        setTimeout(() => {
            document.getElementById('newDocTitle')?.focus();
        }, 100);
        
        // Enter key to create
        document.getElementById('newDocTitle')?.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                createNewDoc();
            }
        });
        
        // Click outside to close
        document.getElementById('createDocModal')?.addEventListener('click', (e) => {
            if (e.target.id === 'createDocModal') {
                closeCreateDocModal();
            }
        });
    }
    
    window.closeCreateDocModal = function() {
        const modal = document.getElementById('createDocModal');
        if (modal) modal.remove();
    };
    
    window.createNewDoc = async function() {
        const titleInput = document.getElementById('newDocTitle');
        const title = titleInput?.value.trim() || 'Untitled';
        
        if (!appState.currentTeamId || !currentAuthUser) {
            showToast('Please select a team first', 'error');
            return;
        }
        
        // RATE LIMITING: Check if user can create document
        const rateCheck = canCreateDocument();
        if (!rateCheck.allowed) {
            showToast(rateCheck.reason, 'warning', 3000);
            return;
        }
        
        try {
            const { collection, addDoc, serverTimestamp } = 
                await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
            
            const docsRef = collection(db, 'teams', appState.currentTeamId, 'docs');
            
            const docData = {
                title: title,
                contentHtml: '<p></p>',
                contentText: '',
                teamId: appState.currentTeamId,
                createdBy: currentAuthUser.uid,
                createdAt: serverTimestamp(),
                updatedAt: serverTimestamp(),
                updatedBy: currentAuthUser.uid
            };
            
            const docRef = await addDoc(docsRef, docData);
            
            // RATE LIMITING: Update rate limit state after successful creation
            rateLimitState.lastDocCreation = Date.now();
            rateLimitState.docCount++;
            
            closeCreateDocModal();
            showToast('Document created', 'success');
            
            // Open the new doc
            openDoc(docRef.id);
            
        } catch (error) {
            console.error('Error creating doc:', error);
            showToast('Failed to create document', 'error');
        }
    };
    
    /**
     * Open a doc in the editor panel
     */
    async function openDoc(docId) {
        // Save current doc if dirty
        if (appState.activeDocId && appState.isDocDirty) {
            await saveDocNow();
        }
        
        // Find doc in state
        const doc = appState.docs.find(d => d.id === docId);
        if (!doc) {
            showToast('Document not found', 'error');
            return;
        }
        
        appState.activeDocId = docId;
        appState.isDocDirty = false;
        
        // Check if current user is the owner of this doc
        const isDocOwner = doc.createdBy === currentAuthUser?.uid;
        
        // Determine if editor should be read-only
        // Read-only if: isReadOnly is true AND user is NOT the owner
        const isReadOnly = doc.isReadOnly === true && !isDocOwner;
        
        // Update panel UI
        const titleInput = document.getElementById('docTitleInput');
        const editor = document.getElementById('docEditor');
        const saveStatus = document.getElementById('docSaveStatus');
        
        if (titleInput) {
            titleInput.value = doc.title || 'Untitled';
            titleInput.readOnly = isReadOnly;
        }
        
        if (editor) {
            // SECURITY: Sanitize HTML with DOMPurify to prevent XSS
            const sanitizedHtml = typeof DOMPurify !== 'undefined' 
                ? DOMPurify.sanitize(doc.contentHtml || '<p></p>', {
                    ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'u', 's', 'a', 'ul', 'ol', 'li', 'h1', 'h2', 'h3', 'blockquote', 'code', 'pre', 'span', 'div'],
                    ALLOWED_ATTR: ['href', 'target', 'rel', 'class', 'style', 'data-task-id', 'data-spreadsheet-id', 'data-type', 'contenteditable'],
                    ALLOW_DATA_ATTR: true
                })
                : doc.contentHtml || '<p></p>';
            editor.innerHTML = sanitizedHtml;
            editor.contentEditable = !isReadOnly;
            editor.classList.toggle('read-only', isReadOnly);
        }
        
        if (saveStatus) {
            if (isReadOnly) {
                saveStatus.textContent = 'View Only';
                saveStatus.className = 'doc-save-status read-only';
            } else {
                saveStatus.textContent = 'Saved';
                saveStatus.className = 'doc-save-status';
            }
        }
        
        // Show/hide read-only indicator
        updateDocReadOnlyIndicator(isReadOnly);
        
        // Hydrate chips and embeds
        setTimeout(() => {
            hydrateDocChips();
            hydrateDocEmbeds();
        }, 100);
        
        // Show panel
        const tasksSection = document.getElementById('tasks-section');
        if (tasksSection) {
            tasksSection.classList.add('doc-open');
        }
        
        // Focus editor only if not read-only
        if (!isReadOnly) {
            setTimeout(() => editor?.focus(), 100);
        }
    }
    
    /**
     * Update read-only indicator in the doc panel header
     */
    function updateDocReadOnlyIndicator(isReadOnly) {
        // Find or create read-only badge in doc panel header
        let indicator = document.getElementById('docReadOnlyIndicator');
        const header = document.querySelector('.doc-panel-header');
        
        if (isReadOnly) {
            if (!indicator && header) {
                indicator = document.createElement('span');
                indicator.id = 'docReadOnlyIndicator';
                indicator.className = 'doc-readonly-badge';
                indicator.innerHTML = '<i class="fas fa-lock"></i> View Only';
                // Insert after title input
                const titleInput = header.querySelector('.doc-title-input');
                if (titleInput) {
                    titleInput.after(indicator);
                }
            }
            if (indicator) indicator.style.display = 'inline-flex';
        } else {
            if (indicator) indicator.style.display = 'none';
        }
    }
    
    /**
     * Close doc panel
     */
    async function closeDocPanel() {
        // Save if dirty
        if (appState.activeDocId && appState.isDocDirty) {
            await saveDocNow();
        }
        
        appState.activeDocId = null;
        appState.isDocDirty = false;
        
        // Clear save timer
        if (appState.docSaveTimer) {
            clearTimeout(appState.docSaveTimer);
            appState.docSaveTimer = null;
        }
        
        // Hide panel
        const tasksSection = document.getElementById('tasks-section');
        if (tasksSection) {
            tasksSection.classList.remove('doc-open');
        }
    }
    
    /**
     * Schedule a doc save with debounce
     */
    function scheduleDocSave() {
        // Update save status
        const saveStatus = document.getElementById('docSaveStatus');
        if (saveStatus) {
            saveStatus.textContent = 'Saving...';
            saveStatus.className = 'doc-save-status saving';
        }
        
        // Clear existing timer
        if (appState.docSaveTimer) {
            clearTimeout(appState.docSaveTimer);
        }
        
        // Schedule save after 800ms of no typing
        appState.docSaveTimer = setTimeout(() => {
            saveDocNow();
        }, 800);
    }
    
    /**
     * Save doc immediately
     */
    async function saveDocNow() {
        if (!appState.activeDocId || appState.isDocSaving) return;
        
        const editor = document.getElementById('docEditor');
        const titleInput = document.getElementById('docTitleInput');
        const saveStatus = document.getElementById('docSaveStatus');
        
        if (!editor || !titleInput) return;
        
        appState.isDocSaving = true;
        
        try {
            const { doc, updateDoc, serverTimestamp } = 
                await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
            
            const contentHtml = sanitizeDocHtml(editor.innerHTML);
            const contentText = extractPlainText(contentHtml);
            const title = titleInput.value.trim() || 'Untitled';
            
            // Size limit check (50KB for contentHtml)
            if (contentHtml.length > 50000) {
                showToast('Document too large. Please reduce content.', 'error');
                if (saveStatus) {
                    saveStatus.textContent = 'Too large';
                    saveStatus.className = 'doc-save-status error';
                }
                appState.isDocSaving = false;
                return;
            }
            
            const docRef = doc(db, 'teams', appState.currentTeamId, 'docs', appState.activeDocId);
            
            await updateDoc(docRef, {
                title: title,
                contentHtml: contentHtml,
                contentText: contentText.substring(0, 500), // Limit preview text
                updatedAt: serverTimestamp(),
                updatedBy: currentAuthUser.uid
            });
            
            appState.isDocDirty = false;
            
            if (saveStatus) {
                saveStatus.textContent = 'Saved';
                saveStatus.className = 'doc-save-status';
            }
            
            debugLog('ðŸ“„ Doc saved:', appState.activeDocId);
            
        } catch (error) {
            console.error('Error saving doc:', error);
            if (saveStatus) {
                saveStatus.textContent = "Couldn't save";
                saveStatus.className = 'doc-save-status error';
            }
            showToast('Failed to save document', 'error');
        } finally {
            appState.isDocSaving = false;
        }
    }
    
    /**
     * Sanitize HTML content - whitelist safe tags
     * Allowed: p, br, b, strong, i, em, u, a, ul, ol, li, div, span
     */
    function sanitizeDocHtml(html) {
        const temp = document.createElement('div');
        temp.innerHTML = html;
        
        // Remove script tags and event handlers
        temp.querySelectorAll('script, style, iframe, object, embed').forEach(el => el.remove());
        
        // Strip hydrated content from embeds - save only the shell with data attributes
        temp.querySelectorAll('.doc-embed').forEach(embed => {
            embed.innerHTML = ''; // Clear hydrated content
            embed.classList.remove('hydrated', 'unavailable');
        });
        
        // Strip hydrated content from chips - save only the shell with data attributes
        // BUT preserve link chip content (favicon and text)
        temp.querySelectorAll('.doc-chip').forEach(chip => {
            if (chip.dataset.chipType !== 'link') {
                chip.innerHTML = ''; // Clear hydrated content only for task/sheet chips
            }
            chip.classList.remove('hydrated', 'unavailable');
            chip.onclick = null;
        });
        
        // Process all elements
        const allElements = temp.querySelectorAll('*');
        const allowedTags = ['P', 'BR', 'B', 'STRONG', 'I', 'EM', 'U', 'A', 'UL', 'OL', 'LI', 'DIV', 'SPAN', 'H1', 'H2', 'H3', 'TABLE', 'THEAD', 'TBODY', 'TR', 'TH', 'TD', 'BUTTON', 'IMG'];
        
        allElements.forEach(el => {
            // Remove disallowed tags (keep content)
            if (!allowedTags.includes(el.tagName)) {
                const parent = el.parentNode;
                while (el.firstChild) {
                    parent.insertBefore(el.firstChild, el);
                }
                parent.removeChild(el);
                return;
            }
            
            // Check if this is a chip or embed - preserve special attributes
            const isChip = el.classList.contains('doc-chip');
            const isEmbed = el.classList.contains('doc-embed');
            const isLinkChip = isChip && el.dataset.chipType === 'link';
            
            // Remove all attributes except allowed ones
            const attrsToRemove = [];
            for (let attr of el.attributes) {
                // Links: keep href, target, rel
                if (el.tagName === 'A' && attr.name === 'href') {
                    // Validate href - only http, https, mailto
                    const href = attr.value.toLowerCase();
                    if (!href.startsWith('http://') && !href.startsWith('https://') && !href.startsWith('mailto:')) {
                        attrsToRemove.push(attr.name);
                    }
                } else if (el.tagName === 'A' && (attr.name === 'target' || attr.name === 'rel')) {
                    // Keep target and rel for links
                } 
                // Link chips: keep everything (href, class, data-chip-type, contenteditable)
                else if (isLinkChip && (attr.name === 'class' || attr.name === 'href' || attr.name === 'target' || 
                                         attr.name === 'rel' || attr.name === 'data-chip-type' || attr.name === 'contenteditable')) {
                    // Keep these
                }
                // Images in link chips: keep src, class, onerror
                else if (el.tagName === 'IMG' && el.parentElement?.classList?.contains('doc-chip') && 
                         (attr.name === 'src' || attr.name === 'class' || attr.name === 'onerror' || attr.name === 'alt')) {
                    // Keep these
                } 
                // Chips: keep class, contenteditable, data-chip-type, data-id
                else if (isChip && (attr.name === 'class' || attr.name === 'contenteditable' || 
                                     attr.name === 'data-chip-type' || attr.name === 'data-id')) {
                    // Keep these
                } 
                // Embeds: keep class, data-embed-type, data-id
                else if (isEmbed && (attr.name === 'class' || attr.name === 'data-embed-type' || attr.name === 'data-id')) {
                    // Keep these
                }
                else {
                    attrsToRemove.push(attr.name);
                }
            }
            attrsToRemove.forEach(name => el.removeAttribute(name));
            
            // Ensure links open in new tab safely
            if (el.tagName === 'A') {
                el.setAttribute('target', '_blank');
                el.setAttribute('rel', 'noopener noreferrer');
            }
        });
        
        return temp.innerHTML;
    }
    
    /**
     * Extract plain text from HTML
     */
    function extractPlainText(html) {
        const temp = document.createElement('div');
        temp.innerHTML = html;
        return temp.textContent || temp.innerText || '';
    }
    
    /**
     * Rename a doc
     */
    async function renameDoc(doc) {
        const newTitle = await showInputModal('Enter new title:', doc.title || 'Untitled', {
            title: 'Rename Document'
        });
        if (newTitle === null || newTitle.trim() === '') return;
        
        try {
            const { doc: docRef, updateDoc, serverTimestamp } = 
                await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
            
            const ref = docRef(db, 'teams', appState.currentTeamId, 'docs', doc.id);
            await updateDoc(ref, {
                title: newTitle.trim(),
                updatedAt: serverTimestamp(),
                updatedBy: currentAuthUser.uid
            });
            
            showToast('Document renamed', 'success');
        } catch (error) {
            console.error('Error renaming doc:', error);
            showToast('Failed to rename document', 'error');
        }
    }
    
    /**
     * Delete a doc
     */
    async function deleteDoc(doc) {
        const confirmed = await showConfirmModal(`Delete "${doc.title || 'Untitled'}"? This cannot be undone.`, {
            title: 'Delete Document',
            confirmText: 'Delete',
            type: 'danger'
        });
        if (!confirmed) return;
        
        try {
            const { doc: docRef, deleteDoc: delDoc } = 
                await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
            
            const ref = docRef(db, 'teams', appState.currentTeamId, 'docs', doc.id);
            await delDoc(ref);
            
            showToast('Document deleted', 'success');
        } catch (error) {
            console.error('Error deleting doc:', error);
            showToast('Failed to delete document', 'error');
        }
    }
    
    /**
     * Helper: Move caret immediately after an element
     * Ensures typing happens outside the element, not inside it
     */
    function moveCaretAfterElement(element) {
        if (!element) return;
        
        const editor = document.getElementById('docEditor');
        if (!editor) return;
        
        // Ensure there's a text node after the element
        let nextNode = element.nextSibling;
        if (!nextNode || nextNode.nodeType !== Node.TEXT_NODE) {
            // Insert a zero-width space after the element
            const textNode = document.createTextNode('\u200B');
            if (element.nextSibling) {
                element.parentNode.insertBefore(textNode, element.nextSibling);
            } else {
                element.parentNode.appendChild(textNode);
            }
            nextNode = textNode;
        }
        
        // Move caret to after the element
        const selection = window.getSelection();
        const range = document.createRange();
        range.setStartAfter(element);
        range.setEndAfter(element);
        selection.removeAllRanges();
        selection.addRange(range);
    }
    
    /**
     * Open link insertion modal
     */
    function openLinkModal() {
        // CRITICAL: Use the range saved on mousedown (before focus was lost)
        // This is already captured by the button's mousedown handler
        const editor = document.getElementById('docEditor');
        let range = window._savedDocLinkRange;
        
        // If no saved range from mousedown, try current selection
        if (!range) {
            const selection = window.getSelection();
            if (selection && selection.rangeCount > 0) {
                const currentRange = selection.getRangeAt(0);
                if (editor && editor.contains(currentRange.commonAncestorContainer)) {
                    range = currentRange.cloneRange();
                }
            }
        }
        
        // If still no valid range, create one at the end
        if (!range && editor) {
            range = document.createRange();
            range.selectNodeContents(editor);
            range.collapse(false); // Collapse to end
        }
        
        // Get selected text to pre-fill
        let selectedText = '';
        if (range && !range.collapsed) {
            selectedText = range.toString().trim();
        }
        
        const modalHTML = `
            <div class="doc-link-modal" id="docLinkModal">
                <div class="doc-link-modal-header">
                    <h4>Insert Link</h4>
                    <button class="doc-link-modal-close" onclick="closeLinkModal()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <input type="text" id="linkTextInput" placeholder="Link text" value="${escapeHtml(selectedText)}" autofocus>
                <input type="text" id="linkUrlInput" placeholder="https://example.com">
                <div class="doc-link-modal-actions">
                    <button class="btn-secondary" onclick="closeLinkModal()">Cancel</button>
                    <button class="btn-primary" onclick="insertLink()">Insert</button>
                </div>
            </div>
            <div class="modal-overlay" id="linkModalOverlay" onclick="closeLinkModal()"></div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', modalHTML);
        
        // Store range for later
        window._savedDocLinkRange = range;
        
        // Focus text input
        setTimeout(() => {
            const textInput = document.getElementById('linkTextInput');
            textInput?.focus();
            // Select all if pre-filled
            if (selectedText) {
                textInput?.select();
            }
        }, 100);
        
        // Tab from text to URL input, Enter to insert from both
        document.getElementById('linkTextInput')?.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                insertLink();
            } else if (e.key === 'Tab' && !e.shiftKey) {
                e.preventDefault();
                document.getElementById('linkUrlInput')?.focus();
            }
        });
        
        document.getElementById('linkUrlInput')?.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                insertLink();
            }
        });
    }
    
    window.closeLinkModal = function() {
        document.getElementById('docLinkModal')?.remove();
        document.getElementById('linkModalOverlay')?.remove();
        window._savedDocLinkRange = null;
    };
    
    window.insertLink = function() {
        const textInput = document.getElementById('linkTextInput');
        const urlInput = document.getElementById('linkUrlInput');
        const linkText = textInput?.value.trim() || '';
        let url = urlInput?.value.trim() || '';

        const savedRange = window._savedDocLinkRange;
        if (!savedRange) {
            console.error('[insertLink] Missing saved range for link insertion');
            return;
        }
        
        if (!url || !linkText) {
            closeLinkModal();
            return;
        }
        
        // Normalize and validate URL (allow http/https/mailto)
        const normalizeUrl = (raw) => {
            if (!raw) return '';
            const trimmed = raw.trim();
            if (trimmed.toLowerCase().startsWith('mailto:')) return trimmed;
            if (!/^https?:\/\//i.test(trimmed)) return `https://${trimmed}`;
            return trimmed;
        };
        const isValidLink = (normalized) => {
            if (!normalized) return false;
            if (normalized.toLowerCase().startsWith('mailto:')) {
                const email = normalized.slice(7);
                return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
            }
            try {
                const parsed = new URL(normalized);
                return parsed.protocol === 'http:' || parsed.protocol === 'https:';
            } catch {
                return false;
            }
        };

        url = normalizeUrl(url);
        if (!isValidLink(url)) {
            showToast('Please enter a valid link (http, https, or mailto).', 'error');
            urlInput?.focus();
            return;
        }
        
        const editor = document.getElementById('docEditor');
        if (!editor) {
            closeLinkModal();
            window._savedDocLinkRange = null;
            return;
        }
        
        // Get favicon URL
        let faviconUrl = '';
        try {
            const urlObj = new URL(url);
            faviconUrl = `https://www.google.com/s2/favicons?domain=${urlObj.hostname}&sz=32`;
        } catch (e) {
            console.warn('Invalid URL for favicon:', url);
        }
        
        editor.focus();

        // Restore selection from saved range - MUST happen after focus
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(savedRange);

        // Build link chip element and insert via the saved range
        const chip = document.createElement('a');
        chip.setAttribute('href', url);
        chip.setAttribute('target', '_blank');
        chip.setAttribute('rel', 'noopener noreferrer');
        chip.className = 'doc-chip hydrated';
        chip.dataset.chipType = 'link';
        chip.contentEditable = 'false';
        chip.draggable = true;

        if (faviconUrl) {
            const icon = document.createElement('img');
            icon.className = 'chip-favicon';
            icon.src = faviconUrl;
            icon.alt = '';
            icon.onerror = function() {
                this.style.display = 'none';
            };
            chip.appendChild(icon);
        }

        chip.appendChild(document.createTextNode(linkText));

        // Insert at the saved range and keep a spacer for continued typing
        savedRange.deleteContents();
        savedRange.insertNode(chip);
        const spacer = document.createTextNode('\u200B');
        chip.parentNode?.insertBefore(spacer, chip.nextSibling);
        moveCaretAfterElement(chip);
        
        appState.isDocDirty = true;
        scheduleDocSave();

        // Clear saved ranges and close modal after insertion
        window._savedDocLinkRange = null;
        closeLinkModal();
    };
    
    // ===================================
    // DOC INTEGRATIONS: FORMAT DROPDOWN, COMMAND POPOVER, CHIPS, EMBEDS, TAGS
    // ===================================
    
    /**
     * Initialize format dropdown (heading selector)
     */
    function initDocFormatDropdown() {
        const trigger = document.getElementById('docFormatTrigger');
        const dropdown = document.getElementById('docFormatDropdown');
        const label = document.getElementById('docFormatLabel');
        
        if (!trigger || !dropdown) return;
        
        // Store saved selection for format dropdown
        let savedFormatRange = null;
        
        // Helper to check if range is inside editor
        function isRangeInsideEditor(range, editor) {
            if (!range || !editor) return false;
            const container = range.commonAncestorContainer;
            return editor.contains(container.nodeType === Node.TEXT_NODE ? container.parentNode : container);
        }
        
        // Toggle dropdown and save selection
        trigger.addEventListener('click', (e) => {
            e.stopPropagation();
            const editor = document.getElementById('docEditor');
            
            // Save current selection if inside editor
            const sel = window.getSelection();
            if (sel.rangeCount > 0) {
                const range = sel.getRangeAt(0);
                if (isRangeInsideEditor(range, editor)) {
                    savedFormatRange = range.cloneRange();
                }
            }
            
            dropdown.classList.toggle('visible');
        });
        
        // Close on outside click (clear saved range)
        document.addEventListener('click', (e) => {
            if (!dropdown.contains(e.target) && !trigger.contains(e.target)) {
                dropdown.classList.remove('visible');
                savedFormatRange = null;
            }
        });
        
        // Format options
        dropdown.querySelectorAll('.doc-format-option').forEach(option => {
            option.addEventListener('click', () => {
                const format = option.dataset.format;
                const editor = document.getElementById('docEditor');
                
                if (!editor) return;
                
                // Restore saved selection
                if (savedFormatRange) {
                    const sel = window.getSelection();
                    sel.removeAllRanges();
                    sel.addRange(savedFormatRange);
                }
                
                editor.focus();
                
                // Apply formatting
                let success = false;
                try {
                    success = document.execCommand('formatBlock', false, format === 'p' ? '<p>' : `<${format}>`);
                } catch (e) {
                    console.warn('Format command failed:', e);
                }
                
                // Update label only if command succeeded
                if (success && label) {
                    if (format === 'p') {
                        label.textContent = 'Normal';
                    } else {
                        label.textContent = `Heading ${format.charAt(1)}`;
                    }
                }
                
                dropdown.classList.remove('visible');
                savedFormatRange = null;
                appState.isDocDirty = true;
                scheduleDocSave();
            });
        });
    }
    
    /**
     * Initialize command popover (/ trigger for references, embeds, etc.)
     */
    function initDocCommandPopover() {
        const editor = document.getElementById('docEditor');
        const popover = document.getElementById('docCommandPopover');
        const commandBtn = document.getElementById('insertCommandBtn');
        
        if (!editor || !popover) return;
        
        // Clear any existing state
        window._commandRange = null;
        window._commandTriggerInfo = null;
        window._slashInsertRange = null;
        window._referenceInsertRange = null; // Dedicated range for reference picker modal
        
        // Show popover on / key
        editor.addEventListener('keydown', (e) => {
            if (e.key === '/') {
                // Store the range BEFORE the slash is typed (we'll capture after with keyup)
                const sel = window.getSelection();
                if (sel.rangeCount > 0) {
                    window._preSlashRange = sel.getRangeAt(0).cloneRange();
                }
            } else if (e.key === 'Escape') {
                hideCommandPopover();
            }
        });
        
        editor.addEventListener('keyup', (e) => {
            if (e.key === '/') {
                // After the slash is typed, store the exact range (pointing at the slash location)
                const sel = window.getSelection();
                if (sel.rangeCount > 0) {
                    // The caret is now AFTER the slash
                    window._slashInsertRange = sel.getRangeAt(0).cloneRange();
                }
                showCommandPopover('slash');
            }
        });
        
        // Also show on button click
        if (commandBtn) {
            commandBtn.addEventListener('click', (e) => {
                e.preventDefault();
                // Focus editor and capture current selection
                editor.focus();
                const sel = window.getSelection();
                if (sel.rangeCount > 0) {
                    window._commandRange = sel.getRangeAt(0).cloneRange();
                }
                showCommandPopover('button');
            });
        }
        
        /**
         * Show the command popover anchored to the caret position
         */
        function showCommandPopover(triggerType) {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            
            const range = selection.getRangeAt(0);
            
            // Store range for later use (DO NOT CLEAR until action completes)
            window._commandRange = range.cloneRange();
            window._commandTriggerInfo = {
                type: triggerType,
                timestamp: Date.now(),
                editorId: 'docEditor'
            };
            
            // Get caret position in viewport
            const caretRect = range.getBoundingClientRect();
            
            // Use the unified floating menu helper for proper positioning
            openFloatingMenu(popover, caretRect, {
                margin: 10,
                onClose: () => {
                    // Clear state when closed via click-away or Escape
                    window._commandRange = null;
                    window._commandTriggerInfo = null;
                    window._slashInsertRange = null;
                }
            });
        }
        
        /**
         * Remove the slash character that triggered the popover
         */
        function removeSlashAtTrigger() {
            if (!window._slashInsertRange) return;
            
            const range = window._slashInsertRange;
            const editor = document.getElementById('docEditor');
            if (!editor) return;
            
            try {
                // Focus editor and restore selection
                editor.focus();
                
                // The range points to where the caret was AFTER typing '/'
                // We need to select and delete the '/' character before the caret
                const container = range.startContainer;
                const offset = range.startOffset;
                
                if (container.nodeType === Node.TEXT_NODE && offset > 0) {
                    // Check if the character before caret is '/'
                    const text = container.textContent;
                    if (text.charAt(offset - 1) === '/') {
                        // Create range to select the slash
                        const deleteRange = document.createRange();
                        deleteRange.setStart(container, offset - 1);
                        deleteRange.setEnd(container, offset);
                        deleteRange.deleteContents();
                        
                        // Update stored command range to point to same spot (now without slash)
                        if (window._commandRange) {
                            const newRange = document.createRange();
                            newRange.setStart(container, Math.max(0, offset - 1));
                            newRange.setEnd(container, Math.max(0, offset - 1));
                            window._commandRange = newRange;
                        }
                    }
                }
            } catch (e) {
                console.warn('Could not remove slash:', e);
            }
            
            // Clear slash range
            window._slashInsertRange = null;
        }
        
        /**
         * Hide the command popover and optionally clear state
         */
        function hideCommandPopover(clearState = false) {
            // Use the unified close if this popover is active
            if (floatingMenuState.activeMenu === popover) {
                closeFloatingMenu();
            } else {
                popover.style.display = 'none';
            }
            
            // Only clear state when explicitly requested (after action completes or on cancel)
            if (clearState) {
                window._commandRange = null;
                window._commandTriggerInfo = null;
                window._slashInsertRange = null;
            }
        }
        
        // Command option clicks
        popover.querySelectorAll('.command-option').forEach(option => {
            option.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                const command = option.dataset.command;
                
                // CRITICAL: Save the range to dedicated variable BEFORE any other operations
                // This ensures the range survives modal interactions
                if (window._commandRange) {
                    window._referenceInsertRange = window._commandRange.cloneRange();
                }
                
                // Remove slash if triggered by '/' key
                if (window._commandTriggerInfo?.type === 'slash') {
                    removeSlashAtTrigger();
                }
                
                // Hide popover but DO NOT clear the stored range yet
                hideCommandPopover(false);
                
                // Execute command
                switch (command) {
                    case 'task-ref':
                        openReferencePickerModal('task');
                        break;
                    case 'sheet-ref':
                        openReferencePickerModal('sheet');
                        break;
                    case 'sheet-embed':
                        openReferencePickerModal('sheet-embed');
                        break;
                    // convert-tasks feature removed
                }
            });
        });
        
        // Scroll handler: hide popover if caret scrolls out of view
        const editorContainer = document.querySelector('.doc-panel-body');
        if (editorContainer) {
            editorContainer.addEventListener('scroll', () => {
                if (popover.style.display !== 'none' && window._commandRange) {
                    try {
                        const caretRect = window._commandRange.getBoundingClientRect();
                        const containerRect = editorContainer.getBoundingClientRect();
                        
                        // If caret scrolled out of view, hide popover
                        if (caretRect.top < containerRect.top || caretRect.bottom > containerRect.bottom) {
                            hideCommandPopover(true);
                        }
                    } catch (e) {
                        hideCommandPopover(true);
                    }
                }
            });
        }
        
        // Make hideCommandPopover accessible for external calls
        window._hideCommandPopover = hideCommandPopover;
    }
    
    /**
     * Initialize emoji picker for doc editor (triggered by '#' key)
     */
    function initDocEmojiPicker() {
        const editor = document.getElementById('docEditor');
        const popover = document.getElementById('docEmojiPopover');
        const searchInput = document.getElementById('docEmojiSearch');
        const emojiGrid = document.getElementById('docEmojiGrid');
        const categoryTabs = document.getElementById('emojiCategoryTabs');
        
        if (!editor || !popover || !emojiGrid) return;
        
        // Emoji data organized by category
        const emojiData = {
            smileys: ['ðŸ˜€', 'ðŸ˜ƒ', 'ðŸ˜„', 'ðŸ˜', 'ðŸ˜†', 'ðŸ˜…', 'ðŸ¤£', 'ðŸ˜‚', 'ðŸ™‚', 'ðŸ™ƒ', 'ðŸ˜‰', 'ðŸ˜Š', 'ðŸ˜‡', 'ðŸ¥°', 'ðŸ˜', 'ðŸ¤©', 'ðŸ˜˜', 'ðŸ˜—', 'ðŸ˜š', 'ðŸ˜™', 'ðŸ¥²', 'ðŸ˜‹', 'ðŸ˜›', 'ðŸ˜œ', 'ðŸ¤ª', 'ðŸ˜', 'ðŸ¤‘', 'ðŸ¤—', 'ðŸ¤­', 'ðŸ¤«', 'ðŸ¤”', 'ðŸ¤', 'ðŸ¤¨', 'ðŸ˜', 'ðŸ˜‘', 'ðŸ˜¶', 'ðŸ˜', 'ðŸ˜’', 'ðŸ™„', 'ðŸ˜¬', 'ðŸ¤¥', 'ðŸ˜Œ', 'ðŸ˜”', 'ðŸ˜ª', 'ðŸ¤¤', 'ðŸ˜´', 'ðŸ˜·', 'ðŸ¤’', 'ðŸ¤•', 'ðŸ¤¢', 'ðŸ¤®', 'ðŸ¤§', 'ðŸ¥µ', 'ðŸ¥¶', 'ðŸ¥´', 'ðŸ˜µ', 'ðŸ¤¯', 'ðŸ¤ ', 'ðŸ¥³', 'ðŸ¥¸', 'ðŸ˜Ž', 'ðŸ¤“', 'ðŸ§', 'ðŸ˜•', 'ðŸ˜Ÿ', 'ðŸ™', 'â˜¹ï¸', 'ðŸ˜®', 'ðŸ˜¯', 'ðŸ˜²', 'ðŸ˜³', 'ðŸ¥º', 'ðŸ˜¦', 'ðŸ˜§', 'ðŸ˜¨', 'ðŸ˜°', 'ðŸ˜¥', 'ðŸ˜¢', 'ðŸ˜­', 'ðŸ˜±', 'ðŸ˜–', 'ðŸ˜£', 'ðŸ˜ž', 'ðŸ˜“', 'ðŸ˜©', 'ðŸ˜«', 'ðŸ¥±', 'ðŸ˜¤', 'ðŸ˜¡', 'ðŸ˜ ', 'ðŸ¤¬', 'ðŸ˜ˆ', 'ðŸ‘¿', 'ðŸ’€', 'â˜ ï¸', 'ðŸ’©', 'ðŸ¤¡', 'ðŸ‘¹', 'ðŸ‘º', 'ðŸ‘»', 'ðŸ‘½', 'ðŸ‘¾', 'ðŸ¤–'],
            people: ['ðŸ‘‹', 'ðŸ¤š', 'ðŸ–ï¸', 'âœ‹', 'ðŸ––', 'ðŸ‘Œ', 'ðŸ¤Œ', 'ðŸ¤', 'âœŒï¸', 'ðŸ¤ž', 'ðŸ¤Ÿ', 'ðŸ¤˜', 'ðŸ¤™', 'ðŸ‘ˆ', 'ðŸ‘‰', 'ðŸ‘†', 'ðŸ–•', 'ðŸ‘‡', 'â˜ï¸', 'ðŸ‘', 'ðŸ‘Ž', 'âœŠ', 'ðŸ‘Š', 'ðŸ¤›', 'ðŸ¤œ', 'ðŸ‘', 'ðŸ™Œ', 'ðŸ‘', 'ðŸ¤²', 'ðŸ¤', 'ðŸ™', 'âœï¸', 'ðŸ’…', 'ðŸ¤³', 'ðŸ’ª', 'ðŸ¦¾', 'ðŸ¦¿', 'ðŸ¦µ', 'ðŸ¦¶', 'ðŸ‘‚', 'ðŸ¦»', 'ðŸ‘ƒ', 'ðŸ§ ', 'ðŸ«€', 'ðŸ«', 'ðŸ¦·', 'ðŸ¦´', 'ðŸ‘€', 'ðŸ‘ï¸', 'ðŸ‘…', 'ðŸ‘„', 'ðŸ‘¶', 'ðŸ§’', 'ðŸ‘¦', 'ðŸ‘§', 'ðŸ§‘', 'ðŸ‘±', 'ðŸ‘¨', 'ðŸ§”', 'ðŸ‘©', 'ðŸ§“', 'ðŸ‘´', 'ðŸ‘µ', 'ðŸ™', 'ðŸ™Ž', 'ðŸ™…', 'ðŸ™†', 'ðŸ’', 'ðŸ™‹', 'ðŸ§', 'ðŸ™‡', 'ðŸ¤¦', 'ðŸ¤·', 'ðŸ‘®', 'ðŸ•µï¸', 'ðŸ’‚', 'ðŸ¥·', 'ðŸ‘·', 'ðŸ¤´', 'ðŸ‘¸', 'ðŸ‘³', 'ðŸ‘²', 'ðŸ§•', 'ðŸ¤µ', 'ðŸ‘°', 'ðŸ¤°', 'ðŸ¤±', 'ðŸ‘¼', 'ðŸŽ…', 'ðŸ¤¶', 'ðŸ¦¸', 'ðŸ¦¹', 'ðŸ§™', 'ðŸ§š', 'ðŸ§›', 'ðŸ§œ', 'ðŸ§', 'ðŸ§ž', 'ðŸ§Ÿ', 'ðŸ’†', 'ðŸ’‡', 'ðŸš¶', 'ðŸ§', 'ðŸ§Ž', 'ðŸƒ', 'ðŸ’ƒ', 'ðŸ•º', 'ðŸ•´ï¸', 'ðŸ‘¯', 'ðŸ§–', 'ðŸ§—', 'ðŸ¤¸', 'ðŸŒï¸', 'ðŸ‡', 'â›·ï¸', 'ðŸ‚', 'ðŸ‹ï¸', 'ðŸ¤¼', 'ðŸ¤½', 'ðŸ¤¾', 'ðŸ¤º', 'â›¹ï¸', 'ðŸŠ', 'ðŸš£', 'ðŸ§˜', 'ðŸ›€', 'ðŸ›Œ'],
            nature: ['ðŸ¶', 'ðŸ±', 'ðŸ­', 'ðŸ¹', 'ðŸ°', 'ðŸ¦Š', 'ðŸ»', 'ðŸ¼', 'ðŸ»â€â„ï¸', 'ðŸ¨', 'ðŸ¯', 'ðŸ¦', 'ðŸ®', 'ðŸ·', 'ðŸ½', 'ðŸ¸', 'ðŸµ', 'ðŸ™ˆ', 'ðŸ™‰', 'ðŸ™Š', 'ðŸ’', 'ðŸ”', 'ðŸ§', 'ðŸ¦', 'ðŸ¤', 'ðŸ£', 'ðŸ¥', 'ðŸ¦†', 'ðŸ¦…', 'ðŸ¦‰', 'ðŸ¦‡', 'ðŸº', 'ðŸ—', 'ðŸ´', 'ðŸ¦„', 'ðŸ', 'ðŸª±', 'ðŸ›', 'ðŸ¦‹', 'ðŸŒ', 'ðŸž', 'ðŸœ', 'ðŸª°', 'ðŸª²', 'ðŸª³', 'ðŸ¦Ÿ', 'ðŸ¦—', 'ðŸ•·ï¸', 'ðŸ•¸ï¸', 'ðŸ¦‚', 'ðŸ¢', 'ðŸ', 'ðŸ¦Ž', 'ðŸ¦–', 'ðŸ¦•', 'ðŸ™', 'ðŸ¦‘', 'ðŸ¦', 'ðŸ¦ž', 'ðŸ¦€', 'ðŸ¡', 'ðŸ ', 'ðŸŸ', 'ðŸ¬', 'ðŸ³', 'ðŸ‹', 'ðŸ¦ˆ', 'ðŸŠ', 'ðŸ…', 'ðŸ†', 'ðŸ¦“', 'ðŸ¦', 'ðŸ¦§', 'ðŸ¦£', 'ðŸ˜', 'ðŸ¦›', 'ðŸ¦', 'ðŸª', 'ðŸ«', 'ðŸ¦’', 'ðŸ¦˜', 'ðŸ¦¬', 'ðŸƒ', 'ðŸ‚', 'ðŸ„', 'ðŸŽ', 'ðŸ–', 'ðŸ', 'ðŸ‘', 'ðŸ¦™', 'ðŸ', 'ðŸ¦Œ', 'ðŸ•', 'ðŸ©', 'ðŸ¦®', 'ðŸ•â€ðŸ¦º', 'ðŸˆ', 'ðŸˆâ€â¬›', 'ðŸª¶', 'ðŸ“', 'ðŸ¦ƒ', 'ðŸ¦¤', 'ðŸ¦š', 'ðŸ¦œ', 'ðŸ¦¢', 'ðŸ¦©', 'ðŸ•Šï¸', 'ðŸ‡', 'ðŸ¦', 'ðŸ¦¨', 'ðŸ¦¡', 'ðŸ¦«', 'ðŸ¦¦', 'ðŸ¦¥', 'ðŸ', 'ðŸ€', 'ðŸ¿ï¸', 'ðŸ¦”', 'ðŸŒµ', 'ðŸŽ„', 'ðŸŒ²', 'ðŸŒ³', 'ðŸŒ´', 'ðŸªµ', 'ðŸŒ±', 'ðŸŒ¿', 'â˜˜ï¸', 'ðŸ€', 'ðŸŽ', 'ðŸª´', 'ðŸŽ‹', 'ðŸƒ', 'ðŸ‚', 'ðŸ', 'ðŸªº', 'ðŸª¹', 'ðŸ„', 'ðŸš', 'ðŸª¸', 'ðŸª¨', 'ðŸŒ¾', 'ðŸ’', 'ðŸŒ·', 'ðŸŒ¹', 'ðŸ¥€', 'ðŸŒº', 'ðŸŒ¸', 'ðŸŒ¼', 'ðŸŒ»', 'ðŸŒž', 'ðŸŒ', 'ðŸŒ›', 'ðŸŒœ', 'ðŸŒš', 'ðŸŒ•', 'ðŸŒ–', 'ðŸŒ—', 'ðŸŒ˜', 'ðŸŒ‘', 'ðŸŒ’', 'ðŸŒ“', 'ðŸŒ”', 'ðŸŒ™', 'ðŸŒŽ', 'ðŸŒ', 'ðŸŒ', 'ðŸª', 'ðŸ’«', 'â­', 'ðŸŒŸ', 'âœ¨', 'âš¡', 'â˜„ï¸', 'ðŸ’¥', 'ðŸ”¥', 'ðŸŒªï¸', 'ðŸŒˆ', 'â˜€ï¸', 'ðŸŒ¤ï¸', 'â›…', 'ðŸŒ¥ï¸', 'â˜ï¸', 'ðŸŒ¦ï¸', 'ðŸŒ§ï¸', 'â›ˆï¸', 'ðŸŒ©ï¸', 'ðŸŒ¨ï¸', 'â„ï¸', 'â˜ƒï¸', 'â›„', 'ðŸŒ¬ï¸', 'ðŸ’¨', 'ðŸ’§', 'ðŸ’¦', 'ðŸŒŠ'],
            food: ['ðŸ', 'ðŸŽ', 'ðŸ', 'ðŸŠ', 'ðŸ‹', 'ðŸŒ', 'ðŸ‰', 'ðŸ‡', 'ðŸ“', 'ðŸ«', 'ðŸˆ', 'ðŸ’', 'ðŸ‘', 'ðŸ¥­', 'ðŸ', 'ðŸ¥¥', 'ðŸ¥', 'ðŸ…', 'ðŸ†', 'ðŸ¥‘', 'ðŸ¥¦', 'ðŸ¥¬', 'ðŸ¥’', 'ðŸŒ¶ï¸', 'ðŸ«‘', 'ðŸŒ½', 'ðŸ¥•', 'ðŸ«’', 'ðŸ§„', 'ðŸ§…', 'ðŸ¥”', 'ðŸ ', 'ðŸ¥', 'ðŸ¥¯', 'ðŸž', 'ðŸ¥–', 'ðŸ¥¨', 'ðŸ§€', 'ðŸ¥š', 'ðŸ³', 'ðŸ§ˆ', 'ðŸ¥ž', 'ðŸ§‡', 'ðŸ¥“', 'ðŸ¥©', 'ðŸ—', 'ðŸ–', 'ðŸ¦´', 'ðŸŒ­', 'ðŸ”', 'ðŸŸ', 'ðŸ•', 'ðŸ«“', 'ðŸ¥ª', 'ðŸ¥™', 'ðŸ§†', 'ðŸŒ®', 'ðŸŒ¯', 'ðŸ«”', 'ðŸ¥—', 'ðŸ¥˜', 'ðŸ«•', 'ðŸ', 'ðŸœ', 'ðŸ²', 'ðŸ›', 'ðŸ£', 'ðŸ±', 'ðŸ¥Ÿ', 'ðŸ¦ª', 'ðŸ¤', 'ðŸ™', 'ðŸš', 'ðŸ˜', 'ðŸ¥', 'ðŸ¥ ', 'ðŸ¥®', 'ðŸ¢', 'ðŸ¡', 'ðŸ§', 'ðŸ¨', 'ðŸ¦', 'ðŸ¥§', 'ðŸ§', 'ðŸ°', 'ðŸŽ‚', 'ðŸ®', 'ðŸ­', 'ðŸ¬', 'ðŸ«', 'ðŸ¿', 'ðŸ©', 'ðŸª', 'ðŸŒ°', 'ðŸ¥œ', 'ðŸ¯', 'ðŸ¥›', 'ðŸ¼', 'ðŸ«–', 'â˜•', 'ðŸµ', 'ðŸ§ƒ', 'ðŸ¥¤', 'ðŸ§‹', 'ðŸ¶', 'ðŸº', 'ðŸ»', 'ðŸ¥‚', 'ðŸ·', 'ðŸ¥ƒ', 'ðŸ¸', 'ðŸ¹', 'ðŸ§‰', 'ðŸ¾', 'ðŸ§Š', 'ðŸ¥„', 'ðŸ´', 'ðŸ½ï¸', 'ðŸ¥£', 'ðŸ¥¡', 'ðŸ¥¢', 'ðŸ§‚'],
            activities: ['âš½', 'ðŸ€', 'ðŸˆ', 'âš¾', 'ðŸ¥Ž', 'ðŸŽ¾', 'ðŸ', 'ðŸ‰', 'ðŸ¥', 'ðŸŽ±', 'ðŸª€', 'ðŸ“', 'ðŸ¸', 'ðŸ’', 'ðŸ‘', 'ðŸ¥', 'ðŸ', 'ðŸªƒ', 'ðŸ¥…', 'â›³', 'ðŸª', 'ðŸ¹', 'ðŸŽ£', 'ðŸ¤¿', 'ðŸ¥Š', 'ðŸ¥‹', 'ðŸŽ½', 'ðŸ›¹', 'ðŸ›¼', 'ðŸ›·', 'â›¸ï¸', 'ðŸ¥Œ', 'ðŸŽ¿', 'â›·ï¸', 'ðŸ‚', 'ðŸª‚', 'ðŸ‹ï¸', 'ðŸ¤¼', 'ðŸ¤¸', 'â›¹ï¸', 'ðŸ¤º', 'ðŸ¤¾', 'ðŸŒï¸', 'ðŸ‡', 'ðŸ§˜', 'ðŸ„', 'ðŸŠ', 'ðŸ¤½', 'ðŸš£', 'ðŸ§—', 'ðŸšµ', 'ðŸš´', 'ðŸ†', 'ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰', 'ðŸ…', 'ðŸŽ–ï¸', 'ðŸµï¸', 'ðŸŽ—ï¸', 'ðŸŽ«', 'ðŸŽŸï¸', 'ðŸŽª', 'ðŸ¤¹', 'ðŸŽ­', 'ðŸ©°', 'ðŸŽ¨', 'ðŸŽ¬', 'ðŸŽ¤', 'ðŸŽ§', 'ðŸŽ¼', 'ðŸŽ¹', 'ðŸ¥', 'ðŸª˜', 'ðŸŽ·', 'ðŸŽº', 'ðŸª—', 'ðŸŽ¸', 'ðŸª•', 'ðŸŽ»', 'ðŸŽ²', 'â™Ÿï¸', 'ðŸŽ¯', 'ðŸŽ³', 'ðŸŽ®', 'ðŸŽ°', 'ðŸ§©'],
            travel: ['ðŸš—', 'ðŸš•', 'ðŸš™', 'ðŸšŒ', 'ðŸšŽ', 'ðŸŽï¸', 'ðŸš“', 'ðŸš‘', 'ðŸš’', 'ðŸš', 'ðŸ›»', 'ðŸšš', 'ðŸš›', 'ðŸšœ', 'ðŸ¦¯', 'ðŸ¦½', 'ðŸ¦¼', 'ðŸ›´', 'ðŸš²', 'ðŸ›µ', 'ðŸï¸', 'ðŸ›º', 'ðŸš¨', 'ðŸš”', 'ðŸš', 'ðŸš˜', 'ðŸš–', 'ðŸš¡', 'ðŸš ', 'ðŸšŸ', 'ðŸšƒ', 'ðŸš‹', 'ðŸšž', 'ðŸš', 'ðŸš„', 'ðŸš…', 'ðŸšˆ', 'ðŸš‚', 'ðŸš†', 'ðŸš‡', 'ðŸšŠ', 'ðŸš‰', 'âœˆï¸', 'ðŸ›«', 'ðŸ›¬', 'ðŸ›©ï¸', 'ðŸ’º', 'ðŸ›°ï¸', 'ðŸš€', 'ðŸ›¸', 'ðŸš', 'ðŸ›¶', 'â›µ', 'ðŸš¤', 'ðŸ›¥ï¸', 'ðŸ›³ï¸', 'â›´ï¸', 'ðŸš¢', 'âš“', 'ðŸª', 'â›½', 'ðŸš§', 'ðŸš¦', 'ðŸš¥', 'ðŸš', 'ðŸ—ºï¸', 'ðŸ—¿', 'ðŸ—½', 'ðŸ—¼', 'ðŸ°', 'ðŸ¯', 'ðŸŸï¸', 'ðŸŽ¡', 'ðŸŽ¢', 'ðŸŽ ', 'â›²', 'â›±ï¸', 'ðŸ–ï¸', 'ðŸï¸', 'ðŸœï¸', 'ðŸŒ‹', 'â›°ï¸', 'ðŸ”ï¸', 'ðŸ—»', 'ðŸ•ï¸', 'â›º', 'ðŸ›–', 'ðŸ ', 'ðŸ¡', 'ðŸ˜ï¸', 'ðŸšï¸', 'ðŸ—ï¸', 'ðŸ­', 'ðŸ¢', 'ðŸ¬', 'ðŸ£', 'ðŸ¤', 'ðŸ¥', 'ðŸ¦', 'ðŸ¨', 'ðŸª', 'ðŸ«', 'ðŸ©', 'ðŸ’’', 'ðŸ›ï¸', 'â›ª', 'ðŸ•Œ', 'ðŸ•', 'ðŸ›•', 'ðŸ•‹', 'â›©ï¸', 'ðŸ›¤ï¸', 'ðŸ›£ï¸', 'ðŸ—¾', 'ðŸŽ‘', 'ðŸžï¸', 'ðŸŒ…', 'ðŸŒ„', 'ðŸŒ ', 'ðŸŽ‡', 'ðŸŽ†', 'ðŸŒ‡', 'ðŸŒ†', 'ðŸ™ï¸', 'ðŸŒƒ', 'ðŸŒŒ', 'ðŸŒ‰', 'ðŸŒ'],
            objects: ['ðŸ’¡', 'ðŸ”¦', 'ðŸ®', 'ðŸª”', 'ðŸ“±', 'ðŸ“²', 'ðŸ’»', 'ðŸ–¥ï¸', 'ðŸ–¨ï¸', 'âŒ¨ï¸', 'ðŸ–±ï¸', 'ðŸ–²ï¸', 'ðŸ’½', 'ðŸ’¾', 'ðŸ’¿', 'ðŸ“€', 'ðŸ§®', 'ðŸŽ¥', 'ðŸŽžï¸', 'ðŸ“½ï¸', 'ðŸŽ¬', 'ðŸ“º', 'ðŸ“·', 'ðŸ“¸', 'ðŸ“¹', 'ðŸ“¼', 'ðŸ”', 'ðŸ”Ž', 'ðŸ•¯ï¸', 'ðŸ’¡', 'ðŸ”¦', 'ðŸ®', 'ðŸª”', 'ðŸ“”', 'ðŸ“•', 'ðŸ“–', 'ðŸ“—', 'ðŸ“˜', 'ðŸ“™', 'ðŸ“š', 'ðŸ““', 'ðŸ“’', 'ðŸ“ƒ', 'ðŸ“œ', 'ðŸ“„', 'ðŸ“°', 'ðŸ—žï¸', 'ðŸ“‘', 'ðŸ”–', 'ðŸ·ï¸', 'ðŸ’°', 'ðŸª™', 'ðŸ’´', 'ðŸ’µ', 'ðŸ’¶', 'ðŸ’·', 'ðŸ’¸', 'ðŸ’³', 'ðŸ§¾', 'ðŸ’¹', 'âœ‰ï¸', 'ðŸ“§', 'ðŸ“¨', 'ðŸ“©', 'ðŸ“¤', 'ðŸ“¥', 'ðŸ“¦', 'ðŸ“«', 'ðŸ“ª', 'ðŸ“¬', 'ðŸ“­', 'ðŸ“®', 'ðŸ—³ï¸', 'âœï¸', 'âœ’ï¸', 'ðŸ–‹ï¸', 'ðŸ–Šï¸', 'ðŸ–Œï¸', 'ðŸ–ï¸', 'ðŸ“', 'ðŸ’¼', 'ðŸ“', 'ðŸ“‚', 'ðŸ—‚ï¸', 'ðŸ“…', 'ðŸ“†', 'ðŸ—’ï¸', 'ðŸ—“ï¸', 'ðŸ“‡', 'ðŸ“ˆ', 'ðŸ“‰', 'ðŸ“Š', 'ðŸ“‹', 'ðŸ“Œ', 'ðŸ“', 'ðŸ“Ž', 'ðŸ–‡ï¸', 'ðŸ“', 'ðŸ“', 'âœ‚ï¸', 'ðŸ—ƒï¸', 'ðŸ—„ï¸', 'ðŸ—‘ï¸', 'ðŸ”’', 'ðŸ”“', 'ðŸ”', 'ðŸ”', 'ðŸ”‘', 'ðŸ—ï¸', 'ðŸ”¨', 'ðŸª“', 'â›ï¸', 'âš’ï¸', 'ðŸ› ï¸', 'ðŸ—¡ï¸', 'âš”ï¸', 'ðŸ”«', 'ðŸªƒ', 'ðŸ¹', 'ðŸ›¡ï¸', 'ðŸªš', 'ðŸ”§', 'ðŸª›', 'ðŸ”©', 'âš™ï¸', 'ðŸ—œï¸', 'âš–ï¸', 'ðŸ¦¯', 'ðŸ”—', 'â›“ï¸', 'ðŸª', 'ðŸ§°', 'ðŸ§²', 'ðŸªœ', 'âš—ï¸', 'ðŸ§ª', 'ðŸ§«', 'ðŸ§¬', 'ðŸ”¬', 'ðŸ”­', 'ðŸ“¡', 'ðŸ’‰', 'ðŸ©¸', 'ðŸ’Š', 'ðŸ©¹', 'ðŸ©º', 'ðŸšª', 'ðŸ›—', 'ðŸªž', 'ðŸªŸ', 'ðŸ›ï¸', 'ðŸ›‹ï¸', 'ðŸª‘', 'ðŸš½', 'ðŸª ', 'ðŸš¿', 'ðŸ›', 'ðŸª¤', 'ðŸª’', 'ðŸ§´', 'ðŸ§·', 'ðŸ§¹', 'ðŸ§º', 'ðŸ§»', 'ðŸª£', 'ðŸ§¼', 'ðŸª¥', 'ðŸ§½', 'ðŸ§¯', 'ðŸ›’', 'ðŸš¬', 'âš°ï¸', 'ðŸª¦', 'âš±ï¸', 'ðŸ—¿', 'ðŸª§', 'ðŸ§'],
            symbols: ['â¤ï¸', 'ðŸ§¡', 'ðŸ’›', 'ðŸ’š', 'ðŸ’™', 'ðŸ’œ', 'ðŸ–¤', 'ðŸ¤', 'ðŸ¤Ž', 'ðŸ’”', 'â£ï¸', 'ðŸ’•', 'ðŸ’ž', 'ðŸ’“', 'ðŸ’—', 'ðŸ’–', 'ðŸ’˜', 'ðŸ’', 'ðŸ’Ÿ', 'â˜®ï¸', 'âœï¸', 'â˜ªï¸', 'ðŸ•‰ï¸', 'â˜¸ï¸', 'âœ¡ï¸', 'ðŸ”¯', 'ðŸ•Ž', 'â˜¯ï¸', 'â˜¦ï¸', 'ðŸ›', 'â›Ž', 'â™ˆ', 'â™‰', 'â™Š', 'â™‹', 'â™Œ', 'â™', 'â™Ž', 'â™', 'â™', 'â™‘', 'â™’', 'â™“', 'ðŸ†”', 'âš›ï¸', 'ðŸ‰‘', 'â˜¢ï¸', 'â˜£ï¸', 'ðŸ“´', 'ðŸ“³', 'ðŸˆ¶', 'ðŸˆš', 'ðŸˆ¸', 'ðŸˆº', 'ðŸˆ·ï¸', 'âœ´ï¸', 'ðŸ†š', 'ðŸ’®', 'ðŸ‰', 'ãŠ™ï¸', 'ãŠ—ï¸', 'ðŸˆ´', 'ðŸˆµ', 'ðŸˆ¹', 'ðŸˆ²', 'ðŸ…°ï¸', 'ðŸ…±ï¸', 'ðŸ†Ž', 'ðŸ†‘', 'ðŸ…¾ï¸', 'ðŸ†˜', 'âŒ', 'â­•', 'ðŸ›‘', 'â›”', 'ðŸ“›', 'ðŸš«', 'ðŸ’¯', 'ðŸ’¢', 'â™¨ï¸', 'ðŸš·', 'ðŸš¯', 'ðŸš³', 'ðŸš±', 'ðŸ”ž', 'ðŸ“µ', 'ðŸš­', 'â—', 'â•', 'â“', 'â”', 'â€¼ï¸', 'â‰ï¸', 'ðŸ”…', 'ðŸ”†', 'ã€½ï¸', 'âš ï¸', 'ðŸš¸', 'ðŸ”±', 'âšœï¸', 'ðŸ”°', 'â™»ï¸', 'âœ…', 'ðŸˆ¯', 'ðŸ’¹', 'â‡ï¸', 'âœ³ï¸', 'âŽ', 'ðŸŒ', 'ðŸ’ ', 'â“‚ï¸', 'ðŸŒ€', 'ðŸ’¤', 'ðŸ§', 'ðŸš¾', 'â™¿', 'ðŸ…¿ï¸', 'ðŸ›—', 'ðŸˆ³', 'ðŸˆ‚ï¸', 'ðŸ›‚', 'ðŸ›ƒ', 'ðŸ›„', 'ðŸ›…', 'ðŸš¹', 'ðŸšº', 'ðŸš¼', 'âš§ï¸', 'ðŸš»', 'ðŸš®', 'ðŸŽ¦', 'ðŸ“¶', 'ðŸˆ', 'ðŸ”£', 'â„¹ï¸', 'ðŸ”¤', 'ðŸ”¡', 'ðŸ” ', 'ðŸ†–', 'ðŸ†—', 'ðŸ†™', 'ðŸ†’', 'ðŸ†•', 'ðŸ†“', '0ï¸âƒ£', '1ï¸âƒ£', '2ï¸âƒ£', '3ï¸âƒ£', '4ï¸âƒ£', '5ï¸âƒ£', '6ï¸âƒ£', '7ï¸âƒ£', '8ï¸âƒ£', '9ï¸âƒ£', 'ðŸ”Ÿ', 'ðŸ”¢', '#ï¸âƒ£', '*ï¸âƒ£', 'âï¸', 'â–¶ï¸', 'â¸ï¸', 'â¯ï¸', 'â¹ï¸', 'âºï¸', 'â­ï¸', 'â®ï¸', 'â©', 'âª', 'â«', 'â¬', 'â—€ï¸', 'ðŸ”¼', 'ðŸ”½', 'âž¡ï¸', 'â¬…ï¸', 'â¬†ï¸', 'â¬‡ï¸', 'â†—ï¸', 'â†˜ï¸', 'â†™ï¸', 'â†–ï¸', 'â†•ï¸', 'â†”ï¸', 'â†ªï¸', 'â†©ï¸', 'â¤´ï¸', 'â¤µï¸', 'ðŸ”€', 'ðŸ”', 'ðŸ”‚', 'ðŸ”„', 'ðŸ”ƒ', 'ðŸŽµ', 'ðŸŽ¶', 'âž•', 'âž–', 'âž—', 'âœ–ï¸', 'ðŸŸ°', 'â™¾ï¸', 'ðŸ’²', 'ðŸ’±', 'â„¢ï¸', 'Â©ï¸', 'Â®ï¸', 'ã€°ï¸', 'âž°', 'âž¿', 'ðŸ”š', 'ðŸ”™', 'ðŸ”›', 'ðŸ”', 'ðŸ”œ', 'âœ”ï¸', 'â˜‘ï¸', 'ðŸ”˜', 'ðŸ”´', 'ðŸŸ ', 'ðŸŸ¡', 'ðŸŸ¢', 'ðŸ”µ', 'ðŸŸ£', 'âš«', 'âšª', 'ðŸŸ¤', 'ðŸ”º', 'ðŸ”»', 'ðŸ”¸', 'ðŸ”¹', 'ðŸ”¶', 'ðŸ”·', 'ðŸ”³', 'ðŸ”²', 'â–ªï¸', 'â–«ï¸', 'â—¾', 'â—½', 'â—¼ï¸', 'â—»ï¸', 'ðŸŸ¥', 'ðŸŸ§', 'ðŸŸ¨', 'ðŸŸ©', 'ðŸŸ¦', 'ðŸŸª', 'â¬›', 'â¬œ', 'ðŸŸ«', 'ðŸ”ˆ', 'ðŸ”‡', 'ðŸ”‰', 'ðŸ”Š', 'ðŸ””', 'ðŸ”•', 'ðŸ“£', 'ðŸ“¢', 'ðŸ‘ï¸â€ðŸ—¨ï¸', 'ðŸ’¬', 'ðŸ’­', 'ðŸ—¯ï¸', 'â™ ï¸', 'â™£ï¸', 'â™¥ï¸', 'â™¦ï¸', 'ðŸƒ', 'ðŸŽ´', 'ðŸ€„', 'ðŸ•', 'ðŸ•‘', 'ðŸ•’', 'ðŸ•“', 'ðŸ•”', 'ðŸ••', 'ðŸ•–', 'ðŸ•—', 'ðŸ•˜', 'ðŸ•™', 'ðŸ•š', 'ðŸ•›', 'ðŸ•œ', 'ðŸ•', 'ðŸ•ž', 'ðŸ•Ÿ', 'ðŸ• ', 'ðŸ•¡', 'ðŸ•¢', 'ðŸ•£', 'ðŸ•¤', 'ðŸ•¥', 'ðŸ•¦', 'ðŸ•§']
        };
        
        let currentCategory = 'smileys';
        let allEmojis = [];
        
        // Flatten all emojis for search
        Object.values(emojiData).forEach(arr => allEmojis.push(...arr));
        
        // State for emoji picker
        window._emojiPickerRange = null;
        window._hashInsertRange = null;
        
        /**
         * Render emoji grid
         */
        function renderEmojiGrid(category, searchTerm = '') {
            let emojis = [];
            
            if (searchTerm) {
                // Simple search: just show all emojis that contain the search term (for now just filter by position)
                emojis = allEmojis;
                // For a better search, you'd need emoji names/keywords database
            } else {
                emojis = emojiData[category] || [];
            }
            
            emojiGrid.innerHTML = emojis.map(emoji => `
                <div class="emoji-item" data-emoji="${emoji}">${emoji}</div>
            `).join('');
        }
        
        /**
         * Show emoji popover
         */
        function showEmojiPopover() {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            
            const range = selection.getRangeAt(0);
            window._emojiPickerRange = range.cloneRange();
            
            // Get caret position
            const caretRect = range.getBoundingClientRect();
            
            // Render current category
            renderEmojiGrid(currentCategory);
            
            // Reset search
            if (searchInput) searchInput.value = '';
            
            // Use floating menu helper
            openFloatingMenu(popover, caretRect, {
                margin: 10,
                onClose: () => {
                    window._emojiPickerRange = null;
                    window._hashInsertRange = null;
                }
            });
            
            // Focus search input
            setTimeout(() => searchInput?.focus(), 50);
        }
        
        /**
         * Hide emoji popover
         */
        function hideEmojiPopover(clearState = false) {
            if (floatingMenuState.activeMenu === popover) {
                closeFloatingMenu();
            } else {
                popover.style.display = 'none';
            }
            
            if (clearState) {
                window._emojiPickerRange = null;
                window._hashInsertRange = null;
            }
        }
        
        /**
         * Remove the # character that triggered the popover
         */
        function removeHashAtTrigger() {
            if (!window._hashInsertRange) return;
            
            const range = window._hashInsertRange;
            
            try {
                editor.focus();
                
                const container = range.startContainer;
                const offset = range.startOffset;
                
                if (container.nodeType === Node.TEXT_NODE && offset > 0) {
                    const text = container.textContent;
                    if (text.charAt(offset - 1) === '#') {
                        const deleteRange = document.createRange();
                        deleteRange.setStart(container, offset - 1);
                        deleteRange.setEnd(container, offset);
                        deleteRange.deleteContents();
                        
                        // Update emoji picker range
                        if (window._emojiPickerRange) {
                            const newRange = document.createRange();
                            newRange.setStart(container, Math.max(0, offset - 1));
                            newRange.setEnd(container, Math.max(0, offset - 1));
                            window._emojiPickerRange = newRange;
                        }
                    }
                }
            } catch (e) {
                console.warn('Could not remove hash:', e);
            }
            
            window._hashInsertRange = null;
        }
        
        /**
         * Insert emoji at cursor position
         */
        function insertEmoji(emoji) {
            // Remove the # trigger character first
            removeHashAtTrigger();
            
            const range = window._emojiPickerRange;
            if (!range) {
                // Fallback: just insert at current position
                editor.focus();
                document.execCommand('insertText', false, emoji);
                hideEmojiPopover(true);
                return;
            }
            
            try {
                editor.focus();
                
                // Restore selection
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
                
                // Insert emoji
                document.execCommand('insertText', false, emoji);
                
                // Trigger save
                if (typeof window.triggerDocAutoSave === 'function') {
                    window.triggerDocAutoSave();
                }
            } catch (e) {
                console.warn('Could not insert emoji:', e);
            }
            
            hideEmojiPopover(true);
        }
        
        // Listen for # key in editor
        editor.addEventListener('keydown', (e) => {
            if (e.key === '#' || (e.shiftKey && e.key === '3')) {
                // Store range before # is typed
                const sel = window.getSelection();
                if (sel.rangeCount > 0) {
                    window._preHashRange = sel.getRangeAt(0).cloneRange();
                }
            } else if (e.key === 'Escape' && popover.style.display !== 'none') {
                e.preventDefault();
                hideEmojiPopover(true);
            }
        });
        
        editor.addEventListener('keyup', (e) => {
            if (e.key === '#' || (e.shiftKey && e.key === '3' && e.code === 'Digit3')) {
                // After # is typed, store the exact range
                const sel = window.getSelection();
                if (sel.rangeCount > 0) {
                    window._hashInsertRange = sel.getRangeAt(0).cloneRange();
                }
                showEmojiPopover();
            }
        });
        
        // Category tab clicks
        if (categoryTabs) {
            categoryTabs.addEventListener('click', (e) => {
                const tab = e.target.closest('.emoji-tab');
                if (!tab) return;
                
                const category = tab.dataset.category;
                if (!category) return;
                
                // Update active tab
                categoryTabs.querySelectorAll('.emoji-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Render new category
                currentCategory = category;
                renderEmojiGrid(category);
                
                // Clear search
                if (searchInput) searchInput.value = '';
            });
        }
        
        // Emoji grid clicks
        emojiGrid.addEventListener('click', (e) => {
            const item = e.target.closest('.emoji-item');
            if (!item) return;
            
            const emoji = item.dataset.emoji;
            if (emoji) {
                insertEmoji(emoji);
            }
        });
        
        // Search input
        if (searchInput) {
            searchInput.addEventListener('input', (e) => {
                const term = e.target.value.trim().toLowerCase();
                if (term) {
                    // Show filtered results (simple character match for now)
                    // A real implementation would use emoji names/keywords
                    renderEmojiGrid(null, term);
                } else {
                    renderEmojiGrid(currentCategory);
                }
            });
            
            // Prevent Enter from closing on search
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    hideEmojiPopover(true);
                    editor.focus();
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    // Select first emoji if available
                    const firstEmoji = emojiGrid.querySelector('.emoji-item');
                    if (firstEmoji) {
                        insertEmoji(firstEmoji.dataset.emoji);
                    }
                }
            });
        }
        
        // Make hideEmojiPopover accessible
        window._hideDocEmojiPopover = hideEmojiPopover;
    }
    
    /**
     * Open reference picker modal
     */
    window.openReferencePickerModal = function(type) {
        const modal = document.getElementById('referencePickerModal');
        const title = document.getElementById('referencePickerTitle');
        const subtitle = document.getElementById('referencePickerSubtitle');
        const list = document.getElementById('referencePickerList');
        const search = document.getElementById('referencePickerSearch');
        
        if (!modal || !list) return;
        
        // Set title based on type
        const titles = {
            'task': { title: '<i class="fas fa-check-circle"></i> Insert Task Reference', subtitle: 'Select a task to reference' },
            'sheet': { title: '<i class="fas fa-table"></i> Insert Sheet Reference', subtitle: 'Select a spreadsheet to reference' },
            'sheet-embed': { title: '<i class="fas fa-table-cells"></i> Embed Sheet', subtitle: 'Select a spreadsheet to embed (read-only)' }
        };
        
        if (title) title.innerHTML = titles[type].title;
        if (subtitle) subtitle.textContent = titles[type].subtitle;
        
        // Store type for later
        modal.dataset.referenceType = type;
        
        // Populate list
        const isEmbed = type === 'sheet-embed';
        const isSheet = type === 'sheet' || isEmbed;
        
        if (isSheet) {
            // Show spreadsheets
            const spreadsheets = appState.spreadsheets.filter(s => {
                // Filter by visibility
                if (s.visibility === 'private') {
                    return s.createdBy === currentAuthUser?.uid;
                }
                return true;
            });
            
            list.innerHTML = spreadsheets.map(sheet => `
                <div class="reference-picker-item" data-id="${escapeHtml(sheet.id)}">
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <div class="reference-item-icon sheet">
                            <i class="fas ${escapeHtml(sheet.icon || 'fa-table')}"></i>
                        </div>
                        <div style="flex: 1;">
                            <div class="reference-item-title">${escapeHtml(sheet.name)}</div>
                            <div class="reference-item-meta">
                                ${sheet.visibility === 'private' ? '<i class="fas fa-lock"></i> Private' : '<i class="fas fa-users"></i> Team'}
                            </div>
                        </div>
                    </div>
                </div>
            `).join('');
        } else {
            // Show tasks
            const tasks = appState.tasks.filter(t => {
                // Filter by spreadsheet visibility
                const taskSpreadsheet = appState.spreadsheets.find(s => s.id === t.spreadsheetId);
                if (taskSpreadsheet?.visibility === 'private') {
                    return taskSpreadsheet.createdBy === currentAuthUser?.uid;
                }
                return true;
            });
            
            list.innerHTML = tasks.map(task => {
                const statusIcons = {
                    'todo': '<i class="fas fa-circle" style="color: #8E8E93;"></i>',
                    'in-progress': '<i class="fas fa-circle-half-stroke" style="color: #FF9500;"></i>',
                    'done': '<i class="fas fa-check-circle" style="color: #34C759;"></i>'
                };
                
                return `
                    <div class="reference-picker-item" data-id="${escapeHtml(task.id)}">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <div class="reference-item-icon task">
                                ${statusIcons[task.status] || statusIcons['todo']}
                            </div>
                            <div style="flex: 1;">
                                <div class="reference-item-title">${escapeHtml(task.title)}</div>
                                <div class="reference-item-meta">
                                    ${task.status || 'To Do'} 
                                    ${task.assignee ? `â€¢ ${getIdentity(task.assignee).displayName}` : ''}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Search functionality
        if (search) {
            search.value = '';
            search.addEventListener('input', () => {
                const query = search.value.toLowerCase();
                list.querySelectorAll('.reference-picker-item').forEach(item => {
                    const title = item.querySelector('.reference-item-title')?.textContent.toLowerCase() || '';
                    item.style.display = title.includes(query) ? 'block' : 'none';
                });
            });
        }
        
        // Item clicks
        list.querySelectorAll('.reference-picker-item').forEach(item => {
            item.addEventListener('click', (e) => {
                console.log('[DEBUG Modal Click] Item clicked:', item.dataset.id, 'type:', type);
                e.stopPropagation(); // Prevent modal backdrop close
                const id = item.dataset.id;
                insertReference(type, id);
                closeReferencePickerModal();
            });
        });
        
        modal.style.display = 'flex';
    };
    
    window.closeReferencePickerModal = function() {
        const modal = document.getElementById('referencePickerModal');
        if (modal) modal.style.display = 'none';
    };
    
    /**
     * Insert reference chip or embed into editor
     */
    function insertReference(type, id) {
        console.log('[DEBUG insertReference] Called with type:', type, 'id:', id);
        
        const editor = document.getElementById('docEditor');
        if (!editor) {
            console.error('[DEBUG insertReference] Editor not found!');
            return;
        }
        
        editor.focus();
        
        // Restore selection from stored range
        // PRIORITY: Use dedicated _referenceInsertRange (survives modal interactions), 
        // then fall back to _commandRange
        const rangeToRestore = window._referenceInsertRange || window._commandRange;
        console.log('[DEBUG insertReference] rangeToRestore:', rangeToRestore, '_referenceInsertRange:', window._referenceInsertRange, '_commandRange:', window._commandRange);
        
        if (rangeToRestore) {
            try {
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(rangeToRestore);
                console.log('[DEBUG insertReference] Restored cursor range for chip insertion');
            } catch (e) {
                console.warn('[DEBUG insertReference] Could not restore selection:', e);
                // If range restoration fails, try to insert at end of editor
                const selection = window.getSelection();
                const range = document.createRange();
                range.selectNodeContents(editor);
                range.collapse(false); // Collapse to end
                selection.removeAllRanges();
                selection.addRange(range);
            }
        } else {
            console.warn('[DEBUG insertReference] No saved range - inserting at end of editor');
            // If no range saved, insert at end of editor
            const selection = window.getSelection();
            const range = document.createRange();
            range.selectNodeContents(editor);
            range.collapse(false); // Collapse to end
            selection.removeAllRanges();
            selection.addRange(range);
        }
        
        // Verify selection is inside editor before insertion
        const sel = window.getSelection();
        const anchorInEditor = sel.rangeCount > 0 && editor.contains(sel.getRangeAt(0).commonAncestorContainer);
        console.log('[DEBUG insertReference] Selection inside editor:', anchorInEditor);
        
        if (type === 'sheet-embed') {
            // Insert embed block
            const embedHTML = `<div class="doc-embed" data-embed-type="sheet" data-id="${escapeHtml(id)}"></div><p></p>`;
            console.log('[DEBUG insertReference] Inserting embed HTML:', embedHTML);
            document.execCommand('insertHTML', false, embedHTML);
            
            // Hydrate embed immediately
            setTimeout(() => hydrateDocEmbeds(), 100);
        } else {
            // Insert chip
            const chipType = type === 'task' ? 'task' : 'sheet';
            const chipHTML = `<span class="doc-chip" contenteditable="false" data-chip-type="${chipType}" data-id="${escapeHtml(id)}"></span>`;
            console.log('[DEBUG insertReference] Inserting chip HTML:', chipHTML);
            const result = document.execCommand('insertHTML', false, chipHTML);
            console.log('[DEBUG insertReference] execCommand result:', result);
            
            // Check if chip was actually inserted
            const allChips = editor.querySelectorAll('.doc-chip');
            console.log('[DEBUG insertReference] All chips in editor after insert:', allChips.length);
            
            // Move caret after the chip so typing happens on same line
            const insertedChip = editor.querySelector(`.doc-chip[data-chip-type="${chipType}"][data-id="${escapeHtml(id)}"]:not(.hydrated)`);
            if (insertedChip) {
                moveCaretAfterElement(insertedChip);
            }
            
            // Hydrate chip immediately
            setTimeout(() => hydrateDocChips(), 100);
        }
        
        // Clear command state now that insertion is complete
        window._commandRange = null;
        window._commandTriggerInfo = null;
        window._slashInsertRange = null;
        window._referenceInsertRange = null; // Clear dedicated range too
        
        appState.isDocDirty = true;
        scheduleDocSave();
    }
    
    /**
     * Add delete button to chip element
     */
    function addChipDeleteButton(chip) {
        // Remove existing delete button if any
        chip.querySelector('.chip-delete-btn')?.remove();
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'chip-delete-btn';
        deleteBtn.innerHTML = '<i class="fas fa-times"></i>';
        deleteBtn.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            chip.remove();
            appState.isDocDirty = true;
            scheduleDocSave();
        };
        chip.appendChild(deleteBtn);
    }
    
    /**
     * Add delete button to embed element
     */
    function addEmbedDeleteButton(embed) {
        // Remove existing delete button if any
        embed.querySelector('.embed-delete-btn')?.remove();
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'embed-delete-btn';
        deleteBtn.innerHTML = '<i class="fas fa-times"></i>';
        deleteBtn.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            embed.remove();
            appState.isDocDirty = true;
            scheduleDocSave();
        };
        embed.appendChild(deleteBtn);
    }
    
    /**
     * Hydrate doc chips with live data
     */
    function hydrateDocChips() {
        const editor = document.getElementById('docEditor');
        if (!editor) return;
        
        const chips = editor.querySelectorAll('.doc-chip:not(.hydrated)');
        
        chips.forEach(chip => {
            const chipType = chip.dataset.chipType;
            const id = chip.dataset.id;
            
            // Make all chips draggable
            chip.setAttribute('draggable', 'true');
            
            // Skip link chips - they don't need hydration (already have content)
            if (chipType === 'link') {
                // Ensure link chip stays non-editable
                chip.setAttribute('contenteditable', 'false');
                chip.classList.add('hydrated');
                addChipDeleteButton(chip);
                return;
            }
            
            if (chipType === 'task') {
                // Ensure chip stays non-editable
                chip.setAttribute('contenteditable', 'false');
                
                const task = appState.tasks.find(t => t.id === id);
                if (task) {
                    // Check visibility
                    const taskSpreadsheet = appState.spreadsheets.find(s => s.id === task.spreadsheetId);
                    if (taskSpreadsheet?.visibility === 'private' && taskSpreadsheet.createdBy !== currentAuthUser?.uid) {
                        chip.classList.add('unavailable');
                        chip.innerHTML = '<i class="fas fa-lock chip-icon"></i><span>Unavailable</span>';
                    } else {
                        const statusDots = {
                            'todo': 'todo',
                            'in-progress': 'in-progress',
                            'done': 'done'
                        };
                        const dotClass = statusDots[task.status] || 'todo';
                        chip.innerHTML = `<span class="chip-status-dot ${dotClass}"></span><span>${escapeHtml(task.title)}</span>`;
                        chip.onclick = (e) => {
                            e.stopPropagation();
                            e.preventDefault();
                            navigateToTaskSheet(id);
                        };
                    }
                } else {
                    chip.classList.add('unavailable');
                    chip.innerHTML = '<i class="fas fa-exclamation-triangle chip-icon"></i><span>Task not found</span>';
                }
            } else if (chipType === 'sheet') {
                // Ensure chip stays non-editable
                chip.setAttribute('contenteditable', 'false');
                
                const sheet = appState.spreadsheets.find(s => s.id === id);
                if (sheet) {
                    // Check visibility
                    if (sheet.visibility === 'private' && sheet.createdBy !== currentAuthUser?.uid) {
                        chip.classList.add('unavailable');
                        chip.innerHTML = '<i class="fas fa-lock chip-icon"></i><span>Unavailable</span>';
                    } else {
                        chip.innerHTML = `<i class="fas ${escapeHtml(sheet.icon || 'fa-table')} chip-icon"></i><span>${escapeHtml(sheet.name)}</span>`;
                        chip.onclick = async (e) => {
                            e.stopPropagation();
                            e.preventDefault();
                            // Use single source of truth navigation
                            await navigateToSpreadsheet(sheet.id);
                        };
                    }
                } else {
                    chip.classList.add('unavailable');
                    chip.innerHTML = '<i class="fas fa-exclamation-triangle chip-icon"></i><span>Sheet not found</span>';
                }
            }
            
            // Add delete button
            addChipDeleteButton(chip);
            
            chip.classList.add('hydrated');
        });
    }
    
    /**
     * Hydrate doc embeds with sheet data
     */
    function hydrateDocEmbeds() {
        const editor = document.getElementById('docEditor');
        if (!editor) return;
        
        const embeds = editor.querySelectorAll('.doc-embed:not(.hydrated)');
        
        embeds.forEach(embed => {
            const embedType = embed.dataset.embedType;
            const id = embed.dataset.id;
            
            if (embedType === 'sheet') {
                const sheet = appState.spreadsheets.find(s => s.id === id);
                
                if (!sheet) {
                    embed.classList.add('unavailable');
                    embed.innerHTML = `
                        <i class="fas fa-exclamation-triangle"></i>
                        <p>Sheet not found</p>
                    `;
                    embed.classList.add('hydrated');
                    return;
                }
                
                // Check visibility
                if (sheet.visibility === 'private' && sheet.createdBy !== currentAuthUser?.uid) {
                    embed.classList.add('unavailable');
                    embed.innerHTML = `
                        <i class="fas fa-lock"></i>
                        <p>This sheet is private</p>
                    `;
                    addEmbedDeleteButton(embed);
                    embed.classList.add('hydrated');
                    return;
                }
                
                // Get OPEN tasks only (filter out done/complete), limit to 6 rows
                const allTasks = getTasksForSpreadsheet(sheet);
                const openTasks = allTasks.filter(t => t.status !== 'done' && t.status !== 'complete');
                const displayTasks = openTasks.slice(0, 6);
                const hasMore = openTasks.length > 6;
                
                // Build compact table (fewer columns for tighter layout)
                const columns = ['title', 'status', 'priority'];
                const columnLabels = { title: 'Task', status: 'Status', priority: 'Priority' };
                
                let tableHTML = '<div class="doc-embed-header doc-embed-header-compact">';
                tableHTML += `<div class="doc-embed-title"><i class="fas ${escapeHtml(sheet.icon || 'fa-table')}"></i> ${escapeHtml(sheet.name)}</div>`;
                tableHTML += `<button class="doc-embed-open-btn" onclick="navigateToSpreadsheet('${escapeHtml(id)}')">Open full sheet</button>`;
                tableHTML += '</div>';
                tableHTML += '<div class="doc-embed-table-wrapper doc-embed-table-wrapper-compact">';
                tableHTML += '<table class="doc-embed-table doc-embed-table-compact">';
                tableHTML += '<thead><tr>';
                columns.forEach(col => {
                    tableHTML += `<th>${columnLabels[col]}</th>`;
                });
                tableHTML += '</tr></thead><tbody>';
                
                displayTasks.forEach(task => {
                    tableHTML += '<tr>';
                    columns.forEach(col => {
                        let value = '';
                        if (col === 'title') {
                            value = escapeHtml(task.title || '');
                        } else if (col === 'status') {
                            const statusClass = (task.status || 'todo').replace(/\s+/g, '-');
                            value = `<span class="embed-status-pill embed-status-${statusClass}">${escapeHtml(task.status || 'todo')}</span>`;
                        } else if (col === 'priority') {
                            if (task.priority) {
                                value = `<span class="embed-priority-pill embed-priority-${task.priority}">${escapeHtml(task.priority)}</span>`;
                            } else {
                                value = '<span class="embed-priority-pill embed-priority-none">â€”</span>';
                            }
                        } else {
                            value = escapeHtml(task[col] || '');
                        }
                        tableHTML += `<td>${value}</td>`;
                    });
                    tableHTML += '</tr>';
                });
                
                if (displayTasks.length === 0) {
                    tableHTML += '<tr><td colspan="3" style="text-align: center; color: var(--text-muted); padding: 16px;">No open tasks</td></tr>';
                }
                
                tableHTML += '</tbody></table></div>';
                
                // Add "See all" footer if there are more tasks
                if (hasMore) {
                    tableHTML += `<div class="doc-embed-footer">
                        <button class="doc-embed-see-all" onclick="navigateToSpreadsheet('${escapeHtml(id)}')">
                            <i class="fas fa-arrow-right"></i> See all ${openTasks.length} tasks
                        </button>
                    </div>`;
                }
                
                embed.innerHTML = tableHTML;
                
                // Add delete button after setting innerHTML
                addEmbedDeleteButton(embed);
                
                embed.classList.add('hydrated');
            }
        });
    }
    
    /**
     * Deprecated: Sheet preview removed
     * Now redirects to proper navigation function
     */
    function openSheetPreview(sheetId) {
        navigateToSpreadsheet(sheetId);
    }
    
    window.closeSheetPreview = function() {
        document.getElementById('sheetPreviewDrawer')?.remove();
    };
    
    /**
     * Doc visibility management
     */
    window.openDocVisibilityModal = function(doc) {
        const modal = document.getElementById('docVisibilityModal');
        const subtitle = document.getElementById('docVisibilitySubtitle');
        const visibilityToggle = modal?.querySelector('.visibility-toggle');
        const visibilityButtons = visibilityToggle?.querySelectorAll('.view-toggle-btn');
        const readOnlySection = document.getElementById('docReadOnlySection');
        const readOnlyToggle = document.getElementById('docReadOnlyToggle');
        
        if (!modal || !doc) return;
        
        // Store doc ID
        modal.dataset.docId = doc.id;
        
        if (subtitle) {
            subtitle.textContent = `Who can see "${doc.title || 'Untitled'}"`;
        }
        
        // Set current visibility selection
        const currentVisibility = doc.visibility || 'team';
        setVisibilitySelection(visibilityToggle, currentVisibility);
        
        // Show read-only toggle only for doc owner
        const isOwner = doc.createdBy === currentAuthUser?.uid;
        if (readOnlySection) {
            readOnlySection.style.display = isOwner ? 'block' : 'none';
        }
        
        // Set current read-only state
        if (readOnlyToggle) {
            readOnlyToggle.checked = doc.isReadOnly === true;
        }
        
        // Click handlers for visibility options
        visibilityButtons?.forEach(btn => {
            btn.onclick = () => setVisibilitySelection(visibilityToggle, btn.dataset.visibility || 'team');
        });
        
        modal.style.display = 'flex';
    };
    
    window.closeDocVisibilityModal = function() {
        const modal = document.getElementById('docVisibilityModal');
        if (modal) modal.style.display = 'none';
    };
    
    document.getElementById('saveDocVisibility')?.addEventListener('click', async () => {
        const modal = document.getElementById('docVisibilityModal');
        const docId = modal?.dataset.docId;
        
        if (!docId) return;
        
        const visibility = getActiveVisibilityValue('docVisibility');
        const readOnlyToggle = document.getElementById('docReadOnlyToggle');
        const isReadOnly = readOnlyToggle?.checked || false;
        
        try {
            const { doc: docRef, updateDoc, serverTimestamp } = 
                await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
            
            const ref = docRef(db, 'teams', appState.currentTeamId, 'docs', docId);
            await updateDoc(ref, {
                visibility,
                isReadOnly,
                updatedAt: serverTimestamp(),
                updatedBy: currentAuthUser.uid
            });
            
            showToast('Visibility updated', 'success');
            closeDocVisibilityModal();
            
        } catch (error) {
            console.error('Error updating doc visibility:', error);
            showToast('Failed to update visibility', 'error');
        }
    });
    
    // navigateToTaskSheet is defined earlier in the file (line ~4295) with proper async handling
    // No need to redefine it here - just ensure window reference exists
    if (!window.navigateToTaskSheet) {
        window.navigateToTaskSheet = navigateToTaskSheet;
    }
    
    /**
     * Clean up docs when switching teams
     */
    function cleanupDocsState() {
        // Cleanup listener
        if (appState.docsUnsub) {
            appState.docsUnsub();
            appState.docsUnsub = null;
        }
        
        // Clear timer
        if (appState.docSaveTimer) {
            clearTimeout(appState.docSaveTimer);
            appState.docSaveTimer = null;
        }
        
        // Reset state
        appState.docs = [];
        appState.activeDocId = null;
        appState.isDocDirty = false;
        appState.isDocSaving = false;
        
        // Close panel if open
        const tasksSection = document.getElementById('tasks-section');
        if (tasksSection) {
            tasksSection.classList.remove('doc-open');
        }
    }
    
    // Expose docs functions globally
    window.initDocsModule = initDocsModule;
    window.loadDocsFromFirestore = loadDocsFromFirestore;
    window.switchTasksView = switchTasksView;
    window.openDoc = openDoc;
    window.closeDocPanel = closeDocPanel;
    window.cleanupDocsState = cleanupDocsState;
    window.openCreateDocModal = openCreateDocModal;

    // Show task details in a clean modal
    window.showTaskDetails = function(task) {
        // Find creator info using unified identity resolver
        const creatorIdentity = getIdentity(task.createdBy, 'Unknown');
        const creatorName = creatorIdentity.displayName;
        const creatorColor = creatorIdentity.avatarColor;
        const creatorInitials = creatorIdentity.initials;

        // Find assignee info using unified identity resolver
        const assigneeIdentity = task.assigneeId ? getIdentity(task.assigneeId, task.assignee) : { displayName: task.assignee || 'Unassigned', avatarColor: '#8E8E93', initials: '?' };
        const assigneeName = assigneeIdentity.displayName;
        const assigneeColor = assigneeIdentity.avatarColor;
        const assigneeInitials = assigneeIdentity.initials;

        const modalHTML = `
            <div class="modal active" id="taskDetailsModal">
                <div class="modal-content" style="max-width: 650px;">
                    <div class="modal-header">
                        <h2><i class="fas fa-tasks"></i> Task Details</h2>
                        <button class="modal-close" onclick="closeTaskDetailsModal()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="modal-body" style="padding: 32px;">
                        <div class="task-details-container">
                            <h3 class="task-details-title">${task.title}</h3>
                            
                            <div class="task-details-meta">
                                <div class="task-details-row">
                                    <div class="task-detail-item">
                                        <span class="detail-label"><i class="fas fa-user"></i> Created by</span>
                                        <div class="task-user-info">
                                            <div class="task-user-avatar" style="background: ${creatorColor};">${creatorInitials}</div>
                                            <span class="detail-value">${creatorName}</span>
                                        </div>
                                    </div>
                                    
                                    <div class="task-detail-item">
                                        <span class="detail-label"><i class="fas fa-user-check"></i> Assigned to</span>
                                        <div class="task-user-info">
                                            <div class="task-user-avatar" style="background: ${assigneeColor};">${assigneeInitials}</div>
                                            <span class="detail-value">${assigneeName}</span>
                                        </div>
                                    </div>
                                </div>

                                <div class="task-details-row">
                                    <div class="task-detail-item">
                                        <span class="detail-label"><i class="fas fa-circle-notch"></i> Status</span>
                                        <span class="detail-value status-badge status-${task.status}">${task.status === 'todo' ? 'To Do' : task.status === 'inprogress' ? 'In Progress' : 'Done'}</span>
                                    </div>
                                    
                                    <div class="task-detail-item">
                                        <span class="detail-label"><i class="fas fa-flag"></i> Priority</span>
                                        <span class="detail-value priority-badge priority-${task.priority}">${task.priority.charAt(0).toUpperCase() + task.priority.slice(1)}</span>
                                    </div>
                                </div>

                                ${task.dueDate ? `
                                <div class="task-detail-item full-width">
                                    <span class="detail-label"><i class="fas fa-calendar-alt"></i> Due Date</span>
                                    <span class="detail-value">${new Date(task.dueDate).toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })}</span>
                                </div>
                                ` : ''}
                            </div>

                            ${task.description ? `
                            <div class="task-details-description">
                                <span class="detail-label"><i class="fas fa-align-left"></i> Description</span>
                                <p class="detail-description">${task.description}</p>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                </div>
            </div>
        `;

        // Remove existing modal if any
        const existing = document.getElementById('taskDetailsModal');
        if (existing) existing.remove();

        // Add to body
        document.body.insertAdjacentHTML('beforeend', modalHTML);

        // Close on backdrop click
        document.getElementById('taskDetailsModal').addEventListener('click', (e) => {
            if (e.target.id === 'taskDetailsModal') {
                closeTaskDetailsModal();
            }
        });
    };

    window.closeTaskDetailsModal = function() {
        const modal = document.getElementById('taskDetailsModal');
        if (modal) modal.remove();
    };
}

// Update task status
// RECURRING TASKS: When a recurring task is completed, reschedule it instead of leaving it done
async function updateTaskStatus(taskId, newStatus) {
    const task = appState.tasks.find(t => String(t.id) === String(taskId));
    if (!task) return;
    
    const oldStatus = task.status;
    
    // RECURRING TASKS: Handle completion-based rescheduling
    // If task is being marked done AND it's recurring, reschedule instead
    if (newStatus === 'done' && task.isRecurring && task.recurrence) {
        const currentDueDate = normalizeTaskDate(task.dueDate);
        if (currentDueDate) {
            const nextDueDate = calculateNextDueDate(currentDueDate, task.recurrence.frequency, task.recurrence.interval || 1);
            
            // Update task with new due date and reset status
            task.dueDate = nextDueDate.getTime();
            task.status = 'todo';  // Reset to todo for next occurrence
            task.progress = 0;     // Reset progress
            task.recurrence.nextDueAt = calculateNextDueDate(nextDueDate, task.recurrence.frequency, task.recurrence.interval || 1).getTime();
            
            // Update in Firestore with rescheduled data
            if (db && currentAuthUser && appState.currentTeamId) {
                try {
                    const { doc, updateDoc, serverTimestamp, Timestamp } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
                    const taskRef = doc(db, 'teams', appState.currentTeamId, 'tasks', String(taskId));
                    await updateDoc(taskRef, { 
                        status: 'todo',
                        progress: 0,
                        dueDate: Timestamp.fromMillis(task.dueDate),
                        recurrence: task.recurrence,
                        updatedAt: serverTimestamp()
                    });
                    
                    debugLog('ðŸ”„ Recurring task rescheduled:', taskId, 'new due:', new Date(task.dueDate).toLocaleDateString());
                    showToast(`"${task.title}" rescheduled to ${new Date(task.dueDate).toLocaleDateString()}`, 'success', 3000);
                    
                    // Add activity for recurring task completion
                    const spreadsheet = appState.spreadsheets.find(s => s.id === task.spreadsheetId);
                    const isPrivateSpreadsheet = spreadsheet && spreadsheet.visibility === 'private';
                    
                    if (!isPrivateSpreadsheet) {
                        addActivity({
                            type: 'task',
                            description: `completed recurring task "${task.title}" (rescheduled)`
                        });
                    }
                    
                } catch (error) {
                    console.error('Error rescheduling recurring task:', error.code || error.message);
                }
            }
            
            // Update local storage
            saveToLocalStorage('tasks', appState.tasks);
            
            // Refresh display
            if (window.displayTasks) {
                window.displayTasks();
            }
            return; // Exit early - don't do normal status update
        }
    }
    
    // Normal (non-recurring) task status update
    task.status = newStatus;
    
    // Update in Firestore
    if (db && currentAuthUser && appState.currentTeamId) {
        try {
            const { doc, updateDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
            const taskRef = doc(db, 'teams', appState.currentTeamId, 'tasks', String(taskId));
            await updateDoc(taskRef, { 
                status: newStatus,
                updatedAt: serverTimestamp()
            });
            
            debugLog('âœ… Task status updated:', taskId, newStatus);
            
            // Add activity only if NOT a private spreadsheet task
            const spreadsheet = appState.spreadsheets.find(s => s.id === task.spreadsheetId);
            const isPrivateSpreadsheet = spreadsheet && spreadsheet.visibility === 'private';
            
            if (!isPrivateSpreadsheet) {
                const statusText = newStatus === 'todo' ? 'To Do' : newStatus === 'in-progress' ? 'In Progress' : 'Done';
                addActivity({
                    type: 'task',
                    description: `marked task "${task.title}" as ${statusText}`
                });
            }
            
        } catch (error) {
            console.error('Error updating task status:', error.code || error.message);
            task.status = oldStatus; // Revert on error
        }
    }
    
    // Update local storage
    saveToLocalStorage('tasks', appState.tasks);
    
    // Refresh display
    if (window.displayTasks) {
        window.displayTasks();
    }
}

// Populate task assignee dropdown with team members
function populateTaskAssigneeDropdown() {
    const menu = document.getElementById('taskAssigneeMenu');
    const trigger = document.getElementById('taskAssigneeTrigger');
    const hiddenInput = document.getElementById('taskAssignee');
    
    if (!menu || !trigger || !hiddenInput) return;
    
    // Clear existing options
    menu.innerHTML = '';
    
    let optionsHTML = '';
    let firstMember = null;
    
    // Add "Team" option first - for tasks with no specific owner
    optionsHTML += `
        <div class="dropdown-menu-option" data-value="team" data-name="Team">
            <div class="dropdown-assignee-avatar team-avatar"><i class="fas fa-users"></i></div>
            <span>Team</span>
        </div>
    `;
    
    // Add current user - use unified identity resolver
    if (currentAuthUser) {
        const identity = getIdentity(currentAuthUser.uid, currentAuthUser.displayName || currentAuthUser.email);
        const displayName = identity.displayName;
        const initials = identity.initials;
        const color = identity.avatarColor;
        firstMember = { id: currentAuthUser.uid, name: displayName, initials, color };
        
        optionsHTML += `
            <div class="dropdown-menu-option" data-value="${currentAuthUser.uid}" data-name="${escapeHtml(displayName)}">
                <div class="dropdown-assignee-avatar" style="background: ${color}">${initials}</div>
                <span>${escapeHtml(displayName)} (You)</span>
            </div>
        `;
    }
    
    // Add team members
    if (appState.teammates && appState.teammates.length > 0) {
        appState.teammates.forEach(teammate => {
            // Skip current user (already added)
            if (currentAuthUser && teammate.id === currentAuthUser.uid) return;
            
            // Use unified identity resolver for consistent display
            const identity = getIdentity(teammate.id, teammate.name || teammate.email);
            const name = identity.displayName;
            const initials = identity.initials;
            const color = identity.avatarColor;
            
            if (!firstMember) {
                firstMember = { id: teammate.id, name, initials, color };
            }
            
            optionsHTML += `
                <div class="dropdown-menu-option" data-value="${teammate.id}" data-name="${escapeHtml(name)}">
                    <div class="dropdown-assignee-avatar" style="background: ${color}">${initials}</div>
                    <span>${escapeHtml(name)}</span>
                </div>
            `;
        });
    }
    
    menu.innerHTML = optionsHTML || '<div class="dropdown-menu-option" style="color: var(--text-muted); cursor: default;">No team members</div>';
    
    // Set first member as default
    if (firstMember) {
        hiddenInput.value = firstMember.id;
        const triggerContent = trigger.querySelector('.dropdown-trigger-content') || trigger.querySelector('.unified-dropdown-value');
        if (triggerContent) {
            triggerContent.innerHTML = `
                <div class="dropdown-assignee-avatar" style="background: ${firstMember.color}">${firstMember.initials}</div>
                <span>${escapeHtml(firstMember.name)}</span>
            `;
        }
        // Mark as active
        const firstOption = menu.querySelector(`[data-value="${firstMember.id}"]`);
        if (firstOption) {
            firstOption.classList.add('active');
            firstOption.innerHTML += '<i class="fas fa-check"></i>';
        }
    }
}

// Populate task spreadsheet dropdown with available spreadsheets
function populateTaskSpreadsheetDropdown(defaultSpreadsheetId = null) {
    const menu = document.getElementById('taskSpreadsheetMenu');
    const trigger = document.getElementById('taskSpreadsheetTrigger');
    const hiddenInput = document.getElementById('taskSpreadsheet');
    
    if (!menu || !trigger || !hiddenInput) return;
    
    // Clear existing options
    menu.innerHTML = '';
    
    let optionsHTML = `
        <div class="dropdown-menu-option active" data-value="default">
            <i class="fas fa-list dropdown-icon"></i>
            <span>All Tasks</span>
            <i class="fas fa-check"></i>
        </div>
    `;
    
    // Add user's spreadsheets (visible ones only)
    if (appState.spreadsheets && appState.spreadsheets.length > 0) {
        appState.spreadsheets.forEach(spreadsheet => {
            if (spreadsheet.id === 'default') return; // Skip default, already added
            
            // Check visibility - only show team spreadsheets or own private spreadsheets
            if (spreadsheet.visibility === 'private' && 
                currentAuthUser && spreadsheet.createdBy !== currentAuthUser.uid) {
                return;
            }
            
            const icon = spreadsheet.icon || 'fa-table';
            optionsHTML += `
                <div class="dropdown-menu-option" data-value="${spreadsheet.id}">
                    <i class="fas ${icon} dropdown-icon"></i>
                    <span>${escapeHtml(spreadsheet.name)}</span>
                </div>
            `;
        });
    }
    
    menu.innerHTML = optionsHTML;
    
    // Set default selection
    let selectedId = 'default';
    if (defaultSpreadsheetId) {
        selectedId = defaultSpreadsheetId;
    } else if (appState.currentSpreadsheet && appState.currentSpreadsheet.id !== 'default') {
        selectedId = appState.currentSpreadsheet.id;
    }
    
    hiddenInput.value = selectedId;
    
    // Update trigger and active state
    const selectedOption = menu.querySelector(`[data-value="${selectedId}"]`);
    if (selectedOption) {
        // Remove active from all
        menu.querySelectorAll('.dropdown-menu-option').forEach(opt => {
            opt.classList.remove('active');
            const check = opt.querySelector('.fa-check');
            if (check) check.remove();
        });
        // Add active to selected
        selectedOption.classList.add('active');
        selectedOption.innerHTML += '<i class="fas fa-check"></i>';
        
        const icon = selectedOption.querySelector('.dropdown-icon');
        const text = selectedOption.querySelector('span').textContent;
        const triggerContent = trigger.querySelector('.dropdown-trigger-content') || trigger.querySelector('.unified-dropdown-value');
        if (triggerContent) {
            triggerContent.innerHTML = `
                <i class="fas ${icon ? icon.classList[1] : 'fa-table'} dropdown-icon"></i>
                <span>${text}</span>
            `;
        }
    }
}

// ===================================
// TASK MODAL CUSTOM DROPDOWNS
// Initialize Apple-like dropdown components
// ===================================
function initTaskModalDropdowns() {
    // Priority dropdown
    setupCustomDropdown('taskPriority', (value, option) => {
        const dot = option.querySelector('.priority-dot, .unified-priority-dot');
        const label = option.querySelector('span:not(.priority-dot):not(.unified-priority-dot)').textContent;
        return `
            <span class="unified-priority-dot ${value}"></span>
            <span>${label}</span>
        `;
    });
    
    // Status dropdown
    setupCustomDropdown('taskStatus', (value, option) => {
        const label = option.querySelector('span:not(.status-dot):not(.unified-status-dot)').textContent;
        return `
            <span class="unified-status-dot ${value}"></span>
            <span>${label}</span>
        `;
    });
    
    // Assignee dropdown
    setupCustomDropdown('taskAssignee', (value, option) => {
        const avatar = option.querySelector('.dropdown-assignee-avatar, .unified-assignee-avatar');
        const name = option.dataset.name || option.querySelector('span').textContent;
        if (avatar) {
            return `
                <div class="unified-assignee-avatar" style="${avatar.getAttribute('style')}">${avatar.textContent}</div>
                <span>${name}</span>
            `;
        }
        return `<span>${name}</span>`;
    });
    
    // Spreadsheet dropdown
    setupCustomDropdown('taskSpreadsheet', (value, option) => {
        const icon = option.querySelector('.dropdown-icon, .unified-dropdown-icon');
        const text = option.querySelector('span').textContent;
        return `
            <i class="fas ${icon ? icon.classList[1] : 'fa-table'} unified-dropdown-icon"></i>
            <span>${text}</span>
        `;
    });
    
    // RECURRING TASKS: Recurrence dropdown
    setupCustomDropdown('taskRecurrence', (value, option) => {
        const icon = option.querySelector('i');
        const text = option.querySelector('span').textContent;
        // Show/hide recurrence hint based on selection
        const hint = document.getElementById('recurrenceHint');
        if (hint) {
            hint.style.display = value !== 'none' ? 'block' : 'none';
        }
        if (icon && value !== 'none') {
            return `<i class="${icon.className}" style="${icon.getAttribute('style')}"></i><span>${text}</span>`;
        }
        return `<span>${text}</span>`;
    });
}

function setupCustomDropdown(inputId, getTriggerContent) {
    const container = document.getElementById(inputId + 'Dropdown');
    const trigger = document.getElementById(inputId + 'Trigger');
    const menu = document.getElementById(inputId + 'Menu');
    const hiddenInput = document.getElementById(inputId);
    
    if (!container || !trigger || !menu || !hiddenInput) return;
    
    // Toggle dropdown on trigger click
    trigger.addEventListener('click', (e) => {
        e.stopPropagation();
        
        // Close other dropdowns first (support both old and unified classes)
        document.querySelectorAll('.custom-dropdown-menu.visible, .unified-dropdown-menu.visible').forEach(m => {
            if (m !== menu) {
                m.classList.remove('visible');
                const parentContainer = m.closest('.custom-dropdown-container') || m.closest('.unified-dropdown');
                const parentTrigger = parentContainer?.querySelector('.custom-dropdown-trigger, .unified-dropdown-trigger');
                parentTrigger?.classList.remove('active');
            }
        });
        
        const isOpen = menu.classList.contains('visible');
        menu.classList.toggle('visible');
        trigger.classList.toggle('active');
    });
    
    // Handle option selection (support both old and unified classes)
    menu.addEventListener('click', (e) => {
        const option = e.target.closest('.dropdown-menu-option, .unified-dropdown-option');
        if (!option || option.style.cursor === 'default') return;
        
        const value = option.dataset.value;
        
        // Update hidden input
        hiddenInput.value = value;
        
        // Update active state (support both old and unified classes)
        menu.querySelectorAll('.dropdown-menu-option, .unified-dropdown-option').forEach(opt => {
            opt.classList.remove('active', 'selected');
            const check = opt.querySelector('.fa-check');
            if (check) check.style.opacity = '0';
        });
        option.classList.add('active', 'selected');
        const checkIcon = option.querySelector('.fa-check');
        if (checkIcon) checkIcon.style.opacity = '1';
        
        // Update trigger content (support both old and unified classes)
        const triggerContent = trigger.querySelector('.dropdown-trigger-content, .unified-dropdown-value');
        if (getTriggerContent && triggerContent) {
            triggerContent.innerHTML = getTriggerContent(value, option);
        }
        
        // Close dropdown
        menu.classList.remove('visible');
        trigger.classList.remove('active');
    });
    
    // Close on outside click
    document.addEventListener('click', (e) => {
        if (!container.contains(e.target)) {
            menu.classList.remove('visible');
            trigger.classList.remove('active');
        }
    });
}

// ===================================
// 20-WORD LIMIT FOR TASK TITLE
// Real-time enforcement while typing
// ===================================
function initTaskTitleWordLimit() {
    const titleInput = document.getElementById('taskTitle');
    const counter = document.getElementById('taskTitleCounter');
    const MAX_WORDS = 20;
    
    if (!titleInput || !counter) return;
    
    titleInput.addEventListener('input', (e) => {
        let text = e.target.value;
        const words = text.split(/\s+/).filter(word => word.length > 0);
        const wordCount = words.length;
        
        // Update counter
        counter.textContent = `${wordCount}/${MAX_WORDS} words`;
        
        // Update counter style based on word count
        counter.classList.remove('warning', 'limit');
        if (wordCount >= MAX_WORDS) {
            counter.classList.add('limit');
        } else if (wordCount >= MAX_WORDS - 5) {
            counter.classList.add('warning');
        }
        
        // If over limit, truncate to MAX_WORDS
        if (wordCount > MAX_WORDS) {
            // Get the position where we need to cut
            const truncatedWords = words.slice(0, MAX_WORDS);
            const truncatedText = truncatedWords.join(' ');
            
            // Preserve cursor position as much as possible
            const cursorPos = e.target.selectionStart;
            e.target.value = truncatedText;
            
            // Set cursor at end if it was beyond truncation point
            const newCursorPos = Math.min(cursorPos, truncatedText.length);
            e.target.setSelectionRange(newCursorPos, newCursorPos);
            
            // Update counter
            counter.textContent = `${MAX_WORDS}/${MAX_WORDS} words`;
            counter.classList.add('limit');
        }
    });
    
    // Also handle paste events
    titleInput.addEventListener('paste', (e) => {
        // Let the paste happen, then check word count
        setTimeout(() => {
            titleInput.dispatchEvent(new Event('input'));
        }, 0);
    });
}

// ===================================
// TASK MODAL PROGRESS BAR
// Modern gradient progress bar
// ===================================
function initTaskModalProgressSlider() {
    const progressInput = document.getElementById('taskProgress');
    const progressFill = document.getElementById('taskProgressFill');
    
    if (!progressInput) return;
    
    progressInput.addEventListener('input', (e) => {
        let value = parseInt(e.target.value) || 0;
        value = Math.max(0, Math.min(100, value));
        if (progressFill) {
            progressFill.style.width = value + '%';
        }
    });
    
    progressInput.addEventListener('change', (e) => {
        let value = parseInt(e.target.value) || 0;
        value = Math.max(0, Math.min(100, value));
        progressInput.value = value;
        if (progressFill) {
            progressFill.style.width = value + '%';
        }
    });
}

// ===================================
// RESET TASK MODAL DROPDOWNS
// Called when opening modal for new task
// ===================================
function resetTaskModalDropdowns() {
    // Reset Priority to Medium
    const priorityTrigger = document.getElementById('taskPriorityTrigger');
    const priorityInput = document.getElementById('taskPriority');
    const priorityMenu = document.getElementById('taskPriorityMenu');
    if (priorityTrigger && priorityInput && priorityMenu) {
        priorityInput.value = 'medium';
        const priorityTriggerContent = priorityTrigger.querySelector('.dropdown-trigger-content') || priorityTrigger.querySelector('.unified-dropdown-value');
        if (priorityTriggerContent) {
            priorityTriggerContent.innerHTML = `
                <span class="unified-priority-dot medium"></span>
                <span>Medium</span>
            `;
        }
        priorityMenu.querySelectorAll('.dropdown-menu-option').forEach(opt => {
            opt.classList.remove('active');
            const check = opt.querySelector('.fa-check');
            if (check) check.remove();
            if (opt.dataset.value === 'medium') {
                opt.classList.add('active');
                opt.innerHTML += '<i class="fas fa-check"></i>';
            }
        });
    }
    
    // Reset Status to To Do
    const statusTrigger = document.getElementById('taskStatusTrigger');
    const statusInput = document.getElementById('taskStatus');
    const statusMenu = document.getElementById('taskStatusMenu');
    if (statusTrigger && statusInput && statusMenu) {
        statusInput.value = 'todo';
        const statusTriggerContent = statusTrigger.querySelector('.dropdown-trigger-content') || statusTrigger.querySelector('.unified-dropdown-value');
        if (statusTriggerContent) {
            statusTriggerContent.innerHTML = `
                <span class="unified-status-dot todo"></span>
                <span>To Do</span>
            `;
        }
        statusMenu.querySelectorAll('.dropdown-menu-option').forEach(opt => {
            opt.classList.remove('active');
            const check = opt.querySelector('.fa-check');
            if (check) check.remove();
            if (opt.dataset.value === 'todo') {
                opt.classList.add('active');
                opt.innerHTML += '<i class="fas fa-check"></i>';
            }
        });
    }
    
    // Reset Assignee placeholder
    const assigneeTrigger = document.getElementById('taskAssigneeTrigger');
    const assigneeInput = document.getElementById('taskAssignee');
    if (assigneeTrigger && assigneeInput) {
        assigneeInput.value = '';
        const assigneeTriggerContent = assigneeTrigger.querySelector('.dropdown-trigger-content') || assigneeTrigger.querySelector('.unified-dropdown-value');
        if (assigneeTriggerContent) {
            assigneeTriggerContent.innerHTML = `
                <span class="dropdown-placeholder">Select...</span>
            `;
        }
    }
    
    // Reset Progress (range slider + number input + fill + badge)
    const progressInput = document.getElementById('taskProgress');
    const progressSlider = document.getElementById('taskProgressSlider');
    const progressFill = document.getElementById('taskProgressFill');
    const progressBadge = document.getElementById('taskProgressBadge');
    if (progressInput) {
        progressInput.value = 0;
        if (progressSlider) {
            progressSlider.value = 0;
            progressSlider.style.setProperty('--progress', '0%');
        }
        if (progressFill) {
            progressFill.style.width = '0%';
        }
        if (progressBadge) {
            progressBadge.textContent = '0%';
        }
    }
    
    // Reset word counter
    const counter = document.getElementById('taskTitleCounter');
    if (counter) {
        counter.textContent = '0/20 words';
        counter.classList.remove('warning', 'limit');
    }
}

// Delete task function (global for onclick access)
window.deleteTask = async function(taskId, event) {
    if (DEBUG) console.log('ðŸ—‘ï¸ Delete task called with ID:', taskId);
    
    // Find the task to check permissions
    const taskIdStr = String(taskId);
    const task = appState.tasks.find(t => String(t.id) === taskIdStr);
    
    // Check permissions: admin/owner can delete any task, members can only delete their own
    if (db && currentAuthUser && appState.currentTeamId) {
        try {
            const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
            const teamRef = doc(db, 'teams', appState.currentTeamId);
            const teamDoc = await getDoc(teamRef);
            const teamData = teamDoc.data();
            
            const userRole = getCurrentUserRole(teamData);
            const isAdminOrOwner = userRole === 'admin' || userRole === 'owner';
            const isCreator = task && task.createdBy === currentAuthUser.uid;
            
            if (!isAdminOrOwner && !isCreator) {
                showToast('You can only delete tasks you created.', 'error');
                return;
            }
        } catch (error) {
            console.error('Error checking permissions:', error);
        }
    }
    
    // Show custom delete popup near cursor
    showDeleteConfirmPopup(taskId, task?.title || 'this task', event);
        if (DEBUG) {
            console.log('ðŸ“Š Current state:', {
                db: !!db,
                currentAuthUser: !!currentAuthUser,
                currentTeamId: appState.currentTeamId
            });
        }
        
        const taskTitle = task ? task.title : 'Unknown';
        if (DEBUG) console.log('ðŸ“Œ Found task:', task);
        
        // Delete from Firestore FIRST (before removing from local state)
        if (db && currentAuthUser && appState.currentTeamId) {
            try {
                const { doc, deleteDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
                const taskPath = `teams/${appState.currentTeamId}/tasks/${taskIdStr}`;
                if (DEBUG) console.log('ðŸ”¥ Attempting to delete from Firestore path:', taskPath);
                
                const taskRef = doc(db, 'teams', appState.currentTeamId, 'tasks', taskIdStr);
                await deleteDoc(taskRef);
                debugLog('âœ… Task deleted from Firestore successfully');
                
                // Add to activity feed only if NOT a private spreadsheet task
                const spreadsheet = appState.spreadsheets.find(s => s.id === task?.spreadsheetId);
                const isPrivateSpreadsheet = spreadsheet && spreadsheet.visibility === 'private';
                
                if (!isPrivateSpreadsheet) {
                    addActivity({
                        type: 'task',
                        description: `deleted task "${taskTitle}"`
                    });
                }
            } catch (error) {
                console.error('âŒ Error deleting task from Firestore:', error.code || error.message);
                
                // If task doesn't exist in Firestore (old task), allow local deletion
                if (error.code === 'not-found' || error.message.includes('No document to update')) {
                    console.log('âš ï¸ Task not found in Firestore (probably an old task). Deleting locally only.');
                } else {
                    showToast('Error deleting task from database. Please try again.', 'error', 5000, 'Delete Failed');
                    return; // Don't delete from local state if it's a real error
                }
            }
        } else {
            console.warn('âš ï¸ Skipping Firestore deletion - missing requirements');
        }
        
        // Remove from local state AFTER successful Firestore deletion
        appState.tasks = appState.tasks.filter(t => String(t.id) !== taskIdStr);
        saveToLocalStorage('tasks', appState.tasks);
        console.log('âœ… Task removed from local state');
        
        // Update display
        window.displayTasks();
};

// Show custom delete confirmation popup near cursor
function showDeleteConfirmPopup(taskId, taskTitle, event) {
    // Remove any existing popup
    const existing = document.querySelector('.delete-confirm-popup');
    if (existing) existing.remove();
    
    // Get click position
    let x = event?.clientX || window.innerWidth / 2;
    let y = event?.clientY || window.innerHeight / 2;
    
    const popup = document.createElement('div');
    popup.className = 'delete-confirm-popup';
    popup.innerHTML = `
        <div class="delete-popup-content">
            <p>Delete <strong>${taskTitle}</strong>?</p>
            <div class="delete-popup-actions">
                <button class="delete-popup-btn cancel" onclick="closeDeletePopup()">Cancel</button>
                <button class="delete-popup-btn confirm" onclick="confirmDeleteTask('${taskId}')">Delete</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(popup);
    
    // Position popup near cursor (adjust to keep on screen)
    const rect = popup.getBoundingClientRect();
    const padding = 10;
    
    // Position to left of cursor so delete button is near cursor
    x = Math.min(x - 20, window.innerWidth - rect.width - padding);
    x = Math.max(padding, x);
    y = Math.min(y - rect.height / 2, window.innerHeight - rect.height - padding);
    y = Math.max(padding, y);
    
    popup.style.left = x + 'px';
    popup.style.top = y + 'px';
    
    // Close on outside click
    setTimeout(() => {
        document.addEventListener('click', closeDeletePopupOutside);
    }, 10);
}

function closeDeletePopupOutside(e) {
    const popup = document.querySelector('.delete-confirm-popup');
    if (popup && !popup.contains(e.target)) {
        closeDeletePopup();
    }
}

window.closeDeletePopup = function() {
    const popup = document.querySelector('.delete-confirm-popup');
    if (popup) popup.remove();
    document.removeEventListener('click', closeDeletePopupOutside);
};

window.confirmDeleteTask = async function(taskId) {
    closeDeletePopup();
    
    const taskIdStr = String(taskId);
    const task = appState.tasks.find(t => String(t.id) === taskIdStr);
    const taskTitle = task ? task.title : 'Unknown';
    
    if (DEBUG) {
        console.log('ðŸ“Š Current state:', {
            db: !!db,
            currentAuthUser: !!currentAuthUser,
            currentTeamId: appState.currentTeamId
        });
    }
    
    if (DEBUG) console.log('ðŸ“Œ Found task:', task);
    
    // Delete from Firestore FIRST (before removing from local state)
    if (db && currentAuthUser && appState.currentTeamId) {
        try {
            const { doc, deleteDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
            const taskPath = `teams/${appState.currentTeamId}/tasks/${taskIdStr}`;
            if (DEBUG) console.log('ðŸ”¥ Attempting to delete from Firestore path:', taskPath);
            
            const taskRef = doc(db, 'teams', appState.currentTeamId, 'tasks', taskIdStr);
            await deleteDoc(taskRef);
            debugLog('âœ… Task deleted from Firestore successfully');
            
            // Add to activity feed
            addActivity({
                type: 'task',
                description: `deleted task "${taskTitle}"`
            });
        } catch (error) {
            console.error('âŒ Error deleting task from Firestore:', error.code || error.message);
            
            // If task doesn't exist in Firestore (old task), allow local deletion
            if (error.code === 'not-found' || error.message.includes('No document to update')) {
                console.log('âš ï¸ Task not found in Firestore (probably an old task). Deleting locally only.');
            } else {
                showToast('Error deleting task from database. Please try again.', 'error', 5000, 'Delete Failed');
                return; // Don't delete from local state if it's a real error
            }
        }
    } else {
        console.warn('âš ï¸ Skipping Firestore deletion - missing requirements');
    }
    
    // Remove from local state AFTER successful Firestore deletion
    appState.tasks = appState.tasks.filter(t => String(t.id) !== taskIdStr);
    saveToLocalStorage('tasks', appState.tasks);
    console.log('âœ… Task removed from local state');
    
    // Update display
    window.displayTasks();
    showToast('Task deleted', 'success');
};

// ===================================
// ACTIVITY FEED
// ===================================
function initActivityFeed() {
    // Activities are now loaded in loadTeamData() after team is initialized
    displayActivities();
    
    // Set up "See All" button click handler
    const seeAllBtn = document.getElementById('seeAllActivitiesBtn');
    if (seeAllBtn) {
        seeAllBtn.addEventListener('click', () => {
            showAllActivities = !showAllActivities;
            displayActivities();
        });
    }
}

// Add activity to Firestore
async function addActivity(activity) {
    if (!db || !currentAuthUser || !appState.currentTeamId) {
        debugLog('Cannot add activity: missing db, auth, or teamId');
        return;
    }
    
    try {
        const { collection, addDoc, serverTimestamp } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const activitiesRef = collection(db, 'teams', appState.currentTeamId, 'activities');
        
        // Use unified identity resolver for consistent username
        const identity = getIdentity(currentAuthUser.uid, currentAuthUser.email?.split('@')[0]);
        const username = identity.displayName;
        
        // SECURITY: Rules require createdBy == request.auth.uid
        const activityData = {
            type: activity.type,
            createdBy: currentAuthUser.uid, // Required by rules - canonical uid field
            userName: username,  // Use SSOT-resolved username
            description: activity.description,
            createdAt: serverTimestamp()
        };
        
        await addDoc(activitiesRef, activityData);
        debugLog('âœ… Activity added to Firestore');
        
    } catch (error) {
        console.error('Error adding activity:', error.code || error.message);
        debugError('Full error:', error);
    }
}

// Track whether all activities are shown
let showAllActivities = false;
const MAX_VISIBLE_ACTIVITIES = 5;

function displayActivities() {
    const activityFeed = document.querySelector('.activity-feed');
    if (!activityFeed) return;

    // Keep the existing sample activities if no saved activities
    if (appState.activities.length === 0) return;

    activityFeed.innerHTML = '';
    
    console.log(`ðŸ“Š Displaying ${appState.activities.length} activities`);

    // Determine how many activities to show
    const activitiesToShow = showAllActivities 
        ? appState.activities 
        : appState.activities.slice(0, MAX_VISIBLE_ACTIVITIES);
    
    // Update the "See All" button visibility and text
    const seeAllBtn = document.getElementById('seeAllActivitiesBtn');
    if (seeAllBtn) {
        if (appState.activities.length > MAX_VISIBLE_ACTIVITIES) {
            seeAllBtn.style.display = 'inline-block';
            seeAllBtn.textContent = showAllActivities ? 'Show Less' : `See All (${appState.activities.length})`;
        } else {
            seeAllBtn.style.display = 'none';
        }
    }

    activitiesToShow.forEach(activity => {
        
        const iconClass = activity.type === 'task' ? 'task-icon' : 
                         activity.type === 'message' ? 'message-icon' : 
                         activity.type === 'team' ? 'team-icon' : 'calendar-icon';
        const icon = activity.type === 'task' ? 'fa-check-circle' : 
                    activity.type === 'message' ? 'fa-comment' : 
                    activity.type === 'team' ? 'fa-user-plus' : 'fa-calendar';

        const activityEl = document.createElement('div');
        activityEl.className = 'activity-item';
        
        // Create icon container
        const iconDiv = document.createElement('div');
        iconDiv.className = `activity-icon ${iconClass}`;
        const iconElement = document.createElement('i');
        iconElement.className = `fas ${icon}`;
        iconDiv.appendChild(iconElement);
        
        // Create content container
        const contentDiv = document.createElement('div');
        contentDiv.className = 'activity-content';
        
        // Create header with user name and description
        const headerDiv = document.createElement('div');
        headerDiv.className = 'activity-header';
        
        // Use unified identity resolver for consistent display
        const identity = getIdentity(activity.createdBy, activity.userName || activity.user);
        const displayName = identity.displayName;
        
        const userNameStrong = document.createElement('strong');
        userNameStrong.textContent = displayName; // Use textContent for user name
        
        const descriptionText = document.createTextNode(' ' + activity.description); // Use textNode for description
        
        headerDiv.appendChild(userNameStrong);
        headerDiv.appendChild(descriptionText);
        
        // Create time element
        const timeDiv = document.createElement('div');
        timeDiv.className = 'activity-time';
        timeDiv.textContent = activity.timeAgo; // Use textContent for time
        
        contentDiv.appendChild(headerDiv);
        contentDiv.appendChild(timeDiv);
        
        activityEl.appendChild(iconDiv);
        activityEl.appendChild(contentDiv);
        
        activityFeed.appendChild(activityEl);
    });
}

// Load activities from Firestore with real-time listener
async function loadActivities() {
    if (!db || !currentAuthUser || !appState.currentTeamId) {
        debugLog('Cannot load activities: missing db, auth, or teamId');
        return;
    }
    
    try {
        const { collection, query, onSnapshot, orderBy, limit } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const activitiesRef = collection(db, 'teams', appState.currentTeamId, 'activities');
        const q = query(activitiesRef, orderBy('createdAt', 'desc'), limit(50));
        
        // Real-time listener
        onSnapshot(q, (querySnapshot) => {
            const activities = [];
            querySnapshot.forEach((doc) => {
                const data = doc.data();
                const timestamp = data.createdAt?.toDate ? data.createdAt.toDate() : new Date();
                
                // Normalize uid field: prefer createdBy, fallback to userId/authorId for backward compat
                const uid = data.createdBy || data.userId || data.authorId || null;
                
                activities.push({
                    id: doc.id,
                    type: data.type,
                    user: data.userName,
                    userName: data.userName,
                    userId: uid, // Keep for backward compat
                    createdBy: uid, // Canonical uid field
                    description: data.description,
                    timestamp: timestamp,
                    timeAgo: getTimeAgo(timestamp)
                });
            });
            
            appState.activities = activities;
            debugLog(`âœ… Loaded ${activities.length} activities`);
            displayActivities();
            updateNotifications(activities);
            updateOverview(); // Update overview with latest data
            updateMetricsIfActive(); // Update metrics if active
        }, (error) => {
            // Handle Firestore listener errors (network issues, timeouts, etc.)
            if (error.code === 'unavailable' || error.code === 'deadline-exceeded') {
                debugLog('âš ï¸ Activities listener temporarily unavailable, will auto-retry');
            } else {
                console.error('Error in activities snapshot listener:', error.code || error.message);
                debugError('Full error:', error);
            }
        });
        
    } catch (error) {
        console.error('Error loading activities from Firestore:', error.code || error.message);
        debugError('Full error:', error);
    }
}

// ===================================
// OVERVIEW/DASHBOARD FUNCTIONS
// ===================================
function updateOverview() {
    updateOverviewStats();
    updateOverviewTasks();
    updateOverviewEvents();
}

function updateOverviewStats() {
    // Count my tasks (not done, assigned to current user)
    const uid = currentAuthUser?.uid;
    const displayName = currentAuthUser?.displayName?.toLowerCase();
    const email = currentAuthUser?.email?.toLowerCase();
    
    const myTasks = appState.tasks.filter(task => {
        if (task.status === 'done') return false;
        
        // Check by assigneeId (UID)
        if (task.assigneeId && uid && task.assigneeId === uid) return true;
        
        // Check by assignee name (case-insensitive)
        if (task.assignee && displayName && task.assignee.toLowerCase() === displayName) return true;
        if (task.assignee && email && task.assignee.toLowerCase() === email) return true;
        
        // Check if assignee contains the display name or email
        if (task.assignee && displayName && task.assignee.toLowerCase().includes(displayName)) return true;
        
        return false;
    });
    
    document.getElementById('myTasksCount').textContent = myTasks.length;
    
    // Count upcoming events (within next 30 days)
    const now = new Date();
    now.setHours(0, 0, 0, 0); // Start of today
    const thirtyDaysFromNow = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);
    const upcomingEvents = appState.events.filter(event => {
        const eventDate = event.date instanceof Date ? event.date : new Date(event.date);
        return eventDate >= now && eventDate <= thirtyDaysFromNow;
    });
    document.getElementById('upcomingEventsCount').textContent = upcomingEvents.length;
    
    // Count team members
    document.getElementById('teamMembersCount').textContent = appState.teammates?.length || 0;
}

function updateOverviewTasks() {
    const container = document.getElementById('overviewTasksList');
    if (!container) return;
    
    // Get tasks assigned to current user (not done)
    const uid = currentAuthUser?.uid;
    const displayName = currentAuthUser?.displayName?.toLowerCase();
    const email = currentAuthUser?.email?.toLowerCase();
    
    const myTasks = appState.tasks.filter(task => {
        if (task.status === 'done') return false;
        
        // Check by assigneeId (UID)
        if (task.assigneeId && uid && task.assigneeId === uid) return true;
        
        // Check by assignee name (case-insensitive)
        if (task.assignee && displayName && task.assignee.toLowerCase() === displayName) return true;
        if (task.assignee && email && task.assignee.toLowerCase() === email) return true;
        
        // Check if assignee contains the display name or email
        if (task.assignee && displayName && task.assignee.toLowerCase().includes(displayName)) return true;
        
        return false;
    });
    
    if (myTasks.length === 0) {
        container.innerHTML = '<div class="ov-empty-state">No tasks assigned to you</div>';
        return;
    }
    
    // Sort by priority and due date
    const sortedTasks = myTasks.sort((a, b) => {
        const priorityOrder = { high: 0, medium: 1, low: 2 };
        return priorityOrder[a.priority] - priorityOrder[b.priority];
    }).slice(0, 5); // Show max 5 tasks
    
    container.innerHTML = '';
    sortedTasks.forEach(task => {
        const taskEl = document.createElement('div');
        taskEl.className = 'ov-task-row';
        taskEl.dataset.taskId = task.id;
        taskEl.onclick = (e) => {
            viewTaskDetails && viewTaskDetails(task.id);
        };
        
        // Priority label and class
        const priority = task.priority || 'medium';
        const priorityLabel = priority.charAt(0).toUpperCase() + priority.slice(1);
        
        // Format due date
        const dueDateText = task.dueDate ? formatDueDate(task.dueDate) : 'No date';
        
        taskEl.innerHTML = `
            <div class="ov-task-content">
                <div class="ov-task-title">${escapeHtml(task.title)}</div>
                <div class="ov-task-meta">
                    <div class="ov-task-priority ov-priority-${priority}">${priorityLabel}</div>
                </div>
            </div>
            <div class="ov-task-date">${dueDateText}</div>
        `;
        container.appendChild(taskEl);
    });
}

function updateOverviewEvents() {
    const container = document.getElementById('overviewEventsList');
    if (!container) return;
    
    // Get upcoming events (next 30 days)
    const now = new Date();
    now.setHours(0, 0, 0, 0); // Start of today
    const thirtyDaysFromNow = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);
    
    const upcomingEvents = appState.events.filter(event => {
        // Handle both Date objects and timestamps/strings
        const eventDate = event.date instanceof Date ? event.date : new Date(event.date);
        return eventDate >= now && eventDate <= thirtyDaysFromNow;
    }).sort((a, b) => {
        const dateA = a.date instanceof Date ? a.date : new Date(a.date);
        const dateB = b.date instanceof Date ? b.date : new Date(b.date);
        return dateA - dateB;
    }).slice(0, 5); // Show max 5 events
    
    if (upcomingEvents.length === 0) {
        container.innerHTML = '<div class="ov-empty-state">No upcoming events</div>';
        return;
    }
    
    container.innerHTML = '';
    upcomingEvents.forEach(event => {
        const eventDate = event.date instanceof Date ? event.date : new Date(event.date);
        const timeStr = formatTime24(eventDate.getHours(), eventDate.getMinutes());
        const dayNum = eventDate.getDate();
        const monthAbbr = eventDate.toLocaleString('en-US', { month: 'short' }).toUpperCase();
        
        // Check if event is private or admins-only
        const isPrivate = event.visibility === 'private' || event.visibility === 'admins';
        const visibilityLabel = event.visibility === 'admins' ? 'Admins' : 'Private';
        
        const eventEl = document.createElement('div');
        eventEl.className = 'ov-event-row';
        eventEl.dataset.eventId = event.id;
        eventEl.tabIndex = 0; // Make keyboard focusable
        eventEl.onclick = () => viewEventDetails(event.id);
        eventEl.onkeydown = (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                viewEventDetails(event.id);
            }
        };
        
        eventEl.innerHTML = `
            <div class="ov-event-date">
                <span class="ov-event-day">${dayNum}</span>
                <span class="ov-event-month">${monthAbbr}</span>
            </div>
            <div class="ov-event-title">${escapeHtml(event.title)}</div>
            <div class="ov-event-time">${timeStr}</div>
        `;
        container.appendChild(eventEl);
    });
}

function formatDueDate(dateStr) {
    const date = new Date(dateStr);
    const today = new Date();
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    const diffDays = Math.ceil((date - today) / (1000 * 60 * 60 * 24));
    
    if (diffDays < 0) return 'Overdue';
    if (diffDays === 0) return 'Today';
    if (diffDays === 1) return 'Tomorrow';
    if (diffDays < 7) return `in ${diffDays} days`;
    
    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
}

window.toggleTaskFromOverview = async function(taskId) {
    // Find the task and toggle it
    const task = appState.tasks.find(t => t.id === taskId);
    if (task) {
        const newStatus = task.status === 'done' ? 'todo' : 'done';
        await updateTaskStatus(taskId, newStatus);
        updateOverview();
    }
};

// ===================================
// METRICS COMPUTATION & RENDERING
// ===================================

/**
 * CUSTOMIZABLE METRICS SYSTEM
 * ===========================
 * 
 * Users can add, remove, and reorder custom business metrics.
 * The configuration is stored in team.settings.enabledMetrics.
 * 
 * PERMISSIONS:
 * - Only owners can edit which metrics are shown (add/remove/reorder)
 * - canEditMetrics() checks for owner role before any modification
 * - Visibility of the entire Metrics tab still respects metricsVisibility setting
 * 
 * DATA STRUCTURE:
 * team.settings.enabledMetrics = ['customers', 'revenue', 'leads', ...]
 * Each string references a metric ID from CUSTOM_METRICS_CATALOG
 * 
 * SECURITY NOTES:
 * 1. Edit button only shown to users where canEditMetrics() returns true (owner)
 * 2. All modification functions (add, remove, reorder) check canEditMetrics() first
 * 3. Firestore rules allow owners to update any settings field
 * 4. Custom metrics use placeholder data - no actual user data is exposed
 * 5. Custom metrics section respects same visibility as rest of Metrics tab
 * 6. No member names or private data are included in custom metric displays
 */

/**
 * Catalog of available custom metrics that can be added to the dashboard
 * Each metric has:
 * - id: unique identifier (stored in enabledMetrics array)
 * - name: display name
 * - description: shown in the add modal
 * - icon: FontAwesome icon class
 * - color: CSS color class (success, warning, danger, or empty for default)
 * - getValue: function that returns { value, subtitle, tooltip } with real data
 * - hasChart: whether to show a mini trend chart
 */
const CUSTOM_METRICS_CATALOG = {
    totalRevenue: {
        id: 'totalRevenue',
        name: 'Total Revenue',
        description: 'Track all-time income from transactions',
        icon: 'fa-dollar-sign',
        color: 'success',
        getValue: () => {
            const financeData = getFinanceMetricsData();
            return {
                value: formatCurrency(financeData.totalIncome),
                subtitle: `YTD: ${formatCurrency(financeData.ytdIncome)}`,
                tooltip: 'Total revenue from all recorded transactions'
            };
        },
        hasChart: true,
        chartData: () => generateFinanceTrendData('income')
    },
    totalExpenses: {
        id: 'totalExpenses',
        name: 'Total Expenses',
        description: 'Track all-time expenses',
        icon: 'fa-receipt',
        color: 'danger',
        getValue: () => {
            const financeData = getFinanceMetricsData();
            return {
                value: formatCurrency(financeData.totalExpenses),
                subtitle: `YTD: ${formatCurrency(financeData.ytdExpenses)}`,
                tooltip: 'Total expenses from all recorded transactions'
            };
        },
        hasChart: true,
        chartData: () => generateFinanceTrendData('expense')
    },
    netProfit: {
        id: 'netProfit',
        name: 'Net Profit',
        description: 'Revenue minus expenses',
        icon: 'fa-chart-line',
        color: '',
        getValue: () => {
            const financeData = getFinanceMetricsData();
            const isPositive = financeData.netBalance >= 0;
            return {
                value: formatCurrency(financeData.netBalance),
                subtitle: isPositive ? 'Profitable' : 'In deficit',
                tooltip: 'Net balance: Total income minus total expenses'
            };
        },
        hasChart: false
    },
    mrr: {
        id: 'mrr',
        name: 'Monthly Recurring Revenue',
        description: 'Track recurring monthly income',
        icon: 'fa-sync-alt',
        color: 'success',
        getValue: () => {
            const financeData = getFinanceMetricsData();
            return {
                value: formatCurrency(financeData.mrr),
                subtitle: `ARR: ${formatCurrency(financeData.mrr * 12)}`,
                tooltip: 'Monthly recurring revenue from subscriptions'
            };
        },
        hasChart: true,
        chartData: () => generateMRRTrendData()
    },
    topCustomer: {
        id: 'topCustomer',
        name: 'Top Customer',
        description: 'Your highest-revenue customer',
        icon: 'fa-crown',
        color: 'warning',
        getValue: () => {
            const financeData = getFinanceMetricsData();
            return {
                value: financeData.mainCustomer || 'N/A',
                subtitle: financeData.mainCustomer ? formatCurrency(financeData.mainCustomerTotal) : 'No customers yet',
                tooltip: 'Customer with highest total revenue'
            };
        },
        hasChart: false
    },
    customers: {
        id: 'customers',
        name: 'Number of Customers',
        description: 'Track unique customer count from transactions',
        icon: 'fa-users',
        color: '',
        getValue: () => {
            const uniqueCustomers = getUniqueCustomerCount();
            return {
                value: uniqueCustomers.toLocaleString(),
                subtitle: uniqueCustomers === 1 ? '1 customer' : `${uniqueCustomers} customers`,
                tooltip: 'Unique customers from revenue transactions'
            };
        },
        hasChart: true,
        chartData: () => generateCustomerGrowthData()
    },
    leads: {
        id: 'leads',
        name: 'Leads Generated',
        description: 'Track new leads and prospects',
        icon: 'fa-user-plus',
        color: '',
        getValue: () => {
            const allLeads = getAllLeadsFromTables();
            const leadCount = allLeads.length;
            return {
                value: leadCount.toLocaleString(),
                subtitle: leadCount === 0 ? 'No leads yet' : `${leadCount} in pipeline`,
                tooltip: 'Total leads from Leads sheets'
            };
        },
        hasChart: false
    },
    conversion: {
        id: 'conversion',
        name: 'Conversion Rate',
        description: 'Track lead to customer conversion',
        icon: 'fa-percentage',
        color: 'success',
        getValue: () => {
            const allLeads = getAllLeadsFromTables();
            const leadCount = allLeads.length;
            const customerCount = getUniqueCustomerCount();
            
            if (leadCount === 0 && customerCount === 0) {
                return {
                    value: 'â€”',
                    subtitle: 'No leads or customers yet',
                    tooltip: 'Add leads to track conversion'
                };
            }
            
            if (leadCount === 0 && customerCount > 0) {
                return {
                    value: 'â€”',
                    subtitle: `${customerCount} customers (no leads tracked)`,
                    tooltip: 'Add leads to calculate conversion rate'
                };
            }
            
            const rate = ((customerCount / leadCount) * 100).toFixed(1);
            return {
                value: rate + '%',
                subtitle: `${customerCount} customers from ${leadCount} leads`,
                tooltip: 'Percentage of leads converted to customers'
            };
        },
        hasChart: false
    },
    monthlyExpenses: {
        id: 'monthlyExpenses',
        name: 'Monthly Expenses',
        description: 'Track monthly expenses from transactions',
        icon: 'fa-calendar-minus',
        color: 'danger',
        getValue: () => {
            const now = new Date();
            const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
            const expenses = (appState.transactions || []).filter(t => t.type === 'expense');
            const monthlyExpenses = expenses.filter(t => {
                const transDate = t.date?.toDate?.() || new Date(t.date);
                return transDate >= startOfMonth && transDate <= now;
            });
            const monthlyTotal = monthlyExpenses.reduce((sum, t) => sum + (t.amount || 0), 0);
            return {
                value: formatCurrency(monthlyTotal),
                subtitle: `${monthlyExpenses.length} expense${monthlyExpenses.length === 1 ? '' : 's'} this month`,
                tooltip: 'Total expenses recorded this month'
            };
        },
        hasChart: true,
        chartData: () => generateExpensesByCategoryData()
    },
    upcomingEvents: {
        id: 'upcomingEvents',
        name: 'Upcoming Events',
        description: 'Events scheduled in the next 7 days',
        icon: 'fa-calendar-day',
        color: '',
        getValue: () => {
            const now = new Date();
            const weekFromNow = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);
            const upcoming = (appState.events || []).filter(e => {
                const eventDate = e.date?.toDate?.() || new Date(e.date);
                return eventDate >= now && eventDate <= weekFromNow;
            });
            return {
                value: upcoming.length.toString(),
                subtitle: upcoming.length === 0 ? 'No events this week' : `${upcoming.length} this week`,
                tooltip: 'Number of events in the next 7 days'
            };
        },
        hasChart: false
    },
    totalTasks: {
        id: 'totalTasks',
        name: 'Active Tasks',
        description: 'Total open tasks across all projects',
        icon: 'fa-tasks',
        color: 'warning',
        getValue: () => {
            const openTasks = (appState.tasks || []).filter(t => t.status !== 'done');
            const dueSoon = openTasks.filter(t => {
                if (!t.dueDate) return false;
                const due = t.dueDate?.toDate?.() || new Date(t.dueDate);
                const threeDays = new Date(Date.now() + 3 * 24 * 60 * 60 * 1000);
                return due <= threeDays;
            });
            return {
                value: openTasks.length.toString(),
                subtitle: dueSoon.length > 0 ? `${dueSoon.length} due soon` : 'No urgent tasks',
                tooltip: 'Number of incomplete tasks across the team'
            };
        },
        hasChart: false
    }
};

/**
 * Get unique customer count from transactions
 */
function getUniqueCustomerCount() {
    if (!appState.transactions) return 0;
    const customers = new Set();
    appState.transactions.forEach(t => {
        if (t.type === 'income' && t.party) {
            customers.add(t.party.toLowerCase().trim());
        }
    });
    return customers.size;
}

/**
 * Generate trend data from actual finance transactions
 */
function generateFinanceTrendData(type = 'income') {
    if (!appState.transactions || appState.transactions.length === 0) {
        return generatePlaceholderTrendData(30, 0, 0);
    }
    
    const now = new Date();
    const data = [];
    
    // Use last 30 days to ensure recent transactions appear in charts
    for (let i = 29; i >= 0; i--) {
        const date = new Date(now);
        date.setDate(date.getDate() - i);
        const dayStart = new Date(date.setHours(0, 0, 0, 0));
        const dayEnd = new Date(date.setHours(23, 59, 59, 999));
        
        let dayTotal = 0;
        appState.transactions.forEach(t => {
            if (t.type === type) {
                const transDate = t.date?.toDate?.() || new Date(t.date);
                if (transDate >= dayStart && transDate <= dayEnd) {
                    dayTotal += t.amount || 0;
                }
            }
        });
        
        data.push({
            label: date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
            count: dayTotal
        });
    }
    
    return data;
}

/**
 * Generate placeholder trend data for charts
 * @param {number} days - Number of days
 * @param {number} min - Minimum value
 * @param {number} max - Maximum value
 */
function generatePlaceholderTrendData(days, min, max) {
    const data = [];
    const now = new Date();
    for (let i = days - 1; i >= 0; i--) {
        const date = new Date(now);
        date.setDate(date.getDate() - i);
        data.push({
            date: date,
            label: date.toLocaleDateString('en-US', { weekday: 'short' }),
            count: Math.floor(Math.random() * (max - min)) + min
        });
    }
    return data;
}

/**
 * Generate MRR trend data (monthly view)
 * Uses both subscriptions and recurring transactions for comprehensive MRR data
 */
function generateMRRTrendData() {
    const now = new Date();
    const data = [];
    
    // Get last 6 months of MRR data
    for (let i = 5; i >= 0; i--) {
        const monthDate = new Date(now.getFullYear(), now.getMonth() - i, 1);
        const monthEnd = new Date(now.getFullYear(), now.getMonth() - i + 1, 0);
        const monthLabel = monthDate.toLocaleDateString('en-US', { month: 'short' });
        
        let monthlyMrr = 0;
        
        // Calculate MRR from subscriptions
        const subs = appState.subscriptions || [];
        subs.forEach(sub => {
            const startDate = sub.startDate?.toDate?.() || new Date(sub.startDate || 0);
            if (startDate <= monthEnd) {
                const amount = sub.amount || 0;
                switch (sub.frequency) {
                    case 'monthly': monthlyMrr += amount; break;
                    case 'quarterly': monthlyMrr += amount / 3; break;
                    case 'yearly': monthlyMrr += amount / 12; break;
                    default: monthlyMrr += amount;
                }
            }
        });
        
        // Also include recurring transactions if no subscriptions
        if (subs.length === 0) {
            const transactions = appState.transactions || [];
            transactions.forEach(t => {
                if (t.type === 'income' && t.isRecurring) {
                    const transDate = t.date?.toDate?.() || new Date(t.date || 0);
                    if (transDate <= monthEnd) {
                        const amount = t.amount || 0;
                        switch (t.frequency) {
                            case 'monthly': monthlyMrr += amount; break;
                            case 'quarterly': monthlyMrr += amount / 3; break;
                            case 'yearly': monthlyMrr += amount / 12; break;
                            default: monthlyMrr += amount;
                        }
                    }
                }
            });
        }
        
        data.push({
            label: monthLabel,
            value: monthlyMrr
        });
    }
    
    return data;
}

/**
 * Generate customer growth data (monthly cumulative)
 */
function generateCustomerGrowthData() {
    const now = new Date();
    const data = [];
    
    // Get last 6 months of customer data
    for (let i = 5; i >= 0; i--) {
        const monthDate = new Date(now.getFullYear(), now.getMonth() - i, 1);
        const monthEnd = new Date(now.getFullYear(), now.getMonth() - i + 1, 0);
        const monthLabel = monthDate.toLocaleDateString('en-US', { month: 'short' });
        
        // Count unique customers up to that month
        const customers = new Set();
        (appState.transactions || []).forEach(t => {
            if (t.type === 'income' && t.party) {
                const transDate = t.date?.toDate?.() || new Date(t.date);
                if (transDate <= monthEnd) {
                    customers.add(t.party.toLowerCase().trim());
                }
            }
        });
        
        data.push({
            label: monthLabel,
            value: customers.size
        });
    }
    
    return data;
}

/**
 * Generate expenses by category data
 */
function generateExpensesByCategoryData() {
    const expenses = (appState.transactions || []).filter(t => t.type === 'expense');
    const byCategory = {};
    
    expenses.forEach(exp => {
        const category = exp.category || 'Other';
        const amount = exp.amount || 0;
        byCategory[category] = (byCategory[category] || 0) + amount;
    });
    
    // Convert to chart data format
    const data = Object.entries(byCategory)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 6)
        .map(([label, value]) => ({
            label: label,
            value: value
        }));
    
    return data.length > 0 ? data : [{ label: 'No data', value: 0 }];
}

/**
 * State for metrics edit mode
 */
let metricsEditMode = false;

/**
 * Get the enabled custom metrics for the current team
 * @returns {string[]} Array of metric IDs
 */
function getEnabledCustomMetrics() {
    return appState.currentTeamData?.settings?.enabledMetrics || [];
}

/**
 * Get the display mode for a metric (card or graph)
 * @param {string} metricId - The metric ID
 * @returns {string} 'card' or 'graph'
 */
function getMetricDisplayMode(metricId) {
    const modes = appState.currentTeamData?.settings?.metricsDisplayModes || {};
    return modes[metricId] || 'card'; // Default to card view
}

/**
 * Toggle the display mode for a metric
 * @param {string} metricId - The metric ID
 */
async function toggleMetricDisplayMode(metricId) {
    if (!canEditMetrics()) return;
    
    const currentMode = getMetricDisplayMode(metricId);
    const newMode = currentMode === 'card' ? 'graph' : 'card';
    
    try {
        const { doc, updateDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        const teamRef = doc(db, 'teams', appState.currentTeamId);
        
        const currentModes = appState.currentTeamData?.settings?.metricsDisplayModes || {};
        currentModes[metricId] = newMode;
        
        await updateDoc(teamRef, {
            'settings.metricsDisplayModes': currentModes
        });
        
        // Update local state
        if (!appState.currentTeamData.settings) appState.currentTeamData.settings = {};
        appState.currentTeamData.settings.metricsDisplayModes = currentModes;
        
        renderMetrics();
    } catch (error) {
        console.error('Error toggling metric display mode:', error);
    }
}

window.toggleMetricDisplayMode = toggleMetricDisplayMode;

/**
 * Check if user can edit metrics (owner only)
 * @returns {boolean}
 */
function canEditMetrics() {
    const userRole = appState.teammates?.find(t => t.id === currentAuthUser?.uid)?.role;
    return userRole === 'owner';
}

/**
 * Toggle metrics edit mode
 */
function toggleMetricsEditMode() {
    if (!canEditMetrics()) {
        showToast('Only the team owner can edit metrics', 'error');
        return;
    }
    metricsEditMode = !metricsEditMode;
    renderMetrics();
}

// Expose to global scope
window.toggleMetricsEditMode = toggleMetricsEditMode;

// ===================================
// METRICS CHART CONFIG SYSTEM
// Per-graph customization (Y-axis, colors, data source, etc.)
// ===================================

/**
 * Available colors for chart customization
 * Instagram-inspired palette
 */
const CHART_COLOR_OPTIONS = [
    { id: 'purple', label: 'Purple', value: '#833AB4', preview: '#833AB4' },
    { id: 'pink', label: 'Pink', value: '#E1306C', preview: '#E1306C' },
    { id: 'accent', label: 'Blue', value: 'var(--accent)', preview: '#007AFF' },
    { id: 'green', label: 'Green', value: '#34C759', preview: '#34C759' },
    { id: 'orange', label: 'Orange', value: '#FF9F0A', preview: '#FF9F0A' },
    { id: 'red', label: 'Red', value: '#FF3B30', preview: '#FF3B30' },
    { id: 'teal', label: 'Teal', value: '#5AC8FA', preview: '#5AC8FA' },
    { id: 'indigo', label: 'Indigo', value: '#5856D6', preview: '#5856D6' }
];

/**
 * Pie chart palette themes
 * Each theme provides an ordered list of colors for pie segments
 */
const PIE_PALETTE_OPTIONS = [
    { 
        id: 'default', 
        label: 'Default', 
        colors: ['#E040FB', '#7C4DFF', '#536DFE', '#40C4FF', '#69F0AE', '#FFD740', '#FF6E40', '#FF4081']
    },
    { 
        id: 'instagram', 
        label: 'Instagram', 
        colors: ['#E1306C', '#833AB4', '#5851DB', '#405DE6', '#C13584', '#F77737', '#FCAF45', '#FFDC80']
    },
    { 
        id: 'ocean', 
        label: 'Ocean', 
        colors: ['#007AFF', '#5AC8FA', '#64D2FF', '#00C7BE', '#30D158', '#34C759', '#A2845E', '#8E8E93']
    },
    { 
        id: 'sunset', 
        label: 'Sunset', 
        colors: ['#FF9F0A', '#FF3B30', '#FF2D55', '#AF52DE', '#BF5AF2', '#FF6482', '#FFD60A', '#FF9500']
    },
    { 
        id: 'forest', 
        label: 'Forest', 
        colors: ['#34C759', '#30D158', '#00C7BE', '#32ADE6', '#007AFF', '#5856D6', '#AF52DE', '#A2845E']
    },
    {
        id: 'monochrome',
        label: 'Monochrome',
        colors: ['var(--accent)', 'var(--accent-hover)', '#5AC8FA', '#64D2FF', '#8E8E93', '#AEAEB2', '#C7C7CC', '#D1D1D6']
    }
];

/**
 * Tick density presets
 * Maps to number of Y-axis ticks
 */
const TICK_DENSITY_OPTIONS = [
    { id: 'compact', label: 'Compact', ticks: 3 },
    { id: 'normal', label: 'Normal', ticks: 4 },
    { id: 'detailed', label: 'Detailed', ticks: 6 }
];

/**
 * Available data sources for metrics
 * These define what data a chart can display
 */
const DATA_SOURCE_OPTIONS = [
    { id: 'personal-tasks', label: 'My Task Completions', sourceType: 'tasks', metricKey: 'personal' },
    { id: 'team-tasks', label: 'Team Task Completions', sourceType: 'tasks', metricKey: 'team' },
    { id: 'task-status', label: 'Task Status Distribution', sourceType: 'tasks', metricKey: 'status' },
    { id: 'events-week', label: 'Events This Week', sourceType: 'events', metricKey: 'weekly' },
    { id: 'messages-week', label: 'Messages This Week', sourceType: 'messages', metricKey: 'weekly' },
    { id: 'custom', label: 'Custom Data', sourceType: 'custom', metricKey: null }
];

/**
 * Default chart configuration
 */
const DEFAULT_CHART_CONFIG = {
    type: 'bar',
    visible: true, // Whether the chart/section is visible
    yAxis: {
        mode: 'auto', // 'auto' | 'custom'
        min: 0,
        max: null, // null = auto
        step: null, // null = auto
        tickDensity: 'normal' // 'compact' | 'normal' | 'detailed'
    },
    colors: {
        primary: 'var(--accent)',
        secondary: '#34C759',
        palette: 'default' // For pie charts
    },
    source: {
        type: 'tasks',
        id: null,
        metricKey: null
    }
};

/**
 * Metrics section visibility state
 * Tracks which sections are hidden
 */
let metricsHiddenSections = {
    personalStats: false,
    teamStats: false,
    personalTrend: false,
    teamCharts: false,
    businessMetrics: false
};

/**
 * Hidden individual metrics (not removed, just hidden)
 * Contains array of metric IDs that are hidden
 */
let hiddenMetricIds = [];

/**
 * Load metrics section visibility from team settings
 */
function loadMetricsSectionVisibility() {
    const visibility = appState.currentTeamData?.settings?.metricsVisibility || {};
    metricsHiddenSections = {
        personalStats: visibility.personalStats === false,
        teamStats: visibility.teamStats === false,
        personalTrend: visibility.personalTrend === false,
        teamCharts: visibility.teamCharts === false,
        businessMetrics: visibility.businessMetrics === false
    };
    
    // Load hidden metrics
    hiddenMetricIds = appState.currentTeamData?.settings?.hiddenMetrics || [];
}

/**
 * Check if a metric is hidden
 */
function isMetricHidden(metricId) {
    return hiddenMetricIds.includes(metricId);
}

/**
 * Toggle individual metric visibility
 */
async function toggleMetricVisibility(metricId) {
    if (!canEditMetrics()) return;
    
    const isHidden = hiddenMetricIds.includes(metricId);
    
    if (isHidden) {
        hiddenMetricIds = hiddenMetricIds.filter(id => id !== metricId);
    } else {
        hiddenMetricIds.push(metricId);
    }
    
    // Save to Firestore
    try {
        const { doc, updateDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        const teamRef = doc(db, 'teams', appState.currentTeamId);
        
        await updateDoc(teamRef, {
            'settings.hiddenMetrics': hiddenMetricIds
        });
        
        // Update local state
        if (!appState.currentTeamData.settings) {
            appState.currentTeamData.settings = {};
        }
        appState.currentTeamData.settings.hiddenMetrics = hiddenMetricIds;
        
        const metric = CUSTOM_METRICS_CATALOG[metricId];
        const metricName = metric?.name || metricId;
        showToast(isHidden ? `Showing "${metricName}"` : `Hiding "${metricName}"`, 'info');
        
        renderMetrics();
    } catch (error) {
        console.error('Error toggling metric visibility:', error);
        showToast('Failed to update visibility', 'error');
    }
}

window.toggleMetricVisibility = toggleMetricVisibility;

/**
 * Toggle section visibility
 */
async function toggleMetricsSectionVisibility(sectionId) {
    if (!canEditMetrics()) return;
    
    metricsHiddenSections[sectionId] = !metricsHiddenSections[sectionId];
    
    // Save to Firestore
    try {
        const { doc, updateDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        const teamRef = doc(db, 'teams', appState.currentTeamId);
        
        const visibilitySettings = {
            personalStats: !metricsHiddenSections.personalStats,
            teamStats: !metricsHiddenSections.teamStats,
            personalTrend: !metricsHiddenSections.personalTrend,
            teamCharts: !metricsHiddenSections.teamCharts,
            businessMetrics: !metricsHiddenSections.businessMetrics
        };
        
        await updateDoc(teamRef, {
            'settings.metricsSectionVisibility': visibilitySettings
        });
        
        renderMetrics();
    } catch (error) {
        console.error('Error saving section visibility:', error);
        showToast('Failed to save visibility settings', 'error');
    }
}

window.toggleMetricsSectionVisibility = toggleMetricsSectionVisibility;

/**
 * Debounce timer for saving chart config
 */
let chartConfigSaveTimer = null;

/**
 * Load metrics chart configuration from team settings
 * @param {string} teamId - Team ID
 */
function loadMetricsChartConfig(teamId) {
    const config = appState.currentTeamData?.settings?.metricsChartConfig || {};
    appState.metricsChartConfig = config;
    
    // Also load saved graph types from config
    Object.keys(config).forEach(chartId => {
        if (config[chartId].type) {
            appState.graphTypes[chartId] = config[chartId].type;
        }
    });
}

/**
 * Get chart configuration for a specific chart
 * Falls back to defaults if not configured
 * Handles backward compatibility with old flat config structure
 * @param {string} chartId - Unique chart identifier
 * @returns {Object} Chart configuration (flat for rendering, nested for storage)
 */
function getChartConfig(chartId) {
    const savedConfig = appState.metricsChartConfig[chartId] || {};
    const chartType = appState.graphTypes[chartId] || savedConfig.type || 'bar';
    
    // Handle backward compatibility: convert old flat structure to new nested
    // Old format: { yAxisMin, yAxisMax, yAxisStep, primaryColor, secondaryColor }
    // New format: { type, yAxis: {...}, colors: {...}, source: {...} }
    
    let yAxis, colors, source;
    
    // Check if it's new format (has yAxis object) or old format
    if (savedConfig.yAxis) {
        yAxis = { ...DEFAULT_CHART_CONFIG.yAxis, ...savedConfig.yAxis };
    } else {
        // Old format - convert
        yAxis = {
            mode: (savedConfig.yAxisMax !== null && savedConfig.yAxisMax !== undefined) ? 'custom' : 'auto',
            min: savedConfig.yAxisMin ?? DEFAULT_CHART_CONFIG.yAxis.min,
            max: savedConfig.yAxisMax ?? DEFAULT_CHART_CONFIG.yAxis.max,
            step: savedConfig.yAxisStep ?? DEFAULT_CHART_CONFIG.yAxis.step,
            tickDensity: savedConfig.tickDensity || DEFAULT_CHART_CONFIG.yAxis.tickDensity
        };
    }
    
    if (savedConfig.colors) {
        colors = { ...DEFAULT_CHART_CONFIG.colors, ...savedConfig.colors };
    } else {
        // Old format - convert
        colors = {
            primary: savedConfig.primaryColor || DEFAULT_CHART_CONFIG.colors.primary,
            secondary: savedConfig.secondaryColor || DEFAULT_CHART_CONFIG.colors.secondary,
            palette: savedConfig.palette || DEFAULT_CHART_CONFIG.colors.palette
        };
    }
    
    source = savedConfig.source ? { ...DEFAULT_CHART_CONFIG.source, ...savedConfig.source } : { ...DEFAULT_CHART_CONFIG.source };
    
    // Return flat format for easy use in rendering functions
    return {
        type: chartType,
        // Flat Y-axis props for backward compat with rendering
        yAxisMin: yAxis.min,
        yAxisMax: yAxis.mode === 'auto' ? null : yAxis.max,
        yAxisStep: yAxis.step,
        yAxisMode: yAxis.mode,
        tickDensity: yAxis.tickDensity,
        // Flat color props for backward compat
        primaryColor: colors.primary,
        secondaryColor: colors.secondary,
        palette: colors.palette,
        // Source info
        sourceType: source.type,
        sourceId: source.id,
        metricKey: source.metricKey,
        // Also include nested structure for settings panel
        _nested: {
            type: chartType,
            yAxis,
            colors,
            source
        }
    };
}

/**
 * Update chart configuration (local state + debounced save)
 * @param {string} chartId - Unique chart identifier
 * @param {Object} updates - Config properties to update (can be flat or nested)
 */
function updateChartConfig(chartId, updates) {
    if (!canEditMetrics()) return;
    
    // Initialize config for this chart if needed
    if (!appState.metricsChartConfig[chartId]) {
        appState.metricsChartConfig[chartId] = {
            type: 'bar',
            yAxis: { ...DEFAULT_CHART_CONFIG.yAxis },
            colors: { ...DEFAULT_CHART_CONFIG.colors },
            source: { ...DEFAULT_CHART_CONFIG.source }
        };
    }
    
    const config = appState.metricsChartConfig[chartId];
    
    // Handle flat updates by mapping to nested structure
    if ('type' in updates) {
        config.type = updates.type;
        appState.graphTypes[chartId] = updates.type;
    }
    
    // Y-axis updates
    if ('yAxisMin' in updates) {
        if (!config.yAxis) config.yAxis = { ...DEFAULT_CHART_CONFIG.yAxis };
        config.yAxis.min = updates.yAxisMin;
    }
    if ('yAxisMax' in updates) {
        if (!config.yAxis) config.yAxis = { ...DEFAULT_CHART_CONFIG.yAxis };
        config.yAxis.max = updates.yAxisMax;
        config.yAxis.mode = updates.yAxisMax !== null ? 'custom' : 'auto';
    }
    if ('yAxisStep' in updates) {
        if (!config.yAxis) config.yAxis = { ...DEFAULT_CHART_CONFIG.yAxis };
        config.yAxis.step = updates.yAxisStep;
    }
    if ('yAxisMode' in updates) {
        if (!config.yAxis) config.yAxis = { ...DEFAULT_CHART_CONFIG.yAxis };
        config.yAxis.mode = updates.yAxisMode;
        if (updates.yAxisMode === 'auto') {
            config.yAxis.max = null;
        }
    }
    if ('tickDensity' in updates) {
        if (!config.yAxis) config.yAxis = { ...DEFAULT_CHART_CONFIG.yAxis };
        config.yAxis.tickDensity = updates.tickDensity;
    }
    
    // Color updates
    if ('primaryColor' in updates) {
        if (!config.colors) config.colors = { ...DEFAULT_CHART_CONFIG.colors };
        config.colors.primary = updates.primaryColor;
    }
    if ('secondaryColor' in updates) {
        if (!config.colors) config.colors = { ...DEFAULT_CHART_CONFIG.colors };
        config.colors.secondary = updates.secondaryColor;
    }
    if ('palette' in updates) {
        if (!config.colors) config.colors = { ...DEFAULT_CHART_CONFIG.colors };
        config.colors.palette = updates.palette;
    }
    
    // Source updates
    if ('sourceType' in updates) {
        if (!config.source) config.source = { ...DEFAULT_CHART_CONFIG.source };
        config.source.type = updates.sourceType;
    }
    if ('sourceId' in updates) {
        if (!config.source) config.source = { ...DEFAULT_CHART_CONFIG.source };
        config.source.id = updates.sourceId;
    }
    if ('metricKey' in updates) {
        if (!config.source) config.source = { ...DEFAULT_CHART_CONFIG.source };
        config.source.metricKey = updates.metricKey;
    }
    
    // Re-render the specific chart
    rerenderSingleChart(chartId);
    
    // Debounced save to Firestore
    if (chartConfigSaveTimer) {
        clearTimeout(chartConfigSaveTimer);
    }
    chartConfigSaveTimer = setTimeout(() => {
        saveMetricsChartConfigToFirestore();
    }, 600);
}

/**
 * Save all chart config to Firestore
 */
async function saveMetricsChartConfigToFirestore() {
    if (!canEditMetrics() || !appState.currentTeamId) return;
    
    try {
        const { doc, updateDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        const teamRef = doc(db, 'teams', appState.currentTeamId);
        await updateDoc(teamRef, {
            'settings.metricsChartConfig': appState.metricsChartConfig
        });
        
        // Update local team data
        if (!appState.currentTeamData.settings) {
            appState.currentTeamData.settings = {};
        }
        appState.currentTeamData.settings.metricsChartConfig = appState.metricsChartConfig;
        
        debugLog('âœ… Chart config saved to Firestore');
    } catch (error) {
        console.error('Error saving chart config:', error);
        showToast('Failed to save chart settings', 'error');
    }
}

/**
 * Reset chart configuration to defaults
 * @param {string} chartId - Unique chart identifier
 */
function resetChartConfig(chartId) {
    if (!canEditMetrics()) return;
    
    // Remove the custom config
    delete appState.metricsChartConfig[chartId];
    
    // Reset graph type to default
    delete appState.graphTypes[chartId];
    
    // Re-render the chart
    rerenderSingleChart(chartId);
    
    // Save to Firestore
    if (chartConfigSaveTimer) {
        clearTimeout(chartConfigSaveTimer);
    }
    chartConfigSaveTimer = setTimeout(() => {
        saveMetricsChartConfigToFirestore();
    }, 300);
    
    // Close the settings panel
    closeGraphSettings(chartId);
    
    showToast('Chart reset to defaults', 'success');
}

/**
 * Re-render a single chart without re-rendering the entire metrics page
 * @param {string} chartId - Unique chart identifier
 */
function rerenderSingleChart(chartId) {
    const container = document.querySelector(`[data-graph-id="${chartId}"] .graph-content`);
    if (!container) return;
    
    const card = container.closest('.metrics-card');
    const dataAttr = card?.dataset.graphData;
    const dataType = card?.dataset.graphDataType || 'trend';
    
    if (!dataAttr) return;
    
    try {
        const data = JSON.parse(dataAttr);
        const config = getChartConfig(chartId);
        const type = config.type || getGraphType(chartId);
        
        // Animate transition
        container.style.opacity = '0';
        container.style.transform = 'scale(0.98)';
        
        setTimeout(() => {
            container.innerHTML = renderGraphByTypeWithConfig(data, type, dataType, config);
            container.style.opacity = '1';
            container.style.transform = 'scale(1)';
        }, 150);
    } catch (e) {
        console.error('Error re-rendering chart:', e);
    }
}

/**
 * Toggle graph settings panel visibility
 * @param {string} chartId - Unique chart identifier
 */
function toggleGraphSettings(chartId) {
    const panel = document.querySelector(`[data-settings-chart="${chartId}"]`);
    if (!panel) return;
    
    const isOpen = panel.classList.contains('open');
    
    // Close all other panels first
    document.querySelectorAll('.graph-settings-panel.open').forEach(p => {
        if (p.dataset.settingsChart !== chartId) {
            p.classList.remove('open');
        }
    });
    
    // Toggle this panel
    panel.classList.toggle('open', !isOpen);
}

/**
 * Close graph settings panel
 * @param {string} chartId - Unique chart identifier
 */
function closeGraphSettings(chartId) {
    const panel = document.querySelector(`[data-settings-chart="${chartId}"]`);
    if (panel) {
        panel.classList.remove('open');
    }
}

/**
 * Handle chart config input change
 * @param {string} chartId - Chart identifier
 * @param {string} field - Config field name
 * @param {any} value - New value
 */
function handleChartConfigChange(chartId, field, value) {
    // Validate and convert value based on field
    let processedValue = value;
    
    if (field === 'yAxisMin' || field === 'yAxisMax' || field === 'yAxisStep') {
        // Convert to number or null
        if (value === '' || value === null) {
            processedValue = null;
        } else {
            processedValue = parseFloat(value);
            if (isNaN(processedValue)) processedValue = null;
        }
        
        // Validation
        if (field === 'yAxisMin' && processedValue !== null && processedValue < 0) {
            processedValue = 0; // Count metrics should not go below 0
        }
        if (field === 'yAxisStep' && processedValue !== null && processedValue <= 0) {
            processedValue = null; // Step must be positive
        }
    }
    
    updateChartConfig(chartId, { [field]: processedValue });
}

// Expose functions to window for onclick handlers
window.toggleGraphSettings = toggleGraphSettings;
window.closeGraphSettings = closeGraphSettings;
window.handleChartConfigChange = handleChartConfigChange;
window.resetChartConfig = resetChartConfig;
window.updateChartConfig = updateChartConfig;

/**
 * Open the Add Metric modal
 */
function openAddMetricModal() {
    if (!canEditMetrics()) return;
    
    const enabledMetrics = getEnabledCustomMetrics();
    const availableMetrics = Object.values(CUSTOM_METRICS_CATALOG)
        .filter(m => !enabledMetrics.includes(m.id));
    
    if (availableMetrics.length === 0) {
        showToast('All available metrics have been added', 'info');
        return;
    }
    
    // Build modal HTML
    let metricsListHTML = availableMetrics.map(m => `
        <div class="add-metric-option" data-metric-id="${m.id}" onclick="addCustomMetric('${m.id}')">
            <div class="add-metric-option-icon">
                <i class="fas ${m.icon}"></i>
            </div>
            <div class="add-metric-option-content">
                <div class="add-metric-option-name">${m.name}</div>
                <div class="add-metric-option-desc">${m.description}</div>
            </div>
            <div class="add-metric-option-action">
                <i class="fas fa-plus"></i>
            </div>
        </div>
    `).join('');
    
    const modalHTML = `
        <div class="modal active" id="addMetricModal">
            <div class="modal-content" style="max-width: 500px;">
                <div class="modal-header">
                    <h2>Add Metric</h2>
                    <button class="modal-close" onclick="closeModal('addMetricModal')">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body" style="padding: 16px 24px; max-height: 400px; overflow-y: auto;">
                    <p style="color: var(--text-muted); margin-bottom: 16px;">
                        Select a metric to add to your dashboard. These are placeholder metrics that will connect to real data in the future.
                    </p>
                    <div class="add-metric-list">
                        ${metricsListHTML}
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // Remove existing modal if any
    const existing = document.getElementById('addMetricModal');
    if (existing) existing.remove();
    
    // Add modal to DOM
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

window.openAddMetricModal = openAddMetricModal;

/**
 * Add a custom metric to the enabled list
 * @param {string} metricId - The metric ID to add
 */
async function addCustomMetric(metricId) {
    if (!canEditMetrics()) return;
    if (!CUSTOM_METRICS_CATALOG[metricId]) return;
    
    const enabledMetrics = [...getEnabledCustomMetrics()];
    if (enabledMetrics.includes(metricId)) {
        showToast('This metric is already added', 'info');
        return;
    }
    
    enabledMetrics.push(metricId);
    
    try {
        await saveEnabledMetrics(enabledMetrics);
        closeModal('addMetricModal');
        showToast(`Added "${CUSTOM_METRICS_CATALOG[metricId].name}"`, 'success');
        renderMetrics();
    } catch (error) {
        console.error('Error adding metric:', error);
        showToast('Failed to add metric. Please try again.', 'error');
    }
}

window.addCustomMetric = addCustomMetric;

/**
 * Remove a custom metric from the enabled list
 * @param {string} metricId - The metric ID to remove
 */
async function removeCustomMetric(metricId) {
    if (!canEditMetrics()) return;
    
    const enabledMetrics = getEnabledCustomMetrics().filter(id => id !== metricId);
    
    try {
        await saveEnabledMetrics(enabledMetrics);
        showToast(`Removed metric`, 'success');
        renderMetrics();
    } catch (error) {
        console.error('Error removing metric:', error);
        showToast('Failed to remove metric. Please try again.', 'error');
    }
}

window.removeCustomMetric = removeCustomMetric;

/**
 * Move a metric up or down in the order
 * @param {string} metricId - The metric ID to move
 * @param {string} direction - 'up' or 'down'
 */
async function reorderCustomMetric(metricId, direction) {
    if (!canEditMetrics()) return;
    
    const enabledMetrics = [...getEnabledCustomMetrics()];
    const currentIndex = enabledMetrics.indexOf(metricId);
    
    if (currentIndex === -1) return;
    
    const newIndex = direction === 'up' ? currentIndex - 1 : currentIndex + 1;
    
    if (newIndex < 0 || newIndex >= enabledMetrics.length) return;
    
    // Swap positions
    [enabledMetrics[currentIndex], enabledMetrics[newIndex]] = 
        [enabledMetrics[newIndex], enabledMetrics[currentIndex]];
    
    try {
        await saveEnabledMetrics(enabledMetrics);
        renderMetrics();
    } catch (error) {
        console.error('Error reordering metrics:', error);
        showToast('Failed to reorder metrics. Please try again.', 'error');
    }
}

window.reorderCustomMetric = reorderCustomMetric;

/**
 * Save enabled metrics to Firestore
 * @param {string[]} enabledMetrics - Array of metric IDs
 */
async function saveEnabledMetrics(enabledMetrics) {
    if (!db || !appState.currentTeamId) {
        throw new Error('Database not available');
    }
    
    const { doc, updateDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
    const teamRef = doc(db, 'teams', appState.currentTeamId);
    
    await updateDoc(teamRef, {
        'settings.enabledMetrics': enabledMetrics
    });
    
    // Update local state
    if (!appState.currentTeamData.settings) {
        appState.currentTeamData.settings = {};
    }
    appState.currentTeamData.settings.enabledMetrics = enabledMetrics;
}

/**
 * Render a custom metric card
 * @param {Object} metric - The metric config from CUSTOM_METRICS_CATALOG
 * @param {number} index - The index in the enabled list
 * @param {number} total - Total number of enabled metrics
 * @param {boolean} showHidden - Whether to show hidden metrics (in edit mode)
 * @returns {string} HTML string
 */
function renderCustomMetricCard(metric, index, total, showHidden = false) {
    const metricIsHidden = isMetricHidden(metric.id);
    
    // If hidden and not in edit mode, don't render
    if (metricIsHidden && !metricsEditMode) {
        return '';
    }
    
    const data = metric.getValue();
    const hasChartOption = metric.hasChart;
    const currentMode = getMetricDisplayMode(metric.id);
    
    // Display mode toggle (only in edit mode and for metrics that support charts)
    const displayModeToggle = (metricsEditMode && hasChartOption) ? `
        <button class="metric-display-toggle" onclick="toggleMetricDisplayMode('${metric.id}')" 
                title="Switch to ${currentMode === 'card' ? 'graph' : 'card'} view">
            <i class="fas fa-${currentMode === 'card' ? 'chart-line' : 'th-large'}"></i>
        </button>
    ` : '';
    
    // Hide/show toggle button
    const hideToggle = metricsEditMode ? `
        <button class="metric-edit-btn ${metricIsHidden ? 'hidden-state' : ''}" 
                onclick="toggleMetricVisibility('${metric.id}')" 
                title="${metricIsHidden ? 'Show metric' : 'Hide metric'}">
            <i class="fas fa-${metricIsHidden ? 'eye-slash' : 'eye'}"></i>
        </button>
    ` : '';
    
    const editControls = metricsEditMode ? `
        <div class="metric-edit-overlay">
            <div class="metric-edit-actions">
                ${displayModeToggle}
                ${hideToggle}
                <button class="metric-edit-btn" onclick="reorderCustomMetric('${metric.id}', 'up')" 
                        ${index === 0 ? 'disabled' : ''} title="Move up">
                    <i class="fas fa-chevron-up"></i>
                </button>
                <button class="metric-edit-btn" onclick="reorderCustomMetric('${metric.id}', 'down')" 
                        ${index === total - 1 ? 'disabled' : ''} title="Move down">
                    <i class="fas fa-chevron-down"></i>
                </button>
                <button class="metric-edit-btn danger" onclick="removeCustomMetric('${metric.id}')" title="Remove">
                    <i class="fas fa-trash"></i>
                </button>
            </div>
        </div>
    ` : '';
    
    const tooltipAttr = data.tooltip ? `data-tooltip="${data.tooltip}"` : '';
    const hiddenClass = metricIsHidden ? 'metric-hidden' : '';
    
    return `
        <div class="metrics-stat-card custom-metric-card ${metric.color} ${metricsEditMode ? 'edit-mode' : ''} ${hiddenClass}" ${tooltipAttr}>
            ${editControls}
            <div class="metrics-stat-icon">
                <i class="fas ${metric.icon}"></i>
            </div>
            <div class="metrics-stat-content">
                <div class="metrics-stat-value">${data.value}</div>
                <div class="metrics-stat-label">${metric.name}</div>
                ${data.subtitle ? `<div class="metrics-stat-subtitle">${data.subtitle}</div>` : ''}
            </div>
        </div>
    `;
}

/**
 * METRICS TIME FILTER STATE
 * Tracks the currently selected time range for metrics display.
 * Options: '7days' (Last 7 days), '30days' (Last 30 days), 'all' (All time)
 * This affects the trend charts and some stat card values.
 */
let metricsTimeFilter = '7days';

/**
 * Get time boundaries based on the current filter setting
 * @returns {Object} { start: Date, end: Date, label: string }
 */
function getMetricsTimeBoundaries() {
    const now = new Date();
    const end = now;
    let start;
    let label;
    
    switch (metricsTimeFilter) {
        case '30days':
            start = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
            label = 'Last 30 Days';
            break;
        case 'all':
            start = new Date(0); // Beginning of time
            label = 'All Time';
            break;
        case '7days':
        default:
            start = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
            label = 'Last 7 Days';
            break;
    }
    
    return { start, end, label };
}

/**
 * Handle time filter change from the dropdown
 * @param {Event} event - The change event
 */
function handleMetricsTimeFilterChange(event) {
    metricsTimeFilter = event.target.value;
    renderMetrics();
}

/**
 * Helper to parse Firestore timestamp or date string to Date object
 */
function parseMetricsDate(dateValue) {
    if (!dateValue) return null;
    if (dateValue instanceof Date) return dateValue;
    if (dateValue.toDate && typeof dateValue.toDate === 'function') {
        return dateValue.toDate();
    }
    if (dateValue.seconds) {
        return new Date(dateValue.seconds * 1000);
    }
    return new Date(dateValue);
}

/**
 * Check if a task is assigned to the given user ID
 */
function isTaskAssignedToUser(task, userId) {
    if (!userId) return false;
    
    // Check by assigneeId (UID) - primary method
    if (task.assigneeId && task.assigneeId === userId) return true;
    
    // Also check by createdBy for tasks without explicit assignee
    if (!task.assigneeId && !task.assignee && task.createdBy === userId) return true;
    
    return false;
}

/**
 * Compute personal metrics for the current user
 * @param {Object} state - The appState object
 * @param {string} userId - The current user's UID
 * @returns {Object} Personal metrics
 */
function computePersonalMetrics(state, userId) {
    const now = new Date();
    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
    
    // Task metrics
    const myTasks = state.tasks.filter(t => isTaskAssignedToUser(t, userId) || t.createdBy === userId);
    const myCompletedTasks = myTasks.filter(t => t.status === 'done');
    
    const completedLast7Days = myCompletedTasks.filter(t => {
        const completedAt = parseMetricsDate(t.completedAt || t.updatedAt);
        return completedAt && completedAt >= sevenDaysAgo;
    });
    
    const completedLast30Days = myCompletedTasks.filter(t => {
        const completedAt = parseMetricsDate(t.completedAt || t.updatedAt);
        return completedAt && completedAt >= thirtyDaysAgo;
    });
    
    const myOpenTasks = myTasks.filter(t => t.status !== 'done');
    const completionRate = myTasks.length > 0 
        ? Math.round((myCompletedTasks.length / myTasks.length) * 100) 
        : 0;
    
    // Event metrics
    const myEvents = state.events.filter(e => e.createdBy === userId);
    const upcomingEvents = myEvents.filter(e => {
        const eventDate = parseMetricsDate(e.date);
        return eventDate && eventDate >= now;
    });
    const eventsCreatedLast30Days = myEvents.filter(e => {
        const createdAt = parseMetricsDate(e.createdAt);
        return createdAt && createdAt >= thirtyDaysAgo;
    });
    
    // Chat metrics
    const myMessages = state.messages.filter(m => m.userId === userId);
    const messagesLast7Days = myMessages.filter(m => {
        const createdAt = parseMetricsDate(m.createdAt);
        return createdAt && createdAt >= sevenDaysAgo;
    });
    
    // Activity metrics
    const myActivities = state.activities.filter(a => a.userId === userId);
    const activitiesLast7Days = myActivities.filter(a => {
        const timestamp = a.timestamp instanceof Date ? a.timestamp : parseMetricsDate(a.createdAt);
        return timestamp && timestamp >= sevenDaysAgo;
    });
    
    // Daily breakdown based on time filter (for trend chart)
    const timeBounds = getMetricsTimeBoundaries();
    const daysToShow = metricsTimeFilter === '7days' ? 7 : (metricsTimeFilter === '30days' ? 30 : 90);
    
    const dailyCompletions = [];
    for (let i = daysToShow - 1; i >= 0; i--) {
        const dayStart = new Date(now);
        dayStart.setDate(dayStart.getDate() - i);
        dayStart.setHours(0, 0, 0, 0);
        const dayEnd = new Date(dayStart);
        dayEnd.setHours(23, 59, 59, 999);
        
        const count = myCompletedTasks.filter(t => {
            const completedAt = parseMetricsDate(t.completedAt || t.updatedAt);
            return completedAt && completedAt >= dayStart && completedAt <= dayEnd;
        }).length;
        
        // Use shorter label format for 30 days
        const labelFormat = daysToShow > 7 
            ? { month: 'numeric', day: 'numeric' } 
            : { weekday: 'short' };
        
        dailyCompletions.push({
            date: dayStart,
            label: dayStart.toLocaleDateString('en-US', labelFormat),
            count
        });
    }
    
    return {
        tasks: {
            total: myTasks.length,
            completed: myCompletedTasks.length,
            open: myOpenTasks.length,
            completedLast7Days: completedLast7Days.length,
            completedLast30Days: completedLast30Days.length,
            // Time-filtered stats based on current filter
            completedInPeriod: metricsTimeFilter === '7days' ? completedLast7Days.length : 
                              (metricsTimeFilter === '30days' ? completedLast30Days.length : myCompletedTasks.length),
            completionRate
        },
        events: {
            total: myEvents.length,
            upcoming: upcomingEvents.length,
            createdLast30Days: eventsCreatedLast30Days.length
        },
        messages: {
            total: myMessages.length,
            last7Days: messagesLast7Days.length,
            inPeriod: metricsTimeFilter === '7days' ? messagesLast7Days.length : 
                     (metricsTimeFilter === '30days' ? myMessages.filter(m => {
                         const createdAt = parseMetricsDate(m.createdAt);
                         return createdAt && createdAt >= thirtyDaysAgo;
                     }).length : myMessages.length)
        },
        activities: {
            total: myActivities.length,
            last7Days: activitiesLast7Days.length
        },
        trends: {
            dailyCompletions
        }
    };
}

/**
 * Compute team-wide metrics
 * @param {Object} state - The appState object
 * @returns {Object} Team metrics
 */
function computeTeamMetrics(state) {
    const now = new Date();
    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
    const weekFromNow = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);
    
    // Task metrics
    const allTasks = state.tasks;
    const completedTasks = allTasks.filter(t => t.status === 'done');
    const openTasks = allTasks.filter(t => t.status !== 'done');
    
    const completedLast7Days = completedTasks.filter(t => {
        const completedAt = parseMetricsDate(t.completedAt || t.updatedAt);
        return completedAt && completedAt >= sevenDaysAgo;
    });
    
    const completedLast30Days = completedTasks.filter(t => {
        const completedAt = parseMetricsDate(t.completedAt || t.updatedAt);
        return completedAt && completedAt >= thirtyDaysAgo;
    });
    
    const teamCompletionRate = allTasks.length > 0
        ? Math.round((completedTasks.length / allTasks.length) * 100)
        : 0;
    
    // Per-member task breakdown
    const memberTaskBreakdown = {};
    state.teammates.forEach(member => {
        const memberTasks = allTasks.filter(t => isTaskAssignedToUser(t, member.id) || t.createdBy === member.id);
        const memberCompleted = memberTasks.filter(t => t.status === 'done');
        memberTaskBreakdown[member.id] = {
            name: member.name,
            total: memberTasks.length,
            completed: memberCompleted.length,
            completionRate: memberTasks.length > 0 
                ? Math.round((memberCompleted.length / memberTasks.length) * 100) 
                : 0
        };
    });
    
    // Event metrics
    const upcomingEventsThisWeek = state.events.filter(e => {
        const eventDate = parseMetricsDate(e.date);
        return eventDate && eventDate >= now && eventDate <= weekFromNow;
    });
    
    // Chat metrics
    const messagesLast7Days = state.messages.filter(m => {
        const createdAt = parseMetricsDate(m.createdAt);
        return createdAt && createdAt >= sevenDaysAgo;
    });
    
    // Daily breakdown for team based on time filter
    const daysToShow = metricsTimeFilter === '7days' ? 7 : (metricsTimeFilter === '30days' ? 30 : 90);
    
    const dailyCompletions = [];
    for (let i = daysToShow - 1; i >= 0; i--) {
        const dayStart = new Date(now);
        dayStart.setDate(dayStart.getDate() - i);
        dayStart.setHours(0, 0, 0, 0);
        const dayEnd = new Date(dayStart);
        dayEnd.setHours(23, 59, 59, 999);
        
        const count = completedTasks.filter(t => {
            const completedAt = parseMetricsDate(t.completedAt || t.updatedAt);
            return completedAt && completedAt >= dayStart && completedAt <= dayEnd;
        }).length;
        
        // Use shorter label format for 30 days
        const labelFormat = daysToShow > 7 
            ? { month: 'numeric', day: 'numeric' } 
            : { weekday: 'short' };
        
        dailyCompletions.push({
            date: dayStart,
            label: dayStart.toLocaleDateString('en-US', labelFormat),
            count
        });
    }
    
    return {
        tasks: {
            total: allTasks.length,
            completed: completedTasks.length,
            open: openTasks.length,
            completedLast7Days: completedLast7Days.length,
            completedLast30Days: completedLast30Days.length,
            // Time-filtered stats based on current filter
            completedInPeriod: metricsTimeFilter === '7days' ? completedLast7Days.length : 
                              (metricsTimeFilter === '30days' ? completedLast30Days.length : completedTasks.length),
            completionRate: teamCompletionRate
        },
        memberBreakdown: memberTaskBreakdown,
        events: {
            total: state.events.length,
            upcomingThisWeek: upcomingEventsThisWeek.length,
            inPeriod: upcomingEventsThisWeek.length // Events in the upcoming week
        },
        messages: {
            total: state.messages.length,
            last7Days: messagesLast7Days.length,
            inPeriod: metricsTimeFilter === '7days' ? messagesLast7Days.length : 
                     (metricsTimeFilter === '30days' ? state.messages.filter(m => {
                         const createdAt = parseMetricsDate(m.createdAt);
                         return createdAt && createdAt >= thirtyDaysAgo;
                     }).length : state.messages.length)
        },
        memberCount: state.teammates.length,
        trends: {
            dailyCompletions
        }
    };
}

// ===================================
// LEADS AGGREGATION
// Collects leads from all 'leads' type spreadsheets
// ===================================

/**
 * Get all leads from leads-type spreadsheets
 * @returns {Array} Array of all leads from all leads tables
 */
function getAllLeadsFromTables() {
    if (!appState.spreadsheets || !appState.tasks) return [];
    
    // Find all leads-type spreadsheets
    const leadsSpreadsheets = appState.spreadsheets.filter(s => s.type === 'leads');
    if (leadsSpreadsheets.length === 0) return [];
    
    const leadsSpreadsheetIds = new Set(leadsSpreadsheets.map(s => s.id));
    
    // Get all tasks (which may include leads) that belong to leads spreadsheets
    const allLeads = appState.tasks.filter(task => 
        task.spreadsheetId && leadsSpreadsheetIds.has(task.spreadsheetId)
    );
    
    return allLeads;
}

/**
 * Deduplicate leads by leadName or contact field
 * @param {Array} leads - Array of lead objects
 * @returns {Array} Deduplicated leads (keeping the most recent version)
 */
function deduplicateLeads(leads) {
    if (!leads || leads.length === 0) return [];
    
    const seenLeads = new Map();
    
    // Sort by createdAt descending (newest first) to keep most recent on conflict
    const sortedLeads = [...leads].sort((a, b) => {
        const dateA = a.createdAt || a.updatedAt || 0;
        const dateB = b.createdAt || b.updatedAt || 0;
        return dateB - dateA;
    });
    
    for (const lead of sortedLeads) {
        // Create a unique key from leadName + contact (normalized)
        const name = (lead.leadName || lead.title || '').trim().toLowerCase();
        const contact = (lead.contact || '').trim().toLowerCase();
        const key = `${name}|${contact}`;
        
        // Only add if not seen or if both name and contact are empty (allow duplicates with no identifiers)
        if (key === '|' || !seenLeads.has(key)) {
            seenLeads.set(key, lead);
        }
    }
    
    return Array.from(seenLeads.values());
}

/**
 * Compute leads metrics for display
 * @returns {Object} Leads metrics including counts, value totals, and breakdowns
 */
function computeLeadsMetrics() {
    const allLeads = getAllLeadsFromTables();
    const leads = deduplicateLeads(allLeads);
    
    // Store in appState for access elsewhere
    appState.leads = leads;
    
    if (leads.length === 0) {
        return {
            total: 0,
            totalValue: 0,
            byStatus: {},
            bySource: {},
            recentLeads: [],
            trends: []
        };
    }
    
    const now = new Date();
    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
    
    // Count by status
    const byStatus = {};
    leads.forEach(lead => {
        const status = lead.status || 'New';
        byStatus[status] = (byStatus[status] || 0) + 1;
    });
    
    // Count by source
    const bySource = {};
    leads.forEach(lead => {
        const source = lead.source || 'Unknown';
        bySource[source] = (bySource[source] || 0) + 1;
    });
    
    // Total value
    const totalValue = leads.reduce((sum, lead) => sum + (parseFloat(lead.value) || 0), 0);
    
    // Recent leads (last 7 days)
    const recentLeads = leads.filter(lead => {
        const createdAt = lead.createdAt ? new Date(lead.createdAt) : null;
        return createdAt && createdAt >= sevenDaysAgo;
    });
    
    // Leads created in last 30 days
    const leadsLast30Days = leads.filter(lead => {
        const createdAt = lead.createdAt ? new Date(lead.createdAt) : null;
        return createdAt && createdAt >= thirtyDaysAgo;
    });
    
    // Daily breakdown for trends
    const daysToShow = metricsTimeFilter === '7days' ? 7 : (metricsTimeFilter === '30days' ? 30 : 14);
    const dailyLeads = [];
    for (let i = daysToShow - 1; i >= 0; i--) {
        const dayStart = new Date(now);
        dayStart.setDate(dayStart.getDate() - i);
        dayStart.setHours(0, 0, 0, 0);
        const dayEnd = new Date(dayStart);
        dayEnd.setHours(23, 59, 59, 999);
        
        const count = leads.filter(lead => {
            const createdAt = lead.createdAt ? new Date(lead.createdAt) : null;
            return createdAt && createdAt >= dayStart && createdAt <= dayEnd;
        }).length;
        
        const labelFormat = daysToShow > 7 
            ? { month: 'numeric', day: 'numeric' } 
            : { weekday: 'short' };
        
        dailyLeads.push({
            date: dayStart,
            label: dayStart.toLocaleDateString('en-US', labelFormat),
            count
        });
    }
    
    return {
        total: leads.length,
        totalRaw: allLeads.length, // Before deduplication
        duplicatesRemoved: allLeads.length - leads.length,
        totalValue: totalValue,
        byStatus: byStatus,
        bySource: bySource,
        recentCount: recentLeads.length,
        last30DaysCount: leadsLast30Days.length,
        trends: dailyLeads
    };
}

// Make leads functions accessible globally
window.getAllLeadsFromTables = getAllLeadsFromTables;
window.deduplicateLeads = deduplicateLeads;
window.computeLeadsMetrics = computeLeadsMetrics;

/**
 * Render a progress ring (circular progress indicator)
 * Instagram-inspired vibrant gradient with smooth animation
 */
function createProgressRing(percent, size = 60, strokeWidth = 5, color = '#833AB4') {
    const radius = (size - strokeWidth) / 2;
    const circumference = radius * 2 * Math.PI;
    const offset = circumference - (percent / 100) * circumference;
    
    // Vibrant gradient ID for uniqueness
    const gradientId = `ring-gradient-${Math.random().toString(36).substr(2, 9)}`;
    
    // Use a pink-to-purple gradient for modern look
    const gradientStart = color === '#833AB4' ? '#E1306C' : color;
    const gradientEnd = color === '#833AB4' ? '#833AB4' : color;
    
    return `
        <svg class="progress-ring" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
            <defs>
                <linearGradient id="${gradientId}" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:${gradientStart};stop-opacity:1" />
                    <stop offset="100%" style="stop-color:${gradientEnd};stop-opacity:1" />
                </linearGradient>
            </defs>
            <circle
                class="progress-ring-bg"
                stroke="var(--border-subtle)"
                stroke-width="${strokeWidth}"
                fill="transparent"
                r="${radius}"
                cx="${size / 2}"
                cy="${size / 2}"
                opacity="0.3"
            />
            <circle
                class="progress-ring-progress"
                stroke="url(#${gradientId})"
                stroke-width="${strokeWidth}"
                stroke-linecap="round"
                fill="transparent"
                r="${radius}"
                cx="${size / 2}"
                cy="${size / 2}"
                style="stroke-dasharray: ${circumference}; stroke-dashoffset: ${offset}; transform: rotate(-90deg); transform-origin: center; transition: stroke-dashoffset 0.6s cubic-bezier(0.4, 0, 0.2, 1);"
            />
        </svg>
        <div class="progress-ring-text">${percent}<span class="progress-ring-unit">%</span></div>
    `;
}

/**
 * Render a horizontal bar chart
 * Clean, minimal design - solid colors, no gradients, no hover animations
 * Bars with value 0 are NOT shown (no visible bar segment)
 * Values are displayed clearly next to each bar
 */
function createBarChart(data, maxValue = null, options = {}) {
    // Handle empty data with styled empty state
    if (!data || data.length === 0) {
        return createChartEmptyState('No data available');
    }
    
    // Show chart even if all values are 0 - this lets users see categories
    const {
        primaryColor = 'var(--accent)',
        secondaryColor = '#34C759'
    } = options;
    
    const max = maxValue || Math.max(...data.map(d => d.value), 1);
    
    let html = '<div class="bar-chart-clean">';
    
    data.forEach((item, index) => {
        const value = item.value || 0;
        // For value 0: width is exactly 0 (no bar shown)
        // For value > 0: calculate percentage, minimum 2% for very small values
        const percentage = value === 0 ? 0 : Math.max((value / max) * 100, 2);
        const barColor = item.color || primaryColor;
        const hasBar = value > 0;
        
        html += `
            <div class="bar-row-clean">
                <div class="bar-label-clean" title="${escapeHtml(item.label)}">${escapeHtml(item.label)}</div>
                <div class="bar-track-clean">
                    ${hasBar ? `<div class="bar-fill-clean" style="width: ${percentage}%; background-color: ${barColor};"></div>` : ''}
                </div>
                <div class="bar-value-clean">${formatAxisValue(value)}</div>
            </div>
        `;
    });
    
    html += '</div>';
    return html;
}

/**
 * Create a styled empty state for charts
 * Uses a progress ring style circle with message
 */
function createChartEmptyState(message = 'No data available') {
    return `
        <div class="chart-empty-state">
            <div class="chart-empty-ring">
                <svg width="80" height="80" viewBox="0 0 80 80">
                    <circle 
                        cx="40" cy="40" r="34" 
                        fill="none" 
                        stroke="var(--border-subtle)" 
                        stroke-width="3"
                        stroke-dasharray="8 4"
                        opacity="0.5"
                    />
                    <circle 
                        cx="40" cy="40" r="24" 
                        fill="var(--bg-body)" 
                    />
                </svg>
                <div class="chart-empty-icon">
                    <i class="fas fa-chart-line"></i>
                </div>
            </div>
            <span class="chart-empty-text">${escapeHtml(message)}</span>
        </div>
    `;
}

/**
 * Format axis value - avoid float clutter
 */
function formatAxisValue(value) {
    if (Number.isInteger(value)) return value.toString();
    if (value >= 1000) return Math.round(value).toString();
    if (value >= 100) return Math.round(value).toString();
    // Max 1 decimal place
    const rounded = Math.round(value * 10) / 10;
    return Number.isInteger(rounded) ? rounded.toString() : rounded.toFixed(1);
}

/**
 * Render a vertical trend bar chart (sparkline-style)
 * Robust for any dataset size (1 to many)
 * Supports custom Y-axis config via options
 */
function createTrendChart(data, options = {}) {
    // Handle empty data
    if (!data || data.length === 0) {
        return createChartEmptyState('No trend data');
    }
    
    // Don't show "Data coming soon" for zero values - show the graph with zeros
    // This allows users to see the timeline even when no activity occurred
    
    const {
        showSecondaryAxis = false,
        secondaryData = null,
        primaryColor = 'var(--accent)',
        secondaryColor = '#34C759',
        yAxisMin = 0,
        yAxisMax = null,
        yAxisStep = null,
        tickCount = 3 // Default tick count, can be overridden by tickDensity
    } = options;
    
    const dataMax = Math.max(...data.map(d => d.count), 1);
    const dataMin = Math.min(...data.map(d => d.count), 0);
    const secondaryMax = secondaryData ? Math.max(...secondaryData.map(d => d.count), 1) : dataMax;
    
    // Use custom Y-axis config if provided
    const effectiveMin = Math.max(yAxisMin ?? 0, 0); // Never go below 0
    const effectiveMax = yAxisMax ?? dataMax;
    
    // Generate Y-axis ticks based on config
    let yTicks;
    if (yAxisStep && yAxisStep > 0) {
        // Custom step: generate ticks from max down to min
        yTicks = [];
        for (let v = effectiveMax; v >= effectiveMin; v -= yAxisStep) {
            yTicks.push(Math.round(v * 100) / 100);
        }
        if (yTicks[yTicks.length - 1] !== effectiveMin) {
            yTicks.push(effectiveMin);
        }
    } else {
        // Auto ticks - use tickCount from options
        yTicks = generateCleanAxisTicks(effectiveMax, tickCount);
    }
    
    const displayMax = yTicks[0]; // Use the nice max for scaling
    const displayMin = yTicks[yTicks.length - 1];
    const displayRange = displayMax - displayMin;
    
    // Calculate bar width based on data length
    const barCount = data.length;
    const minBarWidth = 8;
    const maxBarWidth = 40;
    const calculatedWidth = Math.floor(100 / barCount) - 2;
    const barWidth = Math.min(maxBarWidth, Math.max(minBarWidth, calculatedWidth));
    
    // Determine which X-labels to show (avoid overlap)
    const xLabelIndices = getXLabelIndices(data.length);
    
    let html = `<div class="metrics-trend-chart-v2" data-bar-count="${barCount}">`;
    
    // Y-axis with clean scale markers
    html += `
        <div class="trend-y-axis">
            ${yTicks.map(tick => `<span class="y-axis-label">${formatAxisValue(tick)}</span>`).join('')}
        </div>
    `;
    
    // Secondary Y-axis if enabled
    if (showSecondaryAxis && secondaryData) {
        const secYTicks = generateCleanAxisTicks(secondaryMax, 3);
        html += `
            <div class="trend-y-axis-secondary">
                ${secYTicks.map(tick => `<span class="y-axis-label">${formatAxisValue(tick)}</span>`).join('')}
            </div>
        `;
    }
    
    html += '<div class="trend-chart-area">';
    
    // Grid lines (match Y tick count)
    html += `
        <div class="trend-grid-lines">
            ${yTicks.map(() => '<div class="grid-line"></div>').join('')}
        </div>
    `;
    
    html += '<div class="trend-bars-container">';
    
    data.forEach((item, index) => {
        // Calculate height using the effective range (supports custom Y-axis)
        const clampedValue = Math.max(displayMin, Math.min(displayMax, item.count));
        const height = displayRange > 0 ? Math.max(((clampedValue - displayMin) / displayRange) * 100, 3) : 3;
        const delay = index * 0.04;
        const showLabel = xLabelIndices.has(index);
        
        let secondaryBarHtml = '';
        if (showSecondaryAxis && secondaryData && secondaryData[index]) {
            const secDisplayMax = generateCleanAxisTicks(secondaryMax, 3)[0];
            const secHeight = secDisplayMax > 0 ? Math.max((secondaryData[index].count / secDisplayMax) * 100, 3) : 3;
            secondaryBarHtml = `<div class="trend-bar-secondary" style="height: ${secHeight}%; background: ${secondaryColor}; transition-delay: ${delay + 0.05}s"></div>`;
        }
        
        html += `
            <div class="trend-bar-group" style="--bar-width: ${barWidth}px">
                <div class="trend-bar-wrapper" data-tooltip="${escapeHtml(item.label)}: ${item.count}">
                    <div class="trend-bar-primary" style="height: ${height}%; background: linear-gradient(180deg, ${primaryColor} 0%, ${primaryColor}88 100%); transition-delay: ${delay}s"></div>
                    ${secondaryBarHtml}
                </div>
                <span class="trend-bar-label ${showLabel ? '' : 'hidden'}">${escapeHtml(item.label)}</span>
            </div>
        `;
    });
    
    html += '</div></div></div>';
    return html;
}

/**
 * Render a stat card with optional tooltip
 * Apple-inspired glassmorphism card with subtle icon
 * @param {string} icon - FontAwesome icon class (e.g., 'fa-check-circle')
 * @param {number|string} value - Main value to display
 * @param {string} label - Label text
 * @param {string} subtitle - Subtitle text (optional)
 * @param {string} colorClass - CSS color class (optional: 'success', 'warning', 'danger')
 * @param {string} tooltip - Tooltip text on hover (optional)
 */
function createStatCard(icon, value, label, subtitle = '', colorClass = '', tooltip = '') {
    const tooltipAttr = tooltip ? `data-tooltip="${tooltip}"` : '';
    const colorStyle = colorClass ? `metrics-stat-card-${colorClass}` : '';
    return `
        <div class="metrics-stat-card ${colorStyle}" ${tooltipAttr}>
            <div class="metrics-stat-icon">
                <i class="fas ${icon}"></i>
            </div>
            <div class="metrics-stat-content">
                <div class="metrics-stat-value">${value}</div>
                <div class="metrics-stat-label">${label}</div>
                ${subtitle ? `<div class="metrics-stat-subtitle">${subtitle}</div>` : ''}
            </div>
        </div>
    `;
}

// ===================================
// GRAPH TYPE SWITCHING SYSTEM
// ===================================

/**
 * Get the current graph type for a specific graph
 * @param {string} graphId - Unique identifier for the graph
 * @returns {string} - 'bar' | 'line' | 'pie'
 */
function getGraphType(graphId) {
    return appState.graphTypes[graphId] || 'bar';
}

/**
 * Set the graph type for a specific graph
 * @param {string} graphId - Unique identifier for the graph
 * @param {string} type - 'bar' | 'line' | 'pie'
 */
function setGraphType(graphId, type) {
    appState.graphTypes[graphId] = type;
}

/**
 * Toggle graph menu visibility
 * @param {Event} event - Click event
 * @param {string} graphId - Unique identifier for the graph
 */
function toggleGraphMenu(event, graphId) {
    event.stopPropagation();
    
    // Close all other open menus
    document.querySelectorAll('.graph-menu-dropdown.active').forEach(menu => {
        if (menu.dataset.graphId !== graphId) {
            menu.classList.remove('active');
        }
    });
    
    const menu = document.querySelector(`.graph-menu-dropdown[data-graph-id="${graphId}"]`);
    if (menu) {
        menu.classList.toggle('active');
    }
}

/**
 * Close all graph menus
 */
function closeAllGraphMenus() {
    document.querySelectorAll('.graph-menu-dropdown.active').forEach(menu => {
        menu.classList.remove('active');
    });
}

// Close menus when clicking outside
document.addEventListener('click', (e) => {
    if (!e.target.closest('.graph-menu-container')) {
        closeAllGraphMenus();
    }
});

/**
 * Switch graph type and re-render
 * @param {string} graphId - Unique identifier for the graph
 * @param {string} type - 'bar' | 'line' | 'pie'
 */
function switchGraphType(graphId, type) {
    setGraphType(graphId, type);
    closeAllGraphMenus();
    
    // Also update the chart config if user can edit
    if (canEditMetrics()) {
        updateChartConfig(graphId, { type: type });
        // The updateChartConfig will handle re-rendering
        return;
    }
    
    // Find the graph container and re-render (for non-editors)
    const container = document.querySelector(`[data-graph-id="${graphId}"] .graph-content`);
    if (container) {
        // Get stored data
        const dataAttr = container.closest('.metrics-card')?.dataset.graphData;
        const dataType = container.closest('.metrics-card')?.dataset.graphDataType;
        
        if (dataAttr) {
            try {
                const data = JSON.parse(dataAttr);
                const config = getChartConfig(graphId);
                // Add fade-out animation
                container.style.opacity = '0';
                container.style.transform = 'scale(0.98)';
                
                setTimeout(() => {
                    container.innerHTML = renderGraphByTypeWithConfig(data, type, dataType, config);
                    // Fade in
                    requestAnimationFrame(() => {
                        container.style.opacity = '1';
                        container.style.transform = 'scale(1)';
                    });
                }, 150);
            } catch (e) {
                console.error('Error parsing graph data:', e);
            }
        }
    }
    
    // Update the menu button icon to reflect current type
    updateGraphMenuIcon(graphId, type);
}

/**
 * Update the graph menu icon to show current type
 */
function updateGraphMenuIcon(graphId, type) {
    const iconMap = {
        'bar': 'fa-chart-bar',
        'line': 'fa-chart-line',
        'pie': 'fa-chart-pie'
    };
    
    // Update the button icon to reflect current type
    const menuBtn = document.querySelector(`.metrics-card[data-graph-id="${graphId}"] .graph-menu-btn`);
    if (menuBtn) {
        const icon = menuBtn.querySelector('i');
        if (icon) {
            // Remove all chart icons
            icon.classList.remove('fa-chart-bar', 'fa-chart-line', 'fa-chart-pie');
            // Add the current type icon
            icon.classList.add(iconMap[type] || 'fa-chart-bar');
        }
        menuBtn.dataset.currentType = type;
    }
    
    // Update the active state in dropdown
    const dropdown = document.querySelector(`.graph-menu-dropdown[data-graph-id="${graphId}"]`);
    if (dropdown) {
        dropdown.querySelectorAll('.graph-menu-option').forEach(opt => {
            opt.classList.toggle('active', opt.dataset.type === type);
        });
    }
}

// Expose graph functions globally
window.toggleGraphMenu = toggleGraphMenu;
window.switchGraphType = switchGraphType;

/**
 * Render graph based on type
 * @param {Array} data - Graph data
 * @param {string} type - 'bar' | 'line' | 'pie'
 * @param {string} dataType - 'trend' | 'breakdown' to determine data structure
 */
function renderGraphByType(data, type, dataType = 'trend') {
    if (!data || data.length === 0) {
        return createChartEmptyState('No data available');
    }
    
    switch (type) {
        case 'line':
            return dataType === 'breakdown' 
                ? createLineChartFromBreakdown(data)
                : createLineChart(data);
        case 'pie':
            return dataType === 'breakdown'
                ? createPieChart(data)
                : createPieChartFromTrend(data);
        case 'bar':
        default:
            return dataType === 'breakdown'
                ? createBarChart(data)
                : createTrendChart(data);
    }
}

/**
 * Render graph based on type WITH custom configuration
 * @param {Array} data - Graph data
 * @param {string} type - 'bar' | 'line' | 'pie'
 * @param {string} dataType - 'trend' | 'breakdown' to determine data structure
 * @param {Object} config - Chart configuration (yAxisMin, yAxisMax, colors, tickDensity, palette, etc.)
 */
function renderGraphByTypeWithConfig(data, type, dataType = 'trend', config = {}) {
    if (!data || data.length === 0) {
        return createChartEmptyState('No data available');
    }
    
    // Get tick count from density setting
    const tickDensity = config.tickDensity || 'normal';
    const tickDensityConfig = TICK_DENSITY_OPTIONS.find(t => t.id === tickDensity) || TICK_DENSITY_OPTIONS[1];
    const tickCount = tickDensityConfig.ticks;
    
    // Build options from config
    const options = {
        primaryColor: config.primaryColor || '#833AB4',
        secondaryColor: config.secondaryColor || '#E1306C',
        showSecondaryAxis: config.showSecondaryAxis || false,
        yAxisMin: config.yAxisMode === 'auto' ? 0 : (config.yAxisMin ?? 0),
        yAxisMax: config.yAxisMode === 'auto' ? null : (config.yAxisMax ?? null),
        yAxisStep: config.yAxisMode === 'auto' ? null : (config.yAxisStep ?? null),
        tickCount: tickCount,
        palette: config.palette || 'default'
    };
    
    switch (type) {
        case 'line':
            return dataType === 'breakdown' 
                ? createLineChartFromBreakdown(data, options)
                : createLineChart(data, options);
        case 'pie':
            return dataType === 'breakdown'
                ? createPieChart(data, options)
                : createPieChartFromTrend(data, options);
        case 'bar':
        default:
            return dataType === 'breakdown'
                ? createBarChart(data, null, options)
                : createTrendChart(data, options);
    }
}

/**
 * Generate clean, unique axis tick values
 * Always starts from 0, no duplicates, nice round numbers
 */
function generateCleanAxisTicks(max, steps = 4) {
    // Handle edge cases
    if (max <= 0) return [0];
    if (max === 1) return [1, 0];
    
    // For very small values, use simpler logic
    if (max <= steps) {
        const ticks = [];
        for (let i = max; i >= 0; i--) {
            ticks.push(i);
        }
        return ticks;
    }
    
    // Find a nice round step size
    const roughStep = max / steps;
    const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));
    const residual = roughStep / magnitude;
    
    let niceStep;
    if (residual <= 1.5) niceStep = magnitude;
    else if (residual <= 3) niceStep = 2 * magnitude;
    else if (residual <= 7) niceStep = 5 * magnitude;
    else niceStep = 10 * magnitude;
    
    // Calculate nice max (round up to nearest step)
    const niceMax = Math.ceil(max / niceStep) * niceStep;
    
    // Generate ticks from niceMax down to 0
    const ticks = [];
    for (let v = niceMax; v >= 0; v -= niceStep) {
        // Round to avoid floating point issues
        const rounded = Math.round(v * 1000) / 1000;
        ticks.push(rounded);
    }
    
    // Ensure 0 is included at the end
    if (ticks[ticks.length - 1] !== 0) {
        ticks.push(0);
    }
    
    return ticks;
}

/**
 * Generate nice axis scale values (legacy function - wraps generateCleanAxisTicks)
 */
function generateAxisScale(max, steps = 4) {
    return generateCleanAxisTicks(max, steps);
}

/**
 * Determine which X-axis labels to show based on data count
 * Returns a Set of indices to display
 */
function getXLabelIndices(dataLength) {
    const indices = new Set();
    
    if (dataLength <= 0) return indices;
    
    // Always show first and last
    indices.add(0);
    indices.add(dataLength - 1);
    
    if (dataLength <= 5) {
        // Show all for small datasets
        for (let i = 0; i < dataLength; i++) indices.add(i);
    } else if (dataLength <= 10) {
        // Show every other
        for (let i = 0; i < dataLength; i += 2) indices.add(i);
    } else {
        // Show ~5 evenly spaced labels
        const step = Math.ceil(dataLength / 5);
        for (let i = 0; i < dataLength; i += step) indices.add(i);
    }
    
    return indices;
}

/**
 * Create smooth bezier curve path for line chart
 * Uses monotone cubic interpolation to prevent overshoot below 0
 * @param {Array} points - Array of {x, y, value} objects
 * @param {number} yMax - Maximum Y coordinate (top of chart area)
 * @param {number} yMin - Minimum Y coordinate (bottom of chart area, where y=0)
 */
function createSmoothPath(points, yMax = null, yMin = null) {
    if (points.length < 2) return '';
    if (points.length === 2) {
        return `M ${points[0].x},${points[0].y} L ${points[1].x},${points[1].y}`;
    }
    
    // Use monotone cubic interpolation to prevent overshoot
    // This ensures the curve never goes above local maxima or below local minima
    const n = points.length;
    
    // Calculate slopes
    const slopes = [];
    for (let i = 0; i < n - 1; i++) {
        const dx = points[i + 1].x - points[i].x;
        const dy = points[i + 1].y - points[i].y;
        slopes.push(dx !== 0 ? dy / dx : 0);
    }
    
    // Calculate tangents using monotone method
    const tangents = [slopes[0]];
    for (let i = 1; i < n - 1; i++) {
        // If slopes have different signs or either is zero, tangent is 0
        if (slopes[i - 1] * slopes[i] <= 0) {
            tangents.push(0);
        } else {
            // Use harmonic mean of slopes for monotonicity
            tangents.push(2 / (1 / slopes[i - 1] + 1 / slopes[i]));
        }
    }
    tangents.push(slopes[n - 2]);
    
    // Build path with cubic bezier segments
    let path = `M ${points[0].x.toFixed(2)},${points[0].y.toFixed(2)}`;
    
    for (let i = 0; i < n - 1; i++) {
        const p0 = points[i];
        const p1 = points[i + 1];
        const dx = (p1.x - p0.x) / 3;
        
        // Control points
        let cp1x = p0.x + dx;
        let cp1y = p0.y + tangents[i] * dx;
        let cp2x = p1.x - dx;
        let cp2y = p1.y - tangents[i + 1] * dx;
        
        // Clamp control points to prevent overshoot beyond data bounds
        if (yMax !== null && yMin !== null) {
            // Clamp to chart boundaries (remember: y increases downward in SVG)
            cp1y = Math.max(yMax, Math.min(yMin, cp1y));
            cp2y = Math.max(yMax, Math.min(yMin, cp2y));
        }
        
        // Additional clamping: control points shouldn't create overshoot beyond the segment's y-range
        const segMinY = Math.min(p0.y, p1.y);
        const segMaxY = Math.max(p0.y, p1.y);
        // Allow some tolerance but prevent extreme overshoot
        const tolerance = (segMaxY - segMinY) * 0.1;
        cp1y = Math.max(segMinY - tolerance, Math.min(segMaxY + tolerance, cp1y));
        cp2y = Math.max(segMinY - tolerance, Math.min(segMaxY + tolerance, cp2y));
        
        path += ` C ${cp1x.toFixed(2)},${cp1y.toFixed(2)} ${cp2x.toFixed(2)},${cp2y.toFixed(2)} ${p1.x.toFixed(2)},${p1.y.toFixed(2)}`;
    }
    
    return path;
}

/**
 * Create a modern line chart with dual-axis support
 * Clean, minimal Instagram-style design
 * Clamps Y-axis to always start at 0 (no negative values)
 * Supports custom Y-axis config via options
 * @param {Array} data - Array of { label, count } objects
 * @param {Object} options - Chart options
 */
function createLineChart(data, options = {}) {
    // Handle empty or invalid data
    if (!data || data.length === 0) {
        return createChartEmptyState('No data available');
    }
    
    // Show the chart even if all values are 0 - flat line at bottom
    const {
        showSecondaryAxis = false,
        secondaryData = null,
        primaryColor = '#833AB4',
        secondaryColor = '#E1306C',
        primaryLabel = '',
        secondaryLabel = '',
        height = 140,
        showDots = true,
        showArea = true,
        smoothCurve = true,
        yAxisMin = 0,
        yAxisMax = null,
        yAxisStep = null,
        tickCount = 4 // Default tick count, can be overridden by tickDensity
    } = options;
    
    // Chart dimensions
    const width = 400;
    const chartHeight = height;
    const padding = { top: 16, right: showSecondaryAxis ? 45 : 16, bottom: 32, left: 40 };
    const drawWidth = width - padding.left - padding.right;
    const drawHeight = chartHeight - padding.top - padding.bottom;
    
    // Calculate scales - using custom Y-axis config if provided
    const dataMax = Math.max(...data.map(d => Math.max(0, d.count || 0)), 1);
    const effectiveMin = Math.max(yAxisMin ?? 0, 0); // Never below 0
    const effectiveMax = yAxisMax ?? dataMax;
    
    // Generate Y-axis ticks based on config
    let primaryTicks;
    if (yAxisStep && yAxisStep > 0) {
        primaryTicks = [];
        for (let v = effectiveMax; v >= effectiveMin; v -= yAxisStep) {
            primaryTicks.push(Math.round(v * 100) / 100);
        }
        if (primaryTicks[primaryTicks.length - 1] !== effectiveMin) {
            primaryTicks.push(effectiveMin);
        }
    } else {
        // Use tickCount from options
        primaryTicks = generateCleanAxisTicks(effectiveMax, tickCount);
    }
    
    const primaryMax = primaryTicks[0];
    const primaryMin = primaryTicks[primaryTicks.length - 1];
    const primaryRange = primaryMax - primaryMin;
    
    let secondaryTicks = [];
    let secondaryMax = primaryMax;
    let secondaryMin = primaryMin;
    if (secondaryData && secondaryData.length > 0) {
        const secMaxValue = Math.max(...secondaryData.map(d => Math.max(0, d.count || 0)), 1);
        secondaryTicks = generateCleanAxisTicks(secMaxValue, 4);
        secondaryMax = secondaryTicks[0];
        secondaryMin = secondaryTicks[secondaryTicks.length - 1];
    }
    
    // Generate points - using the effective range for Y positioning
    const getX = (index, len) => padding.left + (len === 1 ? drawWidth / 2 : (index / (len - 1)) * drawWidth);
    const getY = (value, maxVal, minVal = 0) => {
        const range = maxVal - minVal;
        const clampedValue = Math.max(minVal, Math.min(maxVal, value));
        return padding.top + drawHeight - ((clampedValue - minVal) / (range || 1)) * drawHeight;
    };
    
    const primaryPoints = data.map((item, i) => ({
        x: getX(i, data.length),
        y: getY(item.count, primaryMax, primaryMin),
        value: Math.max(0, item.count),
        label: item.label
    }));
    
    const secondaryPoints = secondaryData ? secondaryData.map((item, i) => ({
        x: getX(i, secondaryData.length),
        y: getY(item.count, secondaryMax, secondaryMin),
        value: Math.max(0, item.count),
        label: item.label
    })) : [];
    
    // Generate paths - pass Y-axis bounds to prevent overshoot
    const yTopBound = padding.top; // Top of chart area (minimum Y in SVG coords)
    const yBottomBound = padding.top + drawHeight; // Bottom of chart area (maximum Y in SVG coords = y=0 line)
    
    const primaryPath = smoothCurve && primaryPoints.length > 2
        ? createSmoothPath(primaryPoints, yTopBound, yBottomBound)
        : primaryPoints.length > 1
            ? `M ${primaryPoints.map(p => `${p.x},${p.y}`).join(' L ')}`
            : '';
    
    const secondaryPath = secondaryPoints.length > 1
        ? (smoothCurve && secondaryPoints.length > 2
            ? createSmoothPath(secondaryPoints, yTopBound, yBottomBound)
            : `M ${secondaryPoints.map(p => `${p.x},${p.y}`).join(' L ')}`)
        : '';
    
    // Area path for primary
    const areaPath = showArea && primaryPoints.length > 1
        ? `${primaryPath} L ${primaryPoints[primaryPoints.length - 1].x},${padding.top + drawHeight} L ${primaryPoints[0].x},${padding.top + drawHeight} Z`
        : '';
    
    const gradientId = `line-grad-${Math.random().toString(36).substr(2, 9)}`;
    const gradientId2 = `line-grad2-${Math.random().toString(36).substr(2, 9)}`;
    
    // Determine label display using the helper function
    const labelIndices = getXLabelIndices(data.length);
    
    return `
        <div class="line-chart-v2">
            <svg viewBox="0 0 ${width} ${chartHeight}" preserveAspectRatio="xMidYMid meet">
                <defs>
                    <linearGradient id="${gradientId}" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" stop-color="${primaryColor}" stop-opacity="0.25" />
                        <stop offset="100%" stop-color="${primaryColor}" stop-opacity="0.02" />
                    </linearGradient>
                    <linearGradient id="${gradientId2}" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" stop-color="${secondaryColor}" stop-opacity="0.2" />
                        <stop offset="100%" stop-color="${secondaryColor}" stop-opacity="0.02" />
                    </linearGradient>
                </defs>
                
                <!-- Grid lines -->
                <g class="line-chart-grid">
                    ${primaryTicks.map((val, i) => {
                        const y = padding.top + (i / Math.max(primaryTicks.length - 1, 1)) * drawHeight;
                        return `<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" />`;
                    }).join('')}
                </g>
                
                <!-- Primary Y-axis labels -->
                <g class="line-chart-y-labels">
                    ${primaryTicks.map((val, i) => {
                        const y = padding.top + (i / Math.max(primaryTicks.length - 1, 1)) * drawHeight;
                        return `<text x="${padding.left - 8}" y="${y}" text-anchor="end" dominant-baseline="middle">${formatAxisValue(val)}</text>`;
                    }).join('')}
                </g>
                
                <!-- Secondary Y-axis labels -->
                ${showSecondaryAxis && secondaryTicks.length > 0 ? `
                    <g class="line-chart-y-labels secondary">
                        ${secondaryTicks.map((val, i) => {
                            const y = padding.top + (i / Math.max(secondaryTicks.length - 1, 1)) * drawHeight;
                            return `<text x="${width - padding.right + 8}" y="${y}" text-anchor="start" dominant-baseline="middle">${formatAxisValue(val)}</text>`;
                        }).join('')}
                    </g>
                ` : ''}
                
                <!-- Area fill -->
                ${showArea && areaPath ? `<path class="line-chart-area-v2" d="${areaPath}" fill="url(#${gradientId})" />` : ''}
                
                <!-- Secondary line -->
                ${secondaryPath ? `
                    <path class="line-chart-stroke secondary" d="${secondaryPath}" stroke="${secondaryColor}" />
                ` : ''}
                
                <!-- Primary line -->
                ${primaryPath ? `<path class="line-chart-stroke primary" d="${primaryPath}" stroke="${primaryColor}" />` : ''}
                
                <!-- Dots -->
                ${showDots ? `
                    <g class="line-chart-dots">
                        ${primaryPoints.map((p, i) => `
                            <circle 
                                cx="${p.x}" cy="${p.y}" r="4" 
                                fill="var(--bg-surface)" 
                                stroke="${primaryColor}" 
                                stroke-width="2"
                                class="line-dot"
                                data-tooltip="${escapeHtml(p.label)}: ${formatAxisValue(p.value)}"
                            />
                        `).join('')}
                        ${secondaryPoints.map((p, i) => `
                            <circle 
                                cx="${p.x}" cy="${p.y}" r="3.5" 
                                fill="var(--bg-surface)" 
                                stroke="${secondaryColor}" 
                                stroke-width="2"
                                class="line-dot secondary"
                                data-tooltip="${escapeHtml(p.label)}: ${formatAxisValue(p.value)}"
                            />
                        `).join('')}
                    </g>
                ` : ''}
                
                <!-- X-axis labels -->
                <g class="line-chart-x-labels">
                    ${data.map((item, i) => {
                        if (!labelIndices.has(i)) return '';
                        const x = getX(i, data.length);
                        return `<text x="${x}" y="${chartHeight - 8}" text-anchor="middle">${escapeHtml(item.label)}</text>`;
                    }).join('')}
                </g>
            </svg>
            
            ${primaryLabel || secondaryLabel ? `
                <div class="line-chart-legend">
                    ${primaryLabel ? `<span class="legend-item"><span class="legend-dot" style="background: ${primaryColor}"></span>${escapeHtml(primaryLabel)}</span>` : ''}
                    ${secondaryLabel ? `<span class="legend-item"><span class="legend-dot" style="background: ${secondaryColor}"></span>${escapeHtml(secondaryLabel)}</span>` : ''}
                </div>
            ` : ''}
        </div>
    `;
}

/**
 * Create a line chart from breakdown data
 */
function createLineChartFromBreakdown(data, options = {}) {
    const trendData = data.map(item => ({
        label: item.label,
        count: item.value
    }));
    return createLineChart(trendData, options);
}

/**
 * Create a pie chart (SVG-based donut style)
 * Apple-inspired minimal design
 * @param {Array} data - Array of { label, value|count, color } objects
 * @param {Object} options - Optional chart options (primaryColor, palette, etc.)
 */
function createPieChart(data, options = {}) {
    // Handle empty data
    if (!data || data.length === 0) {
        return createChartEmptyState('No data available');
    }
    
    // Normalize data: support both 'value' and 'count' properties
    const normalizedData = data.map(item => ({
        label: item.label || 'Unknown',
        value: item.value ?? item.count ?? 0,
        color: item.color
    })).filter(item => item.value > 0); // Filter out zero/negative values
    
    if (normalizedData.length === 0) {
        return createChartEmptyState('Data coming soon');
    }
    
    const total = normalizedData.reduce((sum, item) => sum + item.value, 0);
    if (total === 0) {
        return createChartEmptyState('Data coming soon');
    }
    
    const size = 120;
    const center = size / 2;
    const radius = 45;
    const innerRadius = 28; // Donut style
    
    let currentAngle = -90; // Start from top
    
    // Get colors from palette if specified, or generate distinct colors per member
    const paletteId = options.palette || 'default';
    const paletteConfig = PIE_PALETTE_OPTIONS.find(p => p.id === paletteId) || PIE_PALETTE_OPTIONS[0];
    let defaultColors = paletteConfig.colors;
    
    // For member-based data, generate stable distinct colors
    if (options.colorByMember && normalizedData.length > defaultColors.length) {
        // Extend palette with hashed colors
        const extendedColors = [...defaultColors];
        for (let i = defaultColors.length; i < normalizedData.length; i++) {
            const hue = (i * 137.5) % 360; // Golden angle for distinct hues
            extendedColors.push(`hsl(${hue}, 65%, 55%)`);
        }
        defaultColors = extendedColors;
    }
    
    // Handle single segment edge case (full circle)
    if (normalizedData.length === 1) {
        const item = normalizedData[0];
        const color = item.color || defaultColors[0];
        return `
            <div class="metrics-pie-chart">
                <svg viewBox="0 0 ${size} ${size}">
                    <circle cx="${center}" cy="${center}" r="${radius}" fill="${color}" />
                    <circle cx="${center}" cy="${center}" r="${innerRadius}" fill="var(--bg-surface)" />
                    <text x="${center}" y="${center}" text-anchor="middle" dominant-baseline="middle" class="pie-total">${formatAxisValue(total)}</text>
                </svg>
                <div class="pie-legend">
                    <div class="pie-legend-item">
                        <span class="pie-legend-color" style="background: ${color}"></span>
                        <span class="pie-legend-label">${escapeHtml(item.label)}</span>
                        <span class="pie-legend-value">${formatAxisValue(item.value)} (100%)</span>
                    </div>
                </div>
            </div>
        `;
    }
    
    const segments = normalizedData.map((item, index) => {
        const percentage = (item.value / total) * 100;
        const angle = (percentage / 100) * 360;
        
        // Handle very small angles that could cause rendering issues
        if (angle < 0.5) {
            return null; // Skip tiny segments
        }
        
        const startAngle = currentAngle;
        const endAngle = currentAngle + angle;
        
        // Calculate path
        const startRad = (startAngle * Math.PI) / 180;
        const endRad = (endAngle * Math.PI) / 180;
        
        const x1 = center + radius * Math.cos(startRad);
        const y1 = center + radius * Math.sin(startRad);
        const x2 = center + radius * Math.cos(endRad);
        const y2 = center + radius * Math.sin(endRad);
        
        const x3 = center + innerRadius * Math.cos(endRad);
        const y3 = center + innerRadius * Math.sin(endRad);
        const x4 = center + innerRadius * Math.cos(startRad);
        const y4 = center + innerRadius * Math.sin(startRad);
        
        const largeArc = angle > 180 ? 1 : 0;
        // Use assigned color or default based on index (ensures distinct colors)
        const color = item.color || defaultColors[index % defaultColors.length];
        
        currentAngle = endAngle;
        
        const path = `M ${x1.toFixed(2)} ${y1.toFixed(2)} A ${radius} ${radius} 0 ${largeArc} 1 ${x2.toFixed(2)} ${y2.toFixed(2)} L ${x3.toFixed(2)} ${y3.toFixed(2)} A ${innerRadius} ${innerRadius} 0 ${largeArc} 0 ${x4.toFixed(2)} ${y4.toFixed(2)} Z`;
        
        return { path, color, label: item.label, value: item.value, percentage: percentage.toFixed(1) };
    }).filter(seg => seg !== null); // Remove skipped segments
    
    if (segments.length === 0) {
        return createChartEmptyState('Data coming soon');
    }
    
    return `
        <div class="metrics-pie-chart">
            <svg viewBox="0 0 ${size} ${size}">
                ${segments.map((seg, i) => `
                    <path 
                        class="pie-segment" 
                        d="${seg.path}" 
                        fill="${seg.color}"
                        data-tooltip="${escapeHtml(seg.label)}: ${formatAxisValue(seg.value)} (${seg.percentage}%)"
                        style="animation-delay: ${i * 0.05}s"
                    />
                `).join('')}
                <circle cx="${center}" cy="${center}" r="${innerRadius - 2}" fill="var(--bg-surface)" />
                <text x="${center}" y="${center}" text-anchor="middle" dominant-baseline="middle" class="pie-total">${formatAxisValue(total)}</text>
            </svg>
            <div class="pie-legend">
                ${segments.slice(0, 5).map(seg => `
                    <div class="pie-legend-item">
                        <span class="pie-legend-color" style="background: ${seg.color}"></span>
                        <span class="pie-legend-label">${escapeHtml(seg.label)}</span>
                        <span class="pie-legend-value">${formatAxisValue(seg.value)}</span>
                    </div>
                `).join('')}
                ${segments.length > 5 ? `<div class="pie-legend-more">+${segments.length - 5} more</div>` : ''}
            </div>
        </div>
    `;
}

/**
 * Create a pie chart from trend data
 * @param {Array} data - Trend data with { label, count }
 * @param {Object} options - Chart options (palette, etc.)
 */
function createPieChartFromTrend(data, options = {}) {
    // Aggregate trend data into segments
    const pieData = data
        .filter(item => item.count > 0)
        .slice(0, 8)
        .map(item => ({
            label: item.label,
            value: item.count
        }));
    
    if (pieData.length === 0) {
        return createChartEmptyState('No trend data');
    }
    
    return createPieChart(pieData, options);
}

/**
 * Create a metrics card with switchable graph types
 * Includes inline settings panel when in edit mode
 * @param {string} graphId - Unique identifier for this graph
 * @param {string} title - Card title
 * @param {string} icon - FontAwesome icon class
 * @param {Array} data - Graph data
 * @param {string} dataType - 'trend' | 'breakdown'
 */
function createSwitchableGraphCard(graphId, title, icon, data, dataType = 'trend', options = {}) {
    const config = getChartConfig(graphId);
    const currentType = config.type || getGraphType(graphId);
    const graphContent = renderGraphByTypeWithConfig(data, currentType, dataType, config);
    
    // Store data as JSON for re-rendering on type switch
    const dataJson = JSON.stringify(data).replace(/"/g, '&quot;');
    
    // Build settings panel HTML (only if in edit mode and user can edit)
    const showSettings = metricsEditMode && canEditMetrics();
    const settingsPanel = showSettings ? createGraphSettingsPanel(graphId, config, currentType) : '';
    const settingsToggleBtn = showSettings ? `
        <button class="graph-settings-toggle" onclick="toggleGraphSettings('${graphId}')" title="Graph Settings">
            <i class="fas fa-sliders-h"></i>
        </button>
    ` : '';
    
    // Get hide toggle from options (for custom metrics)
    const hideToggle = options.hideToggle || '';
    const hiddenClass = options.hiddenClass || '';
    
    // Get the icon for the current graph type
    const graphTypeIcons = {
        'bar': 'fa-chart-bar',
        'line': 'fa-chart-line',
        'pie': 'fa-chart-pie'
    };
    const currentTypeIcon = graphTypeIcons[currentType] || 'fa-chart-bar';
    
    return `
        <div class="metrics-card ${showSettings ? 'edit-mode' : ''} ${hiddenClass}" data-graph-id="${graphId}" data-graph-data="${dataJson}" data-graph-data-type="${dataType}">
            <div class="metrics-card-header">
                <h3><i class="fas ${icon}"></i> ${title}</h3>
                <div class="graph-header-actions">
                    ${hideToggle}
                    ${settingsToggleBtn}
                    <div class="graph-menu-container">
                        <button class="graph-menu-btn" onclick="toggleGraphMenu(event, '${graphId}')" aria-label="Change graph type" data-current-type="${currentType}">
                            <i class="fas ${currentTypeIcon}"></i>
                        </button>
                        <div class="graph-menu-dropdown" data-graph-id="${graphId}">
                            <div class="graph-menu-title">Graph Type</div>
                            <button class="graph-menu-option ${currentType === 'bar' ? 'active' : ''}" data-type="bar" onclick="switchGraphType('${graphId}', 'bar')">
                                <i class="fas fa-chart-bar"></i>
                                <span>Bar Graph</span>
                            </button>
                            <button class="graph-menu-option ${currentType === 'line' ? 'active' : ''}" data-type="line" onclick="switchGraphType('${graphId}', 'line')">
                                <i class="fas fa-chart-line"></i>
                                <span>Line Graph</span>
                            </button>
                            <button class="graph-menu-option ${currentType === 'pie' ? 'active' : ''}" data-type="pie" onclick="switchGraphType('${graphId}', 'pie')">
                                <i class="fas fa-chart-pie"></i>
                                <span>Pie Graph</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="metrics-card-body">
                <div class="graph-content" style="transition: opacity 0.15s ease, transform 0.15s ease;">
                    ${graphContent}
                </div>
                ${settingsPanel}
            </div>
        </div>
    `;
}

/**
 * Create the inline graph settings panel
 * Comprehensive configuration: Y-axis, tick density, colors, graph type, data source
 * @param {string} graphId - Unique chart identifier
 * @param {Object} config - Current chart configuration
 * @param {string} currentType - Current chart type
 */
function createGraphSettingsPanel(graphId, config, currentType) {
    const yAxisMin = config.yAxisMin ?? 0;
    const yAxisMax = config.yAxisMax ?? '';
    const yAxisStep = config.yAxisStep ?? '';
    const yAxisMode = config.yAxisMode || 'auto';
    const tickDensity = config.tickDensity || 'normal';
    const primaryColor = config.primaryColor || 'var(--accent)';
    const secondaryColor = config.secondaryColor || '#34C759';
    const palette = config.palette || 'default';
    const sourceType = config.sourceType || 'tasks';
    const metricKey = config.metricKey || '';
    
    // Build color options
    const primaryColorOptions = CHART_COLOR_OPTIONS.map(c => `
        <button class="color-option ${primaryColor === c.value ? 'active' : ''}" 
                style="background: ${c.preview}" 
                onclick="handleChartConfigChange('${graphId}', 'primaryColor', '${c.value}')"
                title="${c.label}">
        </button>
    `).join('');
    
    const secondaryColorOptions = CHART_COLOR_OPTIONS.map(c => `
        <button class="color-option ${secondaryColor === c.value ? 'active' : ''}" 
                style="background: ${c.preview}" 
                onclick="handleChartConfigChange('${graphId}', 'secondaryColor', '${c.value}')"
                title="${c.label}">
        </button>
    `).join('');
    
    // Build tick density options
    const tickDensityOptions = TICK_DENSITY_OPTIONS.map(t => `
        <button class="density-option ${tickDensity === t.id ? 'active' : ''}"
                onclick="handleChartConfigChange('${graphId}', 'tickDensity', '${t.id}')"
                title="${t.label} (${t.ticks} ticks)">
            ${t.label}
        </button>
    `).join('');
    
    // Build pie palette options
    const paletteOptions = PIE_PALETTE_OPTIONS.map(p => `
        <button class="palette-option ${palette === p.id ? 'active' : ''}"
                onclick="handleChartConfigChange('${graphId}', 'palette', '${p.id}')"
                title="${p.label}">
            <span class="palette-preview">
                ${p.colors.slice(0, 4).map(c => `<span class="palette-dot" style="background: ${c}"></span>`).join('')}
            </span>
            <span class="palette-label">${p.label}</span>
        </button>
    `).join('');
    
    // Build graph type options
    const graphTypeOptions = `
        <div class="graph-type-options">
            <button class="graph-type-option ${currentType === 'bar' ? 'active' : ''}"
                    onclick="handleChartConfigChange('${graphId}', 'type', 'bar')"
                    title="Bar Chart">
                <i class="fas fa-chart-bar"></i>
                <span>Bar</span>
            </button>
            <button class="graph-type-option ${currentType === 'line' ? 'active' : ''}"
                    onclick="handleChartConfigChange('${graphId}', 'type', 'line')"
                    title="Line Chart">
                <i class="fas fa-chart-line"></i>
                <span>Line</span>
            </button>
            <button class="graph-type-option ${currentType === 'pie' ? 'active' : ''}"
                    onclick="handleChartConfigChange('${graphId}', 'type', 'pie')"
                    title="Pie Chart">
                <i class="fas fa-chart-pie"></i>
                <span>Pie</span>
            </button>
        </div>
    `;
    
    // Build data source dropdown
    const dataSourceOptions = DATA_SOURCE_OPTIONS.map(s => 
        `<option value="${s.id}" ${(sourceType + '-' + metricKey) === s.id ? 'selected' : ''}>${s.label}</option>`
    ).join('');
    
    // Only show Y-axis settings for line and bar charts
    const showYAxisSettings = currentType === 'line' || currentType === 'bar';
    const showPieSettings = currentType === 'pie';
    
    return `
        <div class="graph-settings-panel" data-settings-chart="${graphId}">
            <div class="graph-settings-header">
                <span class="graph-settings-title">
                    <i class="fas fa-sliders-h"></i>
                    Chart Settings
                </span>
                <button class="graph-settings-close" onclick="closeGraphSettings('${graphId}')">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="graph-settings-content">
                <!-- Graph Type Section -->
                <div class="settings-section">
                    <div class="settings-section-title">Graph Type</div>
                    ${graphTypeOptions}
                </div>
                
                <!-- Y-Axis Section (for line/bar only) -->
                ${showYAxisSettings ? `
                <div class="settings-section">
                    <div class="settings-section-title">
                        Scale
                        <div class="settings-toggle-group">
                            <button class="settings-toggle ${yAxisMode === 'auto' ? 'active' : ''}"
                                    onclick="handleChartConfigChange('${graphId}', 'yAxisMode', 'auto')">
                                Auto
                            </button>
                            <button class="settings-toggle ${yAxisMode === 'custom' ? 'active' : ''}"
                                    onclick="handleChartConfigChange('${graphId}', 'yAxisMode', 'custom')">
                                Custom
                            </button>
                        </div>
                    </div>
                    
                    <div class="settings-row y-axis-inputs ${yAxisMode === 'auto' ? 'disabled' : ''}">
                        <div class="settings-field">
                            <label>Min</label>
                            <input type="number" 
                                   class="settings-input" 
                                   value="${yAxisMin}" 
                                   min="0"
                                   placeholder="0"
                                   ${yAxisMode === 'auto' ? 'disabled' : ''}
                                   onchange="handleChartConfigChange('${graphId}', 'yAxisMin', this.value)">
                        </div>
                        <div class="settings-field">
                            <label>Max</label>
                            <input type="number" 
                                   class="settings-input" 
                                   value="${yAxisMax}" 
                                   placeholder="Auto"
                                   ${yAxisMode === 'auto' ? 'disabled' : ''}
                                   onchange="handleChartConfigChange('${graphId}', 'yAxisMax', this.value)">
                        </div>
                        <div class="settings-field">
                            <label>Step</label>
                            <input type="number" 
                                   class="settings-input" 
                                   value="${yAxisStep}" 
                                   min="1"
                                   placeholder="Auto"
                                   ${yAxisMode === 'auto' ? 'disabled' : ''}
                                   onchange="handleChartConfigChange('${graphId}', 'yAxisStep', this.value)">
                        </div>
                    </div>
                    
                    <div class="settings-subsection">
                        <label class="settings-label-small">Tick Density</label>
                        <div class="density-options">
                            ${tickDensityOptions}
                        </div>
                    </div>
                </div>
                ` : ''}
                
                <!-- Appearance Section -->
                <div class="settings-section">
                    <div class="settings-section-title">Appearance</div>
                    
                    ${!showPieSettings ? `
                    <div class="settings-subsection">
                        <label class="settings-label-small">Primary Color</label>
                        <div class="color-options">
                            ${primaryColorOptions}
                        </div>
                    </div>
                    
                    <div class="settings-subsection">
                        <label class="settings-label-small">Secondary Color</label>
                        <div class="color-options">
                            ${secondaryColorOptions}
                        </div>
                    </div>
                    ` : `
                    <div class="settings-subsection">
                        <label class="settings-label-small">Color Palette</label>
                        <div class="palette-options">
                            ${paletteOptions}
                        </div>
                    </div>
                    `}
                </div>
                
                <!-- Data Source Section -->
                <div class="settings-section">
                    <div class="settings-section-title">Data Source</div>
                    <div class="settings-subsection">
                        <select class="settings-select" onchange="handleDataSourceChange('${graphId}', this.value)">
                            ${dataSourceOptions}
                        </select>
                        <p class="settings-hint">Connect this chart to a different data source. More options coming soon.</p>
                    </div>
                </div>
            </div>
            
            <div class="graph-settings-footer">
                <button class="settings-reset-btn" onclick="resetChartConfig('${graphId}')">
                    <i class="fas fa-undo"></i>
                    Reset to Defaults
                </button>
            </div>
        </div>
    `;
}

/**
 * Handle data source change from the settings dropdown
 * @param {string} graphId - Chart identifier
 * @param {string} sourceId - Selected source ID
 */
function handleDataSourceChange(graphId, sourceId) {
    const source = DATA_SOURCE_OPTIONS.find(s => s.id === sourceId);
    if (source) {
        updateChartConfig(graphId, {
            sourceType: source.sourceType,
            metricKey: source.metricKey
        });
    }
}

// Expose to window
window.handleDataSourceChange = handleDataSourceChange;

/**
 * METRICS RENDERING FUNCTIONS
 * ===========================
 * 
 * TESTING SCENARIOS:
 * ------------------
 * Use these scenarios to verify correct behavior across all role/setting combinations:
 * 
 * 1. OWNER with any visibility setting:
 *    - Nav item visible âœ“
 *    - Personal stats shown âœ“
 *    - Team stats shown âœ“
 *    - Member breakdown visible âœ“
 *    - Settings card visible âœ“
 * 
 * 2. ADMIN with 'owner-only' setting:
 *    - Nav item hidden âœ“
 *    - Cannot access metrics âœ“
 * 
 * 3. ADMIN with 'admin-owner' or 'everyone' setting:
 *    - Nav item visible âœ“
 *    - Personal + Team stats shown âœ“
 *    - Member breakdown visible âœ“
 *    - Settings card hidden âœ“
 * 
 * 4. MEMBER with 'owner-only' or 'admin-owner' setting:
 *    - Nav item hidden âœ“
 *    - Cannot access metrics âœ“
 * 
 * 5. MEMBER with 'members-own' setting:
 *    - Nav item visible âœ“
 *    - Personal stats shown âœ“
 *    - Team section NOT shown (no member names, no team completion rate) âœ“
 *    - Settings card hidden âœ“
 * 
 * 6. MEMBER with 'everyone' setting:
 *    - Nav item visible âœ“
 *    - Personal + Team stats shown âœ“
 *    - Member breakdown visible (can see other members' completion counts) âœ“
 *    - Settings card hidden âœ“
 * 
 * 7. EMPTY STATES:
 *    - New user with no tasks: "No Activity Yet" message âœ“
 *    - User with tasks but none completed: "No Completed Tasks Yet" message âœ“
 *    - Team with no assigned tasks: "No Assigned Tasks Yet" for member breakdown âœ“
 * 
 * 8. TIME FILTER:
 *    - Dropdown changes trend chart period (7/30/14 days) âœ“
 *    - Chart labels adapt (weekday names vs MM/DD format) âœ“
 */

/**
 * Show loading state for metrics (displayed while data is loading)
 */
function renderMetricsLoading() {
    const container = document.getElementById('metricsContent');
    if (!container) return;
    
    container.innerHTML = `
        <div class="metrics-loading">
            <div class="metrics-loading-spinner"></div>
            <div class="metrics-loading-text">Loading metrics...</div>
        </div>
    `;
}

/**
 * Create an empty state message
 * @param {string} icon - FontAwesome icon class
 * @param {string} title - Title text
 * @param {string} description - Description text
 */
function createMetricsEmptyState(icon, title, description) {
    return `
        <div class="metrics-empty-state">
            <div class="metrics-empty-icon">
                <i class="fas ${icon}"></i>
            </div>
            <div class="metrics-empty-title">${title}</div>
            <div class="metrics-empty-desc">${description}</div>
        </div>
    `;
}

/**
 * Create the time filter controls HTML with optional Edit button
 */
function createMetricsTimeFilter() {
    const showEditButton = canEditMetrics();
    const editButtonHTML = showEditButton ? `
        <button class="metrics-edit-btn-header ${metricsEditMode ? 'active' : ''}" onclick="toggleMetricsEditMode()">
            <i class="fas ${metricsEditMode ? 'fa-check' : 'fa-cog'}"></i>
            <span>${metricsEditMode ? 'Done' : 'Edit Metrics'}</span>
        </button>
    ` : '';
    
    // Get display text for current filter
    const filterLabels = {
        '7days': 'Last 7 Days',
        '30days': 'Last 30 Days',
        'all': 'All Time'
    };
    const currentLabel = filterLabels[metricsTimeFilter] || 'Last 7 Days';
    
    return `
        <div class="metrics-controls">
            <div class="metrics-time-filter">
                <span class="metrics-time-filter-label">Time Range:</span>
                <div class="metrics-time-dropdown" id="metricsTimeDropdown">
                    <button class="metrics-time-dropdown-trigger" id="metricsTimeDropdownTrigger">
                        <span class="metrics-time-dropdown-value">${currentLabel}</span>
                        <i class="fas fa-chevron-down metrics-time-dropdown-arrow"></i>
                    </button>
                    <div class="metrics-time-dropdown-menu" id="metricsTimeDropdownMenu">
                        <div class="metrics-time-dropdown-option ${metricsTimeFilter === '7days' ? 'selected' : ''}" data-value="7days">
                            <i class="fas fa-check"></i>
                            <span>Last 7 Days</span>
                        </div>
                        <div class="metrics-time-dropdown-option ${metricsTimeFilter === '30days' ? 'selected' : ''}" data-value="30days">
                            <i class="fas fa-check"></i>
                            <span>Last 30 Days</span>
                        </div>
                        <div class="metrics-time-dropdown-option ${metricsTimeFilter === 'all' ? 'selected' : ''}" data-value="all">
                            <i class="fas fa-check"></i>
                            <span>All Time</span>
                        </div>
                    </div>
                </div>
            </div>
            ${editButtonHTML}
        </div>
    `;
}

/**
 * Initialize the metrics time filter dropdown event handlers
 */
function initMetricsTimeDropdown() {
    const trigger = document.getElementById('metricsTimeDropdownTrigger');
    const menu = document.getElementById('metricsTimeDropdownMenu');
    const dropdown = document.getElementById('metricsTimeDropdown');
    
    if (!trigger || !menu || !dropdown) return;
    
    // Toggle dropdown on trigger click
    trigger.addEventListener('click', (e) => {
        e.stopPropagation();
        dropdown.classList.toggle('open');
    });
    
    // Handle option selection
    menu.querySelectorAll('.metrics-time-dropdown-option').forEach(option => {
        option.addEventListener('click', (e) => {
            e.stopPropagation();
            const value = option.dataset.value;
            
            // Update selection state
            menu.querySelectorAll('.metrics-time-dropdown-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            option.classList.add('selected');
            
            // Update trigger text
            trigger.querySelector('.metrics-time-dropdown-value').textContent = option.querySelector('span').textContent;
            
            // Close dropdown
            dropdown.classList.remove('open');
            
            // Trigger filter change
            handleMetricsTimeFilterChange({ target: { value } });
        });
    });
    
    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
        if (!dropdown.contains(e.target)) {
            dropdown.classList.remove('open');
        }
    });
}

// Expose time filter handler globally
window.handleMetricsTimeFilterChange = handleMetricsTimeFilterChange;

/**
 * Main render function for metrics
 * Supports loading states, empty states, time filtering, and tooltips
 */
function renderMetrics() {
    const container = document.getElementById('metricsContent');
    if (!container) return;
    
    const access = appState.metricsAccess;
    const userId = currentAuthUser?.uid;
    
    // Handle no access
    if (!access?.canAccess || access.mode === 'none') {
        container.innerHTML = `
            <div class="metrics-no-access">
                <div class="metrics-no-access-icon">
                    <i class="fas fa-lock"></i>
                </div>
                <h3>Metrics Not Available</h3>
                <p>You don't have access to metrics. Ask the team owner to enable metrics visibility for your role.</p>
            </div>
        `;
        return;
    }
    
    // Check if data is still loading (no tasks array means data hasn't loaded yet)
    if (!appState.tasks) {
        renderMetricsLoading();
        return;
    }
    
    // Compute metrics
    const personalMetrics = computePersonalMetrics(appState, userId);
    const teamMetrics = access.mode === 'team' ? computeTeamMetrics(appState) : null;
    
    // Get time boundary label for display
    const timeBounds = getMetricsTimeBoundaries();
    
    let html = '';
    
    // Time filter controls
    html += createMetricsTimeFilter();
    
    // === Personal Stats Section ===
    html += `
        <div class="metrics-section-title">
            <i class="fas fa-user"></i> My Performance
        </div>
    `;
    
    // Check if user has any personal tasks
    const hasPersonalTasks = personalMetrics.tasks.total > 0;
    const hasPersonalActivity = hasPersonalTasks || personalMetrics.events.total > 0 || personalMetrics.messages.total > 0;
    
    // Get period label for stats
    const periodLabel = metricsTimeFilter === '7days' ? 'This Week' : 
                       (metricsTimeFilter === '30days' ? 'This Month' : 'All Time');
    
    if (!hasPersonalActivity) {
        // Empty state for personal metrics
        html += createMetricsEmptyState(
            'fa-chart-line',
            'No Activity Yet',
            'Start completing tasks, creating events, or sending messages to see your performance metrics here.'
        );
    } else {
        // Section visibility toggle for personal stats
        const personalStatsHidden = metricsHiddenSections.personalStats;
        const personalStatsToggle = metricsEditMode ? `
            <button class="section-visibility-toggle ${personalStatsHidden ? 'hidden-section' : ''}" 
                    onclick="toggleMetricsSectionVisibility('personalStats')" 
                    title="${personalStatsHidden ? 'Show' : 'Hide'} Stats">
                <i class="fas ${personalStatsHidden ? 'fa-eye-slash' : 'fa-eye'}"></i>
            </button>
        ` : '';
        
        // Top row: Stat cards with tooltips (only show if not hidden)
        if (!personalStatsHidden || metricsEditMode) {
            html += `<div class="metrics-stats-row ${personalStatsHidden ? 'section-hidden' : ''}" data-section="personalStats">`;
            if (metricsEditMode) html += personalStatsToggle;
            
            // Completion rate with progress ring
            html += `
                <div class="metrics-stat-card metrics-stat-card-large" data-tooltip="${personalMetrics.tasks.completed} completed, ${personalMetrics.tasks.open} remaining">
                    <div class="metrics-progress-ring-container">
                        ${createProgressRing(personalMetrics.tasks.completionRate)}
                    </div>
                    <div class="metrics-stat-content">
                        <div class="metrics-stat-label">Task Completion Rate</div>
                        <div class="metrics-stat-subtitle">${personalMetrics.tasks.completed} of ${personalMetrics.tasks.total} tasks</div>
                    </div>
                </div>
            `;
            
            // Time-filtered completed tasks
            const tasksTooltip = `Completed: ${personalMetrics.tasks.completedLast7Days} this week, ${personalMetrics.tasks.completedLast30Days} this month`;
            html += createStatCard(
                'fa-check-circle', 
                personalMetrics.tasks.completedInPeriod, 
                `Completed ${periodLabel}`, 
                `${personalMetrics.tasks.open} open`, 
                'success',
                tasksTooltip
            );
            
            const eventsTooltip = `${personalMetrics.events.total} total events created by you`;
            html += createStatCard(
                'fa-calendar-check', 
                personalMetrics.events.upcoming, 
                'Upcoming Events', 
                `${personalMetrics.events.createdLast30Days} created this month`,
                '',
                eventsTooltip
            );
            
            // Time-filtered messages
            const messagesInPeriod = personalMetrics.messages.inPeriod;
            const messagesAvg = messagesInPeriod > 0 
                ? Math.round(messagesInPeriod / (metricsTimeFilter === '7days' ? 7 : (metricsTimeFilter === '30days' ? 30 : 90)) * 10) / 10 
                : 0;
            const messagesDesc = messagesAvg > 0 ? `~${messagesAvg} per day` : 'Keep chatting!';
            html += createStatCard(
                'fa-comment', 
                messagesInPeriod, 
                `Messages ${periodLabel}`, 
                `${personalMetrics.messages.total} total`,
                '',
                messagesDesc
            );
            
            html += '</div>';
        }
        
        // Personal trend chart visibility toggle
        const personalTrendHidden = metricsHiddenSections.personalTrend;
        
        // Personal trend chart (or empty state if no completed tasks)
        if (personalMetrics.tasks.completed === 0) {
            if (!personalTrendHidden || metricsEditMode) {
                html += createMetricsEmptyState(
                    'fa-tasks',
                    'No Completed Tasks Yet',
                    'Complete your first task to see your progress trend!'
                );
            }
        } else if (!personalTrendHidden || metricsEditMode) {
            // Ensure dailyCompletions has proper structure for chart rendering
            const trendData = personalMetrics.trends.dailyCompletions.map(d => ({
                label: d.label,
                value: d.count,
                count: d.count
            }));
            html += createSwitchableGraphCard(
                'personal-trend',
                `My Task Completions (${timeBounds.label})`,
                'fa-chart-line',
                trendData,
                'trend'
            );
        }
    }
    
    // === Team Stats Section (only in team mode) ===
    if (access.mode === 'team' && teamMetrics) {
        html += `
            <div class="metrics-section-title metrics-section-title-team">
                <i class="fas fa-users"></i> Team Performance
            </div>
        `;
        
        const hasTeamTasks = teamMetrics.tasks.total > 0;
        const hasTeamActivity = hasTeamTasks || teamMetrics.events.total > 0 || teamMetrics.memberCount > 0;
        
        if (!hasTeamActivity) {
            // Empty state for team metrics
            html += createMetricsEmptyState(
                'fa-users',
                'No Team Activity Yet',
                'Create tasks, events, and invite team members to see team performance metrics.'
            );
        } else {
            // Team stats visibility toggle
            const teamStatsHidden = metricsHiddenSections.teamStats;
            html += `
                <div class="metrics-section-header">
                    <button class="section-visibility-toggle ${teamStatsHidden ? 'section-hidden' : ''}" 
                            onclick="toggleMetricsSectionVisibility('teamStats')"
                            title="${teamStatsHidden ? 'Show' : 'Hide'} team stats">
                        <i class="fas fa-${teamStatsHidden ? 'eye-slash' : 'eye'}"></i>
                    </button>
                </div>
            `;
            
            if (!teamStatsHidden) {
                // Team stat cards with tooltips - use time-filtered values
                html += '<div class="metrics-stats-row">';
                
                const teamCompletionTooltip = `${teamMetrics.tasks.completedInPeriod} tasks done ${periodLabel}, ${teamMetrics.tasks.open} open`;
                html += `
                    <div class="metrics-stat-card metrics-stat-card-large" data-tooltip="${teamCompletionTooltip}">
                        <div class="metrics-progress-ring-container">
                            ${createProgressRing(teamMetrics.tasks.completionRate, 60, 5, '#34C759')}
                        </div>
                        <div class="metrics-stat-content">
                            <div class="metrics-stat-label">Team Completion Rate</div>
                            <div class="metrics-stat-subtitle">${teamMetrics.tasks.completedInPeriod} completed ${periodLabel}</div>
                        </div>
                    </div>
                `;
                
                const openTasksTooltip = `${teamMetrics.tasks.open} tasks need attention`;
                html += createStatCard(
                    'fa-tasks', 
                    teamMetrics.tasks.open, 
                    'Open Tasks', 
                    `${teamMetrics.tasks.completedInPeriod} done ${periodLabel}`, 
                    'warning',
                    openTasksTooltip
                );
                
                const eventsInPeriodTooltip = `${teamMetrics.events.inPeriod} events ${periodLabel}`;
                html += createStatCard(
                    'fa-calendar-week', 
                    teamMetrics.events.inPeriod, 
                    `Events ${periodLabel}`, 
                    `${teamMetrics.events.total} total events`,
                    '',
                    eventsInPeriodTooltip
                );
                
                const membersTooltip = `Team has ${teamMetrics.memberCount} ${teamMetrics.memberCount === 1 ? 'member' : 'members'}`;
                html += createStatCard(
                    'fa-users', 
                    teamMetrics.memberCount, 
                    'Team Members', 
                    `${teamMetrics.messages.last7Days} messages this week`,
                    '',
                    membersTooltip
                );
                
                html += '</div>';
            }
            
            // Team charts - side by side layout
            const teamChartsHidden = metricsHiddenSections.teamCharts;
            html += `
                <div class="metrics-section-header">
                    <span class="metrics-section-subheading">Team Charts</span>
                    <button class="section-visibility-toggle ${teamChartsHidden ? 'section-hidden' : ''}" 
                            onclick="toggleMetricsSectionVisibility('teamCharts')"
                            title="${teamChartsHidden ? 'Show' : 'Hide'} team charts">
                        <i class="fas fa-${teamChartsHidden ? 'eye-slash' : 'eye'}"></i>
                    </button>
                </div>
            `;
            
            if (!teamChartsHidden) {
                // Team trend chart (or empty state)
                if (teamMetrics.tasks.completed === 0) {
                    html += createMetricsEmptyState(
                        'fa-chart-bar',
                        'No Completed Tasks Yet',
                        'Team members haven\'t completed any tasks yet. Metrics will appear once tasks are done!'
                    );
                } else {
                    // Side-by-side charts container
                    html += '<div class="metrics-charts-row">';
                    
                    // Ensure proper data structure for trend chart
                    const teamTrendData = teamMetrics.trends.dailyCompletions.map(d => ({
                        label: d.label,
                        value: d.count,
                        count: d.count
                    }));
                    html += createSwitchableGraphCard(
                        'team-trend',
                        `Team Completions (${timeBounds.label})`,
                        'fa-chart-bar',
                        teamTrendData,
                        'trend'
                    );
                    
                    // Member breakdown bar chart (only show if there are members with tasks)
                    const memberData = Object.values(teamMetrics.memberBreakdown)
                        .filter(m => m.total > 0)
                        .sort((a, b) => b.completed - a.completed)
                        .slice(0, 10) // Top 10 members
                        .map((m, index) => ({
                            label: m.name,
                            value: m.completed,
                            count: m.completed,
                            color: undefined
                        }));
                    
                    if (memberData.length > 0) {
                        html += createSwitchableGraphCard(
                            'member-breakdown',
                            'By Member',
                            'fa-trophy',
                            memberData,
                            'breakdown',
                            { colorByMember: true }
                        );
                    } else if (teamMetrics.memberCount > 0) {
                        html += `
                            <div class="metrics-graph-card">
                                <div class="metrics-empty-state-mini">
                                    <i class="fas fa-trophy"></i>
                                    <span>No assigned tasks yet</span>
                                </div>
                            </div>
                        `;
                    }
                    
                    html += '</div>'; // End metrics-charts-row
                }
            }
        }
    }
    
    // === Custom Business Metrics Section ===
    const enabledMetrics = getEnabledCustomMetrics();
    const showCustomSection = enabledMetrics.length > 0 || metricsEditMode;
    
    if (showCustomSection) {
        html += `
            <div class="metrics-section-title metrics-section-title-custom">
                <i class="fas fa-chart-pie"></i> Business Metrics
                ${metricsEditMode ? '<span class="metrics-edit-badge">Editing</span>' : ''}
            </div>
        `;
        
        // Business metrics visibility toggle
        const businessMetricsHidden = metricsHiddenSections.businessMetrics;
        html += `
            <div class="metrics-section-header">
                <button class="section-visibility-toggle ${businessMetricsHidden ? 'section-hidden' : ''}" 
                        onclick="toggleMetricsSectionVisibility('businessMetrics')"
                        title="${businessMetricsHidden ? 'Show' : 'Hide'} business metrics">
                    <i class="fas fa-${businessMetricsHidden ? 'eye-slash' : 'eye'}"></i>
                </button>
            </div>
        `;
        
        if (!businessMetricsHidden && enabledMetrics.length > 0) {
            // Separate metrics by display mode, filtering hidden ones unless in edit mode
            const cardMetrics = enabledMetrics.filter(id => {
                const metric = CUSTOM_METRICS_CATALOG[id];
                const isHidden = isMetricHidden(id);
                if (isHidden && !metricsEditMode) return false;
                return !metric?.hasChart || getMetricDisplayMode(id) === 'card';
            });
            const graphMetrics = enabledMetrics.filter(id => {
                const metric = CUSTOM_METRICS_CATALOG[id];
                const isHidden = isMetricHidden(id);
                if (isHidden && !metricsEditMode) return false;
                return metric?.hasChart && getMetricDisplayMode(id) === 'graph';
            });
            
            // Render card-view metrics
            if (cardMetrics.length > 0) {
                html += '<div class="metrics-stats-row custom-metrics-row">';
                
                cardMetrics.forEach((metricId, index) => {
                    const metric = CUSTOM_METRICS_CATALOG[metricId];
                    if (metric) {
                        html += renderCustomMetricCard(metric, index, cardMetrics.length);
                    }
                });
                
                html += '</div>';
            }
            
            // Render graph-view metrics (side by side)
            if (graphMetrics.length > 0) {
                html += '<div class="metrics-charts-row">';
                
                graphMetrics.forEach(metricId => {
                    const metric = CUSTOM_METRICS_CATALOG[metricId];
                    if (metric && metric.hasChart) {
                        const chartData = metric.chartData();
                        const metricIsHidden = isMetricHidden(metricId);
                        const hiddenClass = metricIsHidden ? 'metric-hidden' : '';
                        
                        // Add hide toggle for graph cards in edit mode
                        const graphHideToggle = metricsEditMode ? `
                            <button class="metric-graph-hide-btn ${metricIsHidden ? 'hidden-state' : ''}" 
                                    onclick="toggleMetricVisibility('${metricId}')" 
                                    title="${metricIsHidden ? 'Show metric' : 'Hide metric'}">
                                <i class="fas fa-${metricIsHidden ? 'eye-slash' : 'eye'}"></i>
                            </button>
                        ` : '';
                        
                        html += createSwitchableGraphCard(
                            `custom-${metric.id || 'metric'}`,
                            `${metric.name}`,
                            metric.icon,
                            chartData,
                            'trend',
                            { hideToggle: graphHideToggle, hiddenClass }
                        );
                    }
                });
                
                html += '</div>';
            }
        } else if (!businessMetricsHidden && metricsEditMode) {
            // Show empty state with add button when in edit mode
            html += `
                <div class="metrics-empty-state custom-metrics-empty">
                    <div class="metrics-empty-icon">
                        <i class="fas fa-plus-circle"></i>
                    </div>
                    <div class="metrics-empty-title">No Custom Metrics Added</div>
                    <div class="metrics-empty-desc">Add business metrics to track customers, revenue, and more.</div>
                </div>
            `;
        }
        
        // Add metric button (only in edit mode)
        if (metricsEditMode) {
            const availableCount = Object.keys(CUSTOM_METRICS_CATALOG).length - enabledMetrics.length;
            if (availableCount > 0) {
                html += `
                    <button class="metrics-add-metric-btn" onclick="openAddMetricModal()">
                        <i class="fas fa-plus"></i>
                        <span>Add Metric (${availableCount} available)</span>
                    </button>
                `;
            }
        }
    }
    
    container.innerHTML = html;
    
    // Initialize custom dropdown after rendering
    initMetricsTimeDropdown();
    
    // Initialize line chart dot tooltips
    initLineChartTooltips(container);
    
    // Initialize pie chart hover effects
    initPieChartHoverEffects(container);
}

/**
 * Initialize line chart dot tooltips
 */
function initLineChartTooltips(container) {
    const charts = container.querySelectorAll('.line-chart-v2');
    
    charts.forEach(chart => {
        const dots = chart.querySelectorAll('.line-dot[data-tooltip]');
        let tooltip = null;
        
        dots.forEach(dot => {
            dot.addEventListener('mouseenter', (e) => {
                const tooltipText = dot.getAttribute('data-tooltip');
                if (!tooltipText) return;
                
                // Create tooltip element if not exists
                if (!tooltip) {
                    tooltip = document.createElement('div');
                    tooltip.className = 'line-chart-tooltip';
                    chart.appendChild(tooltip);
                }
                
                tooltip.textContent = tooltipText;
                
                // Position tooltip above the dot
                const cx = parseFloat(dot.getAttribute('cx'));
                const cy = parseFloat(dot.getAttribute('cy'));
                
                tooltip.style.left = cx + 'px';
                tooltip.style.top = cy + 'px';
                tooltip.classList.add('visible');
            });
            
            dot.addEventListener('mouseleave', () => {
                if (tooltip) {
                    tooltip.classList.remove('visible');
                }
            });
        });
    });
}

/**
 * Initialize pie chart hover interactions
 * Highlights corresponding legend item when a segment is hovered
 */
function initPieChartHoverEffects(container) {
    const pieCharts = container.querySelectorAll('.metrics-pie-chart');
    
    pieCharts.forEach(pieChart => {
        const segments = pieChart.querySelectorAll('.pie-segment');
        const legendItems = pieChart.querySelectorAll('.pie-legend-item');
        
        segments.forEach((segment, index) => {
            segment.addEventListener('mouseenter', () => {
                // Highlight corresponding legend item
                if (legendItems[index]) {
                    legendItems[index].classList.add('highlighted');
                }
            });
            
            segment.addEventListener('mouseleave', () => {
                // Remove highlight from legend item
                if (legendItems[index]) {
                    legendItems[index].classList.remove('highlighted');
                }
            });
        });
        
        // Also allow legend items to highlight segments
        legendItems.forEach((legendItem, index) => {
            legendItem.addEventListener('mouseenter', () => {
                if (segments[index]) {
                    segments[index].style.transform = 'scale(1.08)';
                    segments[index].style.filter = 'brightness(1.15) drop-shadow(0 2px 8px rgba(0, 0, 0, 0.15))';
                    // Dim other segments
                    segments.forEach((seg, i) => {
                        if (i !== index) {
                            seg.style.opacity = '0.5';
                            seg.style.filter = 'brightness(0.9)';
                        }
                    });
                }
                legendItem.classList.add('highlighted');
            });
            
            legendItem.addEventListener('mouseleave', () => {
                if (segments[index]) {
                    segments[index].style.transform = '';
                    segments[index].style.filter = '';
                    // Restore other segments
                    segments.forEach(seg => {
                        seg.style.opacity = '';
                        seg.style.filter = '';
                    });
                }
                legendItem.classList.remove('highlighted');
            });
        });
    });
}

// Make renderMetrics available globally for data listener updates
window.renderMetrics = renderMetrics;

/**
 * Update metrics if the metrics tab is currently active.
 * Call this from data listeners to keep metrics fresh.
 */
function updateMetricsIfActive() {
    if (appState.currentSection === 'metrics' && appState.metricsAccess?.canAccess) {
        renderMetrics();
    }
}

// ===================================
// NOTIFICATIONS SYSTEM
// ===================================

// Parse activity description to extract context for preference filtering
function parseActivityContext(activity) {
    const description = (activity.description || '').toLowerCase();
    const context = {};
    
    if (activity.type === 'task') {
        // Check for assignment-related keywords
        if (description.includes('assigned') || description.includes('assign')) {
            context.isAssignment = true;
        }
        // Check for completion-related keywords
        if (description.includes('completed') || description.includes('done') || description.includes('finished')) {
            context.isCompletion = true;
        }
    } else if (activity.type === 'message') {
        // Check for mention-related keywords
        if (description.includes('@') || description.includes('mentioned')) {
            context.isMention = true;
        }
        // Check for reply-related keywords
        if (description.includes('replied') || description.includes('reply')) {
            context.isReply = true;
        }
    } else if (activity.type === 'team') {
        // Check for new member keywords
        if (description.includes('joined') || description.includes('added') || description.includes('welcomed')) {
            context.isNewMember = true;
        }
        // Check for settings change keywords
        if (description.includes('settings') || description.includes('promoted') || 
            description.includes('demoted') || description.includes('role') ||
            description.includes('updated') || description.includes('changed')) {
            context.isSettingsChange = true;
        }
    }
    
    return context;
}

// Filter notifications based on user preferences
function filterNotificationsByPreferences(notifications) {
    return notifications.filter(notification => {
        const context = parseActivityContext(notification);
        return shouldShowNotification(notification.type, context);
    });
}

async function updateNotifications(activities) {
    if (!currentAuthUser) return;
    
    // Filter out activities from the current user (don't notify yourself) and only show recent (last 24 hours)
    const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
    let notifications = activities.filter(activity => {
        // Exclude self-triggered activities
        return activity.createdBy !== currentAuthUser.uid && 
               activity.timestamp > oneDayAgo;
    });
    
    // Apply user preference filtering
    notifications = filterNotificationsByPreferences(notifications);
    
    // Get unread notifications from Firestore
    const readNotifications = await getReadNotificationsFromFirestore();
    const unreadNotifications = notifications.filter(n => !readNotifications.includes(n.id));
    
    // Update badge
    const badge = document.getElementById('notificationBadge');
    if (badge) {
        if (unreadNotifications.length > 0) {
            badge.textContent = unreadNotifications.length > 9 ? '9+' : unreadNotifications.length;
            badge.style.display = 'block';
        } else {
            badge.style.display = 'none';
        }
    }
    
    // Display notifications in popup (compact, limited items)
    displayNotifications(notifications, readNotifications, currentNotificationFilter);
    
    // Display notifications in Overview inbox (full list)
    displayOverviewNotifications(notifications, readNotifications);
}

function displayNotifications(notifications, readNotifications, filterMode = 'unread') {
    const notificationsList = document.getElementById('notificationsList');
    if (!notificationsList) return;
    
    // Filter based on mode
    let filteredNotifications = notifications;
    if (filterMode === 'unread') {
        filteredNotifications = notifications.filter(n => !readNotifications.includes(n.id));
    }
    
    if (filteredNotifications.length === 0) {
        const message = filterMode === 'unread' ? 'No unread notifications' : 'No notifications';
        notificationsList.innerHTML = `<div class="no-notifications">${message}</div>`;
        return;
    }
    
    notificationsList.innerHTML = '';
    
    // Limit to 6 items max in popup for compact view
    const popupNotifications = filteredNotifications.slice(0, 6);
    
    popupNotifications.forEach(notification => {
        const isRead = readNotifications.includes(notification.id);
        const iconClass = notification.type === 'task' ? 'task-icon' : 
                         notification.type === 'message' ? 'message-icon' : 
                         notification.type === 'team' ? 'team-icon' : 'calendar-icon';
        const icon = notification.type === 'task' ? 'fa-check-circle' : 
                    notification.type === 'message' ? 'fa-comment' : 
                    notification.type === 'team' ? 'fa-user-plus' : 'fa-calendar';
        
        // Use unified identity resolver for consistent display
        const identity = getIdentity(notification.createdBy, notification.userName);
        const displayName = identity.displayName;
        
        // Short description for compact popup
        const shortDesc = notification.description.length > 40 
            ? notification.description.substring(0, 40) + '...' 
            : notification.description;
        
        const notificationEl = document.createElement('div');
        notificationEl.className = `notification-item ${!isRead ? 'unread' : ''}`;
        notificationEl.style.cursor = 'pointer';
        notificationEl.innerHTML = `
            <div class="notification-icon ${iconClass}">
                <i class="fas ${icon}"></i>
            </div>
            <div class="notification-content">
                <div class="notification-text">
                    <strong>${escapeHtml(displayName)}</strong> ${escapeHtml(shortDesc)}
                </div>
                <div class="notification-time">${notification.timeAgo}</div>
            </div>
        `;
        
        notificationEl.addEventListener('click', () => {
            markNotificationAsRead(notification.id);
            navigateToNotificationSource(notification);
            // Close notifications dropdown
            const dropdown = document.getElementById('notificationsDropdown');
            if (dropdown) {
                dropdown.classList.remove('active');
            }
        });
        
        notificationsList.appendChild(notificationEl);
    });
}

// Display notifications in Overview section (full inbox-style list)
function displayOverviewNotifications(notifications, readNotifications) {
    const overviewList = document.getElementById('overviewNotificationsList');
    if (!overviewList) return;
    
    if (notifications.length === 0) {
        overviewList.innerHTML = '<div class="no-notifications-overview">No notifications</div>';
        return;
    }
    
    overviewList.innerHTML = '';
    
    // Show up to 30 notifications in overview inbox
    const overviewNotifications = notifications.slice(0, 30);
    
    overviewNotifications.forEach(notification => {
        const isRead = readNotifications.includes(notification.id);
        const iconClass = notification.type === 'task' ? 'task-icon' : 
                         notification.type === 'message' ? 'message-icon' : 
                         notification.type === 'team' ? 'team-icon' : 'calendar-icon';
        const icon = notification.type === 'task' ? 'fa-check-circle' : 
                    notification.type === 'message' ? 'fa-comment' : 
                    notification.type === 'team' ? 'fa-user-plus' : 'fa-calendar';
        
        // Use unified identity resolver for consistent display
        const identity = getIdentity(notification.createdBy, notification.userName);
        const displayName = identity.displayName;
        
        const rowEl = document.createElement('div');
        rowEl.className = `overview-notification-row ${!isRead ? 'unread' : ''}`;
        rowEl.innerHTML = `
            <div class="overview-notification-icon ${iconClass}">
                <i class="fas ${icon}"></i>
            </div>
            <div class="overview-notification-content">
                <div class="overview-notification-text">
                    <strong>${escapeHtml(displayName)}</strong> ${escapeHtml(notification.description)}
                </div>
                <div class="overview-notification-time">${notification.timeAgo}</div>
            </div>
        `;
        
        rowEl.addEventListener('click', () => {
            markNotificationAsRead(notification.id);
            navigateToNotificationSource(notification);
        });
        
        overviewList.appendChild(rowEl);
    });
}

window.markAllNotificationsRead = async function() {
    if (!appState.activities) return;
    
    const notificationIds = appState.activities
        .filter(a => a.userId !== currentAuthUser.uid)
        .map(a => a.id);
    
    await saveReadNotificationsToFirestore(notificationIds);
    
    // Update display
    const badge = document.getElementById('notificationBadge');
    if (badge) {
        badge.style.display = 'none';
    }
    
    // Get filtered notifications for refresh
    const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
    let notifications = appState.activities.filter(a => 
        a.createdBy !== currentAuthUser.uid && a.timestamp > oneDayAgo
    );
    notifications = filterNotificationsByPreferences(notifications);
    
    // Refresh both popup and overview notifications display
    displayNotifications(notifications, notificationIds, currentNotificationFilter);
    displayOverviewNotifications(notifications, notificationIds);
}

async function markNotificationAsRead(notificationId) {
    const readNotifications = await getReadNotificationsFromFirestore();
    if (!readNotifications.includes(notificationId)) {
        readNotifications.push(notificationId);
        await saveReadNotificationsToFirestore(readNotifications);
        
        // Update badge
        const badge = document.getElementById('notificationBadge');
        if (badge) {
            const currentCount = parseInt(badge.textContent) || 0;
            const newCount = Math.max(0, currentCount - 1);
            if (newCount > 0) {
                badge.textContent = newCount > 9 ? '9+' : newCount;
            } else {
                badge.style.display = 'none';
            }
        }
        
        // Refresh display for both popup and overview
        const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
        let notifications = appState.activities.filter(a => 
            a.createdBy !== currentAuthUser.uid && a.timestamp > oneDayAgo
        );
        notifications = filterNotificationsByPreferences(notifications);
        displayNotifications(notifications, readNotifications, currentNotificationFilter);
        displayOverviewNotifications(notifications, readNotifications);
    }
}

async function markAllUnreadNotificationsAsRead() {
    const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
    let notifications = appState.activities.filter(a => 
        a.createdBy !== currentAuthUser.uid && a.timestamp > oneDayAgo
    );
    notifications = filterNotificationsByPreferences(notifications);
    
    const readNotifications = await getReadNotificationsFromFirestore();
    let marked = false;
    
    notifications.forEach(notification => {
        if (!readNotifications.includes(notification.id)) {
            readNotifications.push(notification.id);
            marked = true;
        }
    });
    
    if (marked) {
        await saveReadNotificationsToFirestore(readNotifications);
        
        // Hide badge
        const badge = document.getElementById('notificationBadge');
        if (badge) {
            badge.style.display = 'none';
        }
        
        // Refresh both displays
        displayNotifications(notifications, readNotifications, currentNotificationFilter);
        displayOverviewNotifications(notifications, readNotifications);
    }
}

// ===================================
// FIRESTORE NOTIFICATION HELPERS
// ===================================

async function getReadNotificationsFromFirestore() {
    if (!db || !currentAuthUser) return [];
    
    try {
        const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const userRef = doc(db, 'users', currentAuthUser.uid);
        const userSnap = await getDoc(userRef);
        
        if (userSnap.exists()) {
            return userSnap.data().readNotifications || [];
        }
        
        return [];
    } catch (error) {
        console.error('Error loading read notifications:', error);
        return [];
    }
}

async function saveReadNotificationsToFirestore(readNotifications) {
    if (!db || !currentAuthUser) return;
    
    try {
        const { doc, setDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const userRef = doc(db, 'users', currentAuthUser.uid);
        
        // Update only the readNotifications field
        await setDoc(userRef, {
            readNotifications: readNotifications
        }, { merge: true });
        
        debugLog('âœ… Read notifications saved to Firestore');
    } catch (error) {
        console.error('Error saving read notifications:', error);
    }
}

function navigateToNotificationSource(notification) {
    // Map notification types to sections
    const sectionMap = {
        'task': 'tasks',
        'message': 'chat',
        'calendar': 'calendar',
        'team': 'team'
    };
    
    const targetSection = sectionMap[notification.type] || 'activity';
    
    // Get all nav items and sections
    const navItems = document.querySelectorAll('.nav-item');
    const sections = document.querySelectorAll('.content-section');
    
    // Update active nav item
    navItems.forEach(nav => {
        nav.classList.remove('active');
        if (nav.dataset.section === targetSection) {
            nav.classList.add('active');
        }
    });
    
    // Update active section
    sections.forEach(section => {
        section.classList.remove('active');
        if (section.id === `${targetSection}-section`) {
            section.classList.add('active');
        }
    });
    
    // Update app state
    appState.currentSection = targetSection;
    
    // Scroll to top of the section
    const targetSectionEl = document.getElementById(`${targetSection}-section`);
    if (targetSectionEl) {
        targetSectionEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
}

// Toggle notification filter
let currentNotificationFilter = 'unread';

window.toggleNotificationFilter = function(filter) {
    currentNotificationFilter = filter;
    
    // Update button states
    const unreadBtn = document.getElementById('showUnreadBtn');
    const allBtn = document.getElementById('showAllBtn');
    
    if (unreadBtn && allBtn) {
        if (filter === 'unread') {
            unreadBtn.classList.add('active');
            allBtn.classList.remove('active');
        } else {
            unreadBtn.classList.remove('active');
            allBtn.classList.add('active');
        }
    }
    
    // Re-display notifications with the new filter
    if (!currentAuthUser) return;
    
    const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
    const notifications = appState.activities.filter(activity => {
        return activity.userId !== currentAuthUser.uid && 
               activity.timestamp > oneDayAgo;
    });
    
    const readNotifications = JSON.parse(localStorage.getItem('readNotifications') || '[]');
    displayNotifications(notifications, readNotifications, filter);
}

// Refresh "time ago" text periodically (every minute)
function startActivityRefreshTimer() {
    setInterval(() => {
        if (appState.activities && appState.activities.length > 0) {
            // Update time ago for each activity
            appState.activities.forEach(activity => {
                activity.timeAgo = getTimeAgo(activity.timestamp);
            });
            
            // Refresh displays
            displayActivities();
            
            // Update notifications
            const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
            const notifications = appState.activities.filter(a => 
                a.userId !== currentAuthUser?.uid && a.timestamp > oneDayAgo
            );
            const readNotifications = JSON.parse(localStorage.getItem('readNotifications') || '[]');
            displayNotifications(notifications, readNotifications, currentNotificationFilter);
        }
    }, 60000); // Update every minute
}

// ===================================
// MODAL MANAGEMENT
// ===================================
// MODAL MANAGEMENT
// ===================================
function initModals() {
    // Notifications Dropdown
    const notificationsBtn = document.getElementById('notificationsBtn');
    const notificationsDropdown = document.getElementById('notificationsDropdown');
    
    if (notificationsBtn && notificationsDropdown) {
        // Toggle function for notifications dropdown
        const toggleNotificationsDropdown = (e) => {
            e.preventDefault();
            e.stopPropagation();
            const isVisible = notificationsDropdown.style.display === 'block';
            
            // Toggle dropdown visibility
            notificationsDropdown.style.display = isVisible ? 'none' : 'block';
            
            // Close settings dropdown if open
            if (document.getElementById('settingsDropdown')) {
                document.getElementById('settingsDropdown').style.display = 'none';
            }
        };
        
        // Add both click and touchend for mobile compatibility
        notificationsBtn.addEventListener('click', toggleNotificationsDropdown);
        notificationsBtn.addEventListener('touchend', toggleNotificationsDropdown);
        
        // Prevent dropdown from closing when clicking/touching inside it
        notificationsDropdown.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        notificationsDropdown.addEventListener('touchend', (e) => {
            e.stopPropagation();
        });
    }
    
    // Settings Dropdown in Top Bar
    const topBarSettingsBtn = document.getElementById('topBarSettingsBtn');
    const settingsDropdown = document.getElementById('settingsDropdown');
    
    if (topBarSettingsBtn && settingsDropdown) {
        // Toggle function for settings dropdown
        const toggleSettingsDropdown = (e) => {
            e.preventDefault();
            e.stopPropagation();
            const isVisible = settingsDropdown.style.display === 'block';
            settingsDropdown.style.display = isVisible ? 'none' : 'block';
            
            // Close notifications dropdown if open
            if (notificationsDropdown) {
                notificationsDropdown.style.display = 'none';
            }
        };
        
        // Add both click and touchend for mobile compatibility
        topBarSettingsBtn.addEventListener('click', toggleSettingsDropdown);
        topBarSettingsBtn.addEventListener('touchend', toggleSettingsDropdown);
        
        // Close dropdown when clicking/touching outside
        document.addEventListener('click', () => {
            settingsDropdown.style.display = 'none';
            if (notificationsDropdown) {
                notificationsDropdown.style.display = 'none';
            }
        });
        document.addEventListener('touchend', (e) => {
            // Only close if not touching the settings or notifications buttons
            if (!topBarSettingsBtn.contains(e.target) && !settingsDropdown.contains(e.target) &&
                (!notificationsBtn || !notificationsBtn.contains(e.target)) &&
                (!notificationsDropdown || !notificationsDropdown.contains(e.target))) {
                settingsDropdown.style.display = 'none';
                if (notificationsDropdown) {
                    notificationsDropdown.style.display = 'none';
                }
            }
        });
        
        // Prevent dropdown from closing when clicking/touching inside it
        settingsDropdown.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        settingsDropdown.addEventListener('touchend', (e) => {
            e.stopPropagation();
        });
    }
    
    // Event Modal
    const eventModal = document.getElementById('eventModal');
    const eventForm = document.getElementById('eventForm');
    const closeEventModal = document.getElementById('closeEventModal');
    const cancelEventBtn = document.getElementById('cancelEventBtn');
    
    // Helper to reset event modal to initial state
    function resetEventModal() {
        eventForm.reset();
        delete eventForm.dataset.editingEventId;
        const titleEl = document.querySelector('#eventModal .unified-modal-title h2');
        const submitBtn = document.querySelector('#eventModal .unified-btn-primary');
        if (titleEl) titleEl.innerHTML = '<i class="fas fa-calendar-plus"></i> New Event';
        if (submitBtn) submitBtn.innerHTML = '<i class="fas fa-check"></i> Add Event';
        // Reset textarea height
        const descTextarea = document.getElementById('eventDescription');
        if (descTextarea) {
            descTextarea.style.height = 'auto';
            descTextarea.style.overflowY = 'hidden';
        }
        closeModal('eventModal');
    }

    closeEventModal.addEventListener('click', resetEventModal);
    cancelEventBtn.addEventListener('click', resetEventModal);
    
    // Auto-expanding textarea for event description
    const eventDescriptionTextarea = document.getElementById('eventDescription');
    if (eventDescriptionTextarea) {
        function autoExpandTextarea() {
            // Reset height to auto to get the correct scrollHeight
            eventDescriptionTextarea.style.height = 'auto';
            // Set to scrollHeight but respect max-height from CSS
            const maxHeight = 200;
            const newHeight = Math.min(eventDescriptionTextarea.scrollHeight, maxHeight);
            eventDescriptionTextarea.style.height = newHeight + 'px';
            // Show scrollbar if content exceeds max height
            eventDescriptionTextarea.style.overflowY = eventDescriptionTextarea.scrollHeight > maxHeight ? 'auto' : 'hidden';
        }
        
        eventDescriptionTextarea.addEventListener('input', autoExpandTextarea);
        eventDescriptionTextarea.addEventListener('focus', autoExpandTextarea);
    }
    
    // Real-time duration calculation and validation for 24-hour format
    const startHourInput = document.getElementById('eventHour');
    const startMinuteInput = document.getElementById('eventMinute');
    const endHourInput = document.getElementById('eventEndHour');
    const endMinuteInput = document.getElementById('eventEndMinute');
    const durationDisplay = document.getElementById('eventDuration');
    const durationText = document.getElementById('durationText');
    const eventColorInput = document.getElementById('eventColor');
    
    // Initialize custom time pickers
    initializeTimePicker('startTimeWrapper', 'eventHour', 'eventMinute', 'startHourOptions', 'startMinuteOptions');
    initializeTimePicker('endTimeWrapper', 'eventEndHour', 'eventEndMinute', 'endHourOptions', 'endMinuteOptions');
    
    // Event color option buttons - updated for unified color picker
    const eventColorOptions = document.querySelectorAll('#eventModal .unified-color-option');
    eventColorOptions.forEach(option => {
        option.addEventListener('click', () => {
            const color = option.getAttribute('data-color');
            eventColorInput.value = color;
            
            // Update selected state
            eventColorOptions.forEach(o => o.classList.remove('selected'));
            option.classList.add('selected');
        });
    });
    
    // Event visibility toggle (calendar-style)
    const visibilityToggles = document.querySelectorAll('#eventModal .visibility-toggle');
    initVisibilityToggles(visibilityToggles);
    
    // Event repeat option buttons (support both old .repeat-chip and new .repeat-pill)
    const repeatOptions = document.querySelectorAll('#eventModal .repeat-chip, #eventModal .repeat-pill');
    
    function updateRepeatHelper() {
        // Removed the helper text display since we simplified the UI
    }
    
    repeatOptions.forEach(option => {
        option.addEventListener('click', () => {
            // Update selected state
            repeatOptions.forEach(o => o.classList.remove('selected'));
            option.classList.add('selected');
            
            // Check the corresponding radio
            const radio = option.querySelector('input[type="radio"]');
            if (radio) radio.checked = true;
        });
    });
    
    // Helper function to convert to total minutes from midnight
    function toMinutes(hour, minute) {
        const h = parseInt(hour);
        const m = parseInt(minute);
        
        if (isNaN(h) || isNaN(m)) return null;
        
        // Ensure hour is in range 0-23
        if (h < 0 || h > 23) return null;
        
        return h * 60 + m;
    }
    
    function updateDuration() {
        const startMinutes = toMinutes(startHourInput.value, startMinuteInput.value);
        const endMinutes = toMinutes(endHourInput.value, endMinuteInput.value);
        
        if (startMinutes !== null && endMinutes !== null) {
            let diffMinutes = endMinutes - startMinutes;
            
            // Handle case where end time is next day
            if (diffMinutes < 0) {
                diffMinutes += 24 * 60;
            }
            
            durationDisplay.style.display = 'flex';
            
            if (diffMinutes === 0) {
                durationDisplay.classList.add('error');
                durationText.textContent = 'End time must be different from start time';
            } else {
                durationDisplay.classList.remove('error');
                
                const hours = Math.floor(diffMinutes / 60);
                const minutes = diffMinutes % 60;
                
                if (hours > 0) {
                    durationText.textContent = `${hours} hour${hours > 1 ? 's' : ''} ${minutes > 0 ? minutes + ' min' : ''}`;
                } else {
                    durationText.textContent = `${minutes} minute${minutes > 1 ? 's' : ''}`;
                }
            }
        } else {
            durationDisplay.style.display = 'none';
        }
    }
    
    startHourInput.addEventListener('input', updateDuration);
    startMinuteInput.addEventListener('input', updateDuration);
    endHourInput.addEventListener('input', updateDuration);
    endMinuteInput.addEventListener('input', updateDuration);
    
    // Auto-format and validate time inputs for 24-hour format
    function validateTimeInput(input, min, max) {
        let value = parseInt(input.value);
        if (isNaN(value) || value < min) {
            input.value = '';
        } else if (value > max) {
            input.value = max;
        }
        // Pad with leading zero
        if (input.value && input.value.length === 1) {
            input.value = '0' + input.value;
        }
    }
    
    startHourInput.addEventListener('blur', () => validateTimeInput(startHourInput, 0, 23));
    startMinuteInput.addEventListener('blur', () => validateTimeInput(startMinuteInput, 0, 59));
    endHourInput.addEventListener('blur', () => validateTimeInput(endHourInput, 0, 23));
    endMinuteInput.addEventListener('blur', () => validateTimeInput(endMinuteInput, 0, 59));

    eventForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        console.log('Event form submitted');
        
        const dateStr = document.getElementById('eventDate').value;
        
        // Use 24-hour format directly
        const startHour = parseInt(startHourInput.value);
        const startMinute = parseInt(startMinuteInput.value) || 0;
        const endHour = parseInt(endHourInput.value);
        const endMinute = parseInt(endMinuteInput.value) || 0;
        
        const startTimeStr = `${String(startHour).padStart(2, '0')}:${String(startMinute).padStart(2, '0')}`;
        const endTimeStr = `${String(endHour).padStart(2, '0')}:${String(endMinute).padStart(2, '0')}`;
        
        // Get visibility setting
        const visibility = getActiveVisibilityValue('eventVisibility');
        
        // Get repeat setting
        const repeatRadio = document.querySelector('input[name="eventRepeat"]:checked');
        const repeat = repeatRadio ? repeatRadio.value : 'none';
        
        if (DEBUG) console.log('Form values:', { dateStr, startTimeStr, endTimeStr, visibility, repeat });
        
        // Create full datetime objects
        const startDate = new Date(dateStr + 'T' + startTimeStr);
        const endDate = new Date(dateStr + 'T' + endTimeStr);
        
        // Handle case where end time is before start time (assume next day)
        if (endDate <= startDate) {
            endDate.setDate(endDate.getDate() + 1);
        }
        
        // Check if we're editing or creating
        const editingEventId = eventForm.dataset.editingEventId;
        const isEditing = !!editingEventId;
        
        const event = {
            id: isEditing ? editingEventId : Date.now().toString(),
            title: document.getElementById('eventTitle').value,
            date: startDate,
            endDate: endDate,
            time: startTimeStr,
            endTime: endTimeStr,
            description: document.getElementById('eventDescription').value,
            color: eventColorInput.value,
            visibility: visibility,
            repeat: repeat,
            repeatStart: repeat !== 'none' ? startDate : null,
            teamId: appState.currentTeamId
        };
        
        console.log('ðŸ“… Event being saved:', {
            repeat: event.repeat,
            repeatStart: event.repeatStart,
            date: event.date
        });

        if (DEBUG) console.log(`${isEditing ? 'Updating' : 'Creating'} event:`, event);

        try {
            if (isEditing) {
                // Update existing event
                await updateEventInFirestore(event);
                
                // Add to activity feed
                addActivity({
                    type: 'calendar',
                    description: `updated event "${event.title}"`
                });
                
                debugLog('âœ… Event updated successfully');
            } else {
                // Create new event
                await saveEventToFirestore(event);
                
                // Add to activity feed
                addActivity({
                    type: 'calendar',
                    description: `created event "${event.title}"`
                });
                
                debugLog('âœ… Event created successfully');
            }
            
            // Reset form and modal state
            eventForm.reset();
            delete eventForm.dataset.editingEventId;
            const titleEl = document.querySelector('#eventModal .unified-modal-title h2');
            const submitBtn = document.querySelector('#eventModal .unified-btn-primary');
            if (titleEl) titleEl.innerHTML = '<i class="fas fa-calendar-plus"></i> New Event';
            if (submitBtn) submitBtn.innerHTML = '<i class="fas fa-check"></i> Add Event';
            
            // Reset visibility and repeat to default
            resetEventVisibility();
            resetEventRepeat();
            
            closeModal('eventModal');
        } catch (error) {
            console.error('Error in event submission:', error);
            showToast(`Error ${isEditing ? 'updating' : 'creating'} event: ` + error.message, 'error', 5000, 'Event Error');
        }
    });

    // Task Modal
    const taskModal = document.getElementById('taskModal');
    // Teammate Modal
    const teammateForm = document.getElementById('teammateForm');
    const closeTeammateModal = document.getElementById('closeTeammateModal');
    const cancelTeammateBtn = document.getElementById('cancelTeammateBtn');

    if (closeTeammateModal) closeTeammateModal.addEventListener('click', () => closeModal('teammateModal'));
    if (cancelTeammateBtn) cancelTeammateBtn.addEventListener('click', () => closeModal('teammateModal'));

    if (teammateForm) {
        teammateForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const invitedEmail = document.getElementById('teammateEmail').value.trim();
            const invitedName = document.getElementById('teammateName').value.trim();
            const occupation = document.getElementById('teammateOccupation').value.trim();

            if (!invitedEmail) {
                showToast('Please enter an email address', 'error', 4000, 'Validation Error');
                return;
            }

            try {
                // This will check rate limits and create the invitation
                await sendTeamInvitation(invitedEmail, invitedName, occupation);
                
                // Form will be cleared and modal closed by showInviteLink
                teammateForm.reset();
                
            } catch (error) {
                console.error('Error sending invitation:', error);
                // Show user-friendly error message
                showToast(error.message || 'Failed to send invitation. Please try again.', 'error', 6000, 'Invitation Failed');
            }
        });
    }

    const taskForm = document.getElementById('taskForm');
    const closeTaskModal = document.getElementById('closeTaskModal');
    const cancelTaskBtn = document.getElementById('cancelTaskBtn');
    const taskDueDateInput = document.getElementById('taskDueDate');
    const dueDateHelper = document.getElementById('dueDateHelper');
    const taskShowOnCalendar = document.getElementById('taskShowOnCalendar');

    const resetTaskModalProgress = () => {
        const progressInput = document.getElementById('taskProgress');
        const progressSlider = document.getElementById('taskProgressSlider');
        const progressFill = document.getElementById('taskProgressFill');
        const progressBadge = document.getElementById('taskProgressBadge');

        if (progressInput) progressInput.value = 0;
        if (progressSlider) {
            progressSlider.value = 0;
            progressSlider.style.setProperty('--progress', '0%');
        }
        if (progressFill) progressFill.style.width = '0%';
        if (progressBadge) progressBadge.textContent = '0%';
        if (taskShowOnCalendar) taskShowOnCalendar.checked = true;
    };

    // Show helper text when due date is selected
    if (taskDueDateInput && dueDateHelper) {
        taskDueDateInput.addEventListener('change', () => {
            if (taskDueDateInput.value) {
                dueDateHelper.style.display = 'block';
            } else {
                dueDateHelper.style.display = 'none';
            }
        });
    }

    closeTaskModal.addEventListener('click', () => {
        taskForm.reset();
        resetTaskModalProgress();
        if (dueDateHelper) dueDateHelper.style.display = 'none';
        closeModal('taskModal');
    });
    
    cancelTaskBtn.addEventListener('click', () => {
        taskForm.reset();
        resetTaskModalProgress();
        if (dueDateHelper) dueDateHelper.style.display = 'none';
        closeModal('taskModal');
    });

    // ===================================
    // CUSTOM DROPDOWN INITIALIZATION
    // Initialize the Apple-like dropdowns for task modal
    // ===================================
    initTaskModalDropdowns();
    initTaskTitleWordLimit();
    initTaskModalProgressSlider();

    taskForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const assigneeId = document.getElementById('taskAssignee').value;
        const editingTaskId = taskForm.dataset.editingTaskId;
        const isEditing = !!editingTaskId;
        
        // Rate limiting for new task creation (not edits)
        if (!isEditing) {
            const rateCheck = canCreateTask();
            if (!rateCheck.allowed) {
                showToast(rateCheck.reason, 'warning');
                return;
            }
            rateLimitState.isCreatingTask = true;
        }
        
        // Validate assignee is a team member or "team" (for unassigned/team tasks)
        if (!assigneeId) {
            rateLimitState.isCreatingTask = false;
            showToast('Please select a team member to assign this task to.', 'error');
            return;
        }
        
        // Handle special "team" value - task is assigned to the whole team
        let assigneeName;
        if (assigneeId === 'team') {
            assigneeName = 'Team';
        } else {
            // Get assignee name using unified identity resolver
            const assigneeIdentity = getIdentity(assigneeId, null);
            if (assigneeIdentity.displayName === 'Unknown') {
                rateLimitState.isCreatingTask = false;
                showToast('Invalid assignee. Please select a valid team member.', 'error');
                return;
            }
            assigneeName = assigneeIdentity.displayName;
        }
        
        // Get due date if provided
        const dueDateInput = document.getElementById('taskDueDate').value;
        let dueDate = null;
        if (dueDateInput) {
            dueDate = new Date(dueDateInput).getTime();
        }

        // Get new fields
        const budgetInput = document.getElementById('taskBudget');
        const estimatedTimeInput = document.getElementById('taskEstimatedTime');
        const progressSlider = document.getElementById('taskProgress');
        const spreadsheetSelect = document.getElementById('taskSpreadsheet');
        const showOnCalendarCheckbox = document.getElementById('taskShowOnCalendar');
        const recurrenceInput = document.getElementById('taskRecurrence');
        
        // Validate title - 20 word limit
        let taskTitle = document.getElementById('taskTitle').value.trim();
        const wordCount = taskTitle.split(/\s+/).filter(word => word.length > 0).length;
        if (wordCount > 20) {
            // Truncate to 20 words
            taskTitle = taskTitle.split(/\s+/).slice(0, 20).join(' ');
            showToast('Task title limited to 20 words', 'warning');
        }
        
        // RECURRING TASKS: Get recurrence setting
        const recurrence = recurrenceInput ? recurrenceInput.value : 'none';
        const isRecurring = recurrence && recurrence !== 'none';
        
        const task = {
            title: taskTitle,
            description: document.getElementById('taskDescription').value,
            assigneeId: assigneeId,  // Store user ID
            assignee: assigneeName,   // Store name for display
            priority: document.getElementById('taskPriority').value,
            status: document.getElementById('taskStatus').value || 'todo',
            dueDate: dueDate,  // Store due date timestamp (null if not set)
            budget: budgetInput ? parseFloat(budgetInput.value) || null : null,
            estimatedTime: estimatedTimeInput ? parseFloat(estimatedTimeInput.value) || null : null,
            progress: progressSlider ? parseInt(progressSlider.value) || 0 : 0,
            spreadsheetId: spreadsheetSelect ? spreadsheetSelect.value : 'default',
            showOnCalendar: showOnCalendarCheckbox ? showOnCalendarCheckbox.checked : true,
            // RECURRING TASKS: Store recurrence settings
            isRecurring: isRecurring,
            recurrence: isRecurring ? {
                frequency: recurrence,  // 'daily', 'weekly', 'monthly'
                interval: 1,            // Every 1 day/week/month
                nextDueAt: dueDate ? calculateNextDueDate(new Date(dueDate), recurrence).getTime() : null
            } : null,
            createdBy: currentAuthUser ? currentAuthUser.uid : null,
            createdAt: Date.now()
        };

        if (isEditing) {
            // Update existing task
            const existingTaskIndex = appState.tasks.findIndex(t => String(t.id) === String(editingTaskId));
            if (existingTaskIndex !== -1) {
                task.id = editingTaskId;
                task.createdAt = appState.tasks[existingTaskIndex].createdAt;
                task.createdBy = appState.tasks[existingTaskIndex].createdBy;
                appState.tasks[existingTaskIndex] = task;
                
                // Update in Firestore
                if (db && currentAuthUser && appState.currentTeamId) {
                    await updateTaskInFirestore(task);
                }
                
                showToast('Task updated successfully', 'success');
                
                // Add to activity feed only if NOT a private spreadsheet task
                const spreadsheet = appState.spreadsheets.find(s => s.id === task.spreadsheetId);
                const isPrivateSpreadsheet = spreadsheet && spreadsheet.visibility === 'private';
                
                if (!isPrivateSpreadsheet) {
                    addActivity({
                        type: 'task',
                        description: `updated task "${task.title}"`
                    });
                }
            }
        } else {
            // Save to Firestore first to get the real ID
            if (db && currentAuthUser && appState.currentTeamId) {
                const firestoreId = await saveTaskToFirestore(task);
                if (firestoreId) {
                    task.id = firestoreId; // Use Firestore's document ID
                } else {
                    task.id = Date.now(); // Fallback to timestamp if Firestore fails
                }
            } else {
                task.id = Date.now(); // Fallback for offline mode
            }

            appState.tasks.push(task);
            
            // Add to activity feed only if NOT a private spreadsheet task
            const spreadsheet = appState.spreadsheets.find(s => s.id === task.spreadsheetId);
            const isPrivateSpreadsheet = spreadsheet && spreadsheet.visibility === 'private';
            
            if (!isPrivateSpreadsheet) {
                addActivity({
                    type: 'task',
                    description: `created task "${task.title}" assigned to ${assigneeName}`
                });
            }
        }
        
        saveToLocalStorage('tasks', appState.tasks);
        
        // Update display
        if (window.displayTasks) {
            window.displayTasks();
        }

        taskForm.reset();
        delete taskForm.dataset.editingTaskId;
        
        // Update rate limit state after successful creation
        if (!isEditing) {
            rateLimitState.lastTaskCreation = Date.now();
            rateLimitState.isCreatingTask = false;
        }
        
        // Show success toast for new tasks
        if (!isEditing) {
            showToast('Task created successfully', 'success');
        }
        
        // Reset modal title and button
        const titleEl = document.querySelector('#taskModal .unified-modal-title h2');
        const submitBtn = document.querySelector('#taskModal .unified-btn-primary');
        if (titleEl) titleEl.innerHTML = '<i class="fas fa-plus-circle"></i> New Task';
        if (submitBtn) submitBtn.innerHTML = '<i class="fas fa-check"></i> Create Task';
        
        // Reset status dropdown to default
        const taskStatus = document.getElementById('taskStatus');
        if (taskStatus) taskStatus.value = 'todo';

        // Reset progress bar (range slider + number input + fill + badge)
        const resetProgressInput = document.getElementById('taskProgress');
        const resetProgressSlider = document.getElementById('taskProgressSlider');
        const resetProgressFill = document.getElementById('taskProgressFill');
        const resetProgressBadge = document.getElementById('taskProgressBadge');
        if (resetProgressInput) {
            resetProgressInput.value = 0;
            if (resetProgressSlider) {
                resetProgressSlider.value = 0;
                resetProgressSlider.style.setProperty('--progress', '0%');
            }
            if (resetProgressFill) {
                resetProgressFill.style.width = '0%';
            }
            if (resetProgressBadge) {
                resetProgressBadge.textContent = '0%';
            }
        }
        
        // Hide due date helper
        const dueDateHelper = document.getElementById('dueDateHelper');
        if (dueDateHelper) dueDateHelper.style.display = 'none';
        
        closeModal('taskModal');
    });

    // ===================================
    // ADD LEAD MODAL LOGIC
    // ===================================
    const leadForm = document.getElementById('leadForm');
    const closeLeadModal = document.getElementById('closeLeadModal');
    const cancelLeadBtn = document.getElementById('cancelLeadBtn');
    
    if (closeLeadModal) {
        closeLeadModal.addEventListener('click', () => closeModal('leadModal'));
    }
    if (cancelLeadBtn) {
        cancelLeadBtn.addEventListener('click', () => closeModal('leadModal'));
    }
    
    // Initialize lead modal dropdowns
    initLeadModalDropdowns();
    
    if (leadForm) {
        leadForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const leadNameInput = document.getElementById('leadName');
            const leadName = leadNameInput?.value?.trim();
            
            if (!leadName) {
                showToast('Lead name is required', 'error');
                return;
            }
            
            const spreadsheetId = document.getElementById('leadSpreadsheet')?.value;
            if (!spreadsheetId) {
                showToast('Please select a spreadsheet', 'error');
                return;
            }
            
            const lead = {
                leadName: leadName,
                status: document.getElementById('leadStatus')?.value || 'New',
                source: document.getElementById('leadSource')?.value || 'Website',
                value: parseFloat(document.getElementById('leadValue')?.value) || null,
                contact: document.getElementById('leadContact')?.value?.trim() || null,
                notes: document.getElementById('leadNotes')?.value?.trim() || null,
                spreadsheetId: spreadsheetId,
                createdBy: currentAuthUser?.uid || null,
                createdAt: Date.now()
            };
            
            // Save to Firestore first to get the real ID
            if (db && currentAuthUser && appState.currentTeamId) {
                const firestoreId = await saveTaskToFirestore(lead);
                if (firestoreId) {
                    lead.id = firestoreId;
                } else {
                    lead.id = Date.now();
                }
            } else {
                lead.id = Date.now();
            }
            
            appState.tasks.push(lead);
            saveToLocalStorage('tasks', appState.tasks);
            
            // Update display
            if (window.displayTasks) {
                window.displayTasks();
            }
            
            // Add to activity feed
            const spreadsheet = appState.spreadsheets.find(s => s.id === spreadsheetId);
            const isPrivateSpreadsheet = spreadsheet && spreadsheet.visibility === 'private';
            
            if (!isPrivateSpreadsheet) {
                addActivity({
                    type: 'lead',
                    description: `added new lead "${leadName}"`
                });
            }
            
            leadForm.reset();
            resetLeadModalDropdowns();
            closeModal('leadModal');
            showToast(`Lead "${leadName}" created!`, 'success');
        });
    }

    // Event Details Modal
    const closeEventDetailsModal = document.getElementById('closeEventDetailsModal');
    closeEventDetailsModal.addEventListener('click', () => closeModal('eventDetailsModal'));

    // Logout All Devices Modal
    const closeLogoutAllModal = document.getElementById('closeLogoutAllModal');
    const cancelLogoutAll = document.getElementById('cancelLogoutAll');
    const confirmLogoutAll = document.getElementById('confirmLogoutAll');
    
    if (closeLogoutAllModal) {
        closeLogoutAllModal.addEventListener('click', () => closeModal('logoutAllModal'));
    }
    if (cancelLogoutAll) {
        cancelLogoutAll.addEventListener('click', () => closeModal('logoutAllModal'));
    }
    if (confirmLogoutAll) {
        confirmLogoutAll.addEventListener('click', () => {
            closeModal('logoutAllModal');
            forceLogoutEverywhere();
        });
    }

    // Delete Chat History Modal
    const closeDeleteChatHistoryModal = document.getElementById('closeDeleteChatHistoryModal');
    const cancelDeleteChatHistory = document.getElementById('cancelDeleteChatHistory');
    const confirmDeleteChatHistory = document.getElementById('confirmDeleteChatHistory');
    
    if (closeDeleteChatHistoryModal) {
        closeDeleteChatHistoryModal.addEventListener('click', () => closeModal('deleteChatHistoryModal'));
    }
    if (cancelDeleteChatHistory) {
        cancelDeleteChatHistory.addEventListener('click', () => closeModal('deleteChatHistoryModal'));
    }
    if (confirmDeleteChatHistory) {
        confirmDeleteChatHistory.addEventListener('click', () => {
            clearAllMessages();
        });
    }

    // Role management pending variables (make them global so window functions can access)
    window.pendingPromoteUserId = null;
    window.pendingPromoteUserName = null;
    window.pendingDemoteUserId = null;
    window.pendingDemoteUserName = null;
    window.pendingKickUserId = null;
    window.pendingKickUserName = null;

    // Promote Modal
    const confirmPromote = document.getElementById('confirmPromote');
    if (confirmPromote) {
        console.log('Confirm promote button found, adding event listener');
        confirmPromote.addEventListener('click', () => {
            console.log('Confirm promote button clicked!');
            console.log('pendingPromoteUserId:', window.pendingPromoteUserId);
            console.log('pendingPromoteUserName:', window.pendingPromoteUserName);
            if (window.pendingPromoteUserId && window.pendingPromoteUserName) {
                console.log('Calling closePromoteModal and promoteToAdmin');
                // Save values before closing (which clears them)
                const userId = window.pendingPromoteUserId;
                const userName = window.pendingPromoteUserName;
                closePromoteModal();
                promoteToAdmin(userId, userName);
            } else {
                console.error('Missing userId or userName!');
            }
        });
    } else {
        console.error('confirmPromote button not found!');
    }

    // Demote Modal
    const confirmDemote = document.getElementById('confirmDemote');
    if (confirmDemote) {
        confirmDemote.addEventListener('click', () => {
            if (window.pendingDemoteUserId && window.pendingDemoteUserName) {
                // Save values before closing
                const userId = window.pendingDemoteUserId;
                const userName = window.pendingDemoteUserName;
                closeDemoteModal();
                demoteToMember(userId, userName);
            }
        });
    }

    // Kick Modal
    const confirmKick = document.getElementById('confirmKick');
    if (confirmKick) {
        confirmKick.addEventListener('click', () => {
            if (window.pendingKickUserId && window.pendingKickUserName) {
                // Save values before closing
                const userId = window.pendingKickUserId;
                const userName = window.pendingKickUserName;
                closeKickModal();
                removeMember(userId, userName);
            }
        });
    }

    // Close modal on backdrop click
    document.querySelectorAll('.modal').forEach(modal => {
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                closeModal(modal.id);
            }
        });
    });
    
    // Also handle unified modals (new system)
    document.querySelectorAll('.unified-modal').forEach(modal => {
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                closeModal(modal.id);
            }
        });
    });
}

function openModal(modalId) {
    const modal = document.getElementById(modalId);
    if (!modal) return;
    modal.classList.add('active');
    
    // Add modal-open class to body for mobile styling (hides bottom nav)
    document.body.classList.add('modal-open');
    
    // Bug fix 2: Reset event form duration display when opening event modal
    if (modalId === 'eventModal') {
        const eventForm = document.getElementById('eventForm');
        
        // Only reset if not editing an event
        if (!eventForm.dataset.editingEventId) {
            const durationDisplay = document.getElementById('eventDuration');
            if (durationDisplay) {
                durationDisplay.style.display = 'block';
            }
            const durationText = document.getElementById('durationText');
            if (durationText) {
                durationText.textContent = '0 minutes';
            }
            
            // Reset modal title and button text for unified modal
            const titleEl = document.querySelector('#eventModal .unified-modal-title h2');
            if (titleEl) {
                titleEl.innerHTML = '<i class="fas fa-calendar-plus"></i> New Event';
            }
            const btnEl = document.querySelector('#eventModal .unified-btn-primary');
            if (btnEl) {
                btnEl.innerHTML = '<i class="fas fa-check"></i> Add Event';
            }
        }
    }
}

// Open event modal with pre-filled date and time
function openEventModalWithDate(selectedDate, startHour = 9) {
    // Reset the form first
    const eventForm = document.getElementById('eventForm');
    if (eventForm) {
        eventForm.reset();
        delete eventForm.dataset.editingEventId;
    }
    
    // Format date for input field (YYYY-MM-DD)
    const year = selectedDate.getFullYear();
    const month = String(selectedDate.getMonth() + 1).padStart(2, '0');
    const day = String(selectedDate.getDate()).padStart(2, '0');
    const dateStr = `${year}-${month}-${day}`;
    
    // Set the date
    const eventDateInput = document.getElementById('eventDate');
    if (eventDateInput) {
        eventDateInput.value = dateStr;
    }
    
    // Set start time (default 9:00 if not provided)
    const eventHourInput = document.getElementById('eventHour');
    const eventMinuteInput = document.getElementById('eventMinute');
    if (eventHourInput) {
        eventHourInput.value = String(startHour).padStart(2, '0');
    }
    if (eventMinuteInput) {
        eventMinuteInput.value = '00';
    }
    
    // Set end time (1 hour after start)
    const endHour = (startHour + 1) % 24;
    const eventEndHourInput = document.getElementById('eventEndHour');
    const eventEndMinuteInput = document.getElementById('eventEndMinute');
    if (eventEndHourInput) {
        eventEndHourInput.value = String(endHour).padStart(2, '0');
    }
    if (eventEndMinuteInput) {
        eventEndMinuteInput.value = '00';
    }
    
    // Update duration display
    const durationText = document.getElementById('durationText');
    if (durationText) {
        durationText.textContent = '60 minutes';
    }
    
    // Reset visibility and repeat to defaults
    resetEventVisibility();
    resetEventRepeat();
    
    // Open the modal
    openModal('eventModal');
}

// Expose globally for calendar click handlers
window.openEventModalWithDate = openEventModalWithDate;

function closeModal(modalId) {
    const modal = document.getElementById(modalId);
    if (!modal) return;
    modal.classList.remove('active');
    
    // Remove modal-open class from body if no modals are active
    const anyModalActive = document.querySelector('.modal.active');
    if (!anyModalActive) {
        document.body.classList.remove('modal-open');
    }
}

/**
 * Initialize a custom time picker with dropdown
 * @param {string} wrapperId - The ID of the wrapper element
 * @param {string} hourInputId - The ID of the hour input
 * @param {string} minuteInputId - The ID of the minute input  
 * @param {string} hourOptionsId - The ID of the hour options container
 * @param {string} minuteOptionsId - The ID of the minute options container
 */
function initializeTimePicker(wrapperId, hourInputId, minuteInputId, hourOptionsId, minuteOptionsId) {
    const wrapper = document.getElementById(wrapperId);
    const hourInput = document.getElementById(hourInputId);
    const minuteInput = document.getElementById(minuteInputId);
    const hourOptions = document.getElementById(hourOptionsId);
    const minuteOptions = document.getElementById(minuteOptionsId);
    
    if (!wrapper || !hourInput || !minuteInput || !hourOptions || !minuteOptions) return;
    
    // Generate hour options (0-23)
    hourOptions.innerHTML = '';
    for (let i = 0; i < 24; i++) {
        const option = document.createElement('div');
        option.className = 'time-picker-option';
        option.textContent = i.toString().padStart(2, '0');
        option.dataset.value = i;
        hourOptions.appendChild(option);
    }
    
    // Generate minute options (0-59)
    minuteOptions.innerHTML = '';
    for (let i = 0; i < 60; i++) {
        const option = document.createElement('div');
        option.className = 'time-picker-option';
        option.textContent = i.toString().padStart(2, '0');
        option.dataset.value = i;
        minuteOptions.appendChild(option);
    }
    
    // Toggle dropdown
    const display = wrapper.querySelector('.time-picker-display');
    display.addEventListener('click', (e) => {
        // Don't toggle if clicking on input
        if (e.target.tagName === 'INPUT') return;
        wrapper.classList.toggle('open');
        if (wrapper.classList.contains('open')) {
            updateSelectedOptions();
            scrollToSelected();
        }
    });
    
    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
        if (!wrapper.contains(e.target)) {
            wrapper.classList.remove('open');
        }
    });
    
    // Handle hour option click
    hourOptions.addEventListener('click', (e) => {
        const option = e.target.closest('.time-picker-option');
        if (option) {
            const value = option.dataset.value;
            hourInput.value = value.toString().padStart(2, '0');
            updateSelectedOptions();
            hourInput.dispatchEvent(new Event('change', { bubbles: true }));
        }
    });
    
    // Handle minute option click
    minuteOptions.addEventListener('click', (e) => {
        const option = e.target.closest('.time-picker-option');
        if (option) {
            const value = option.dataset.value;
            minuteInput.value = value.toString().padStart(2, '0');
            updateSelectedOptions();
            minuteInput.dispatchEvent(new Event('change', { bubbles: true }));
        }
    });
    
    // Handle input changes
    hourInput.addEventListener('input', (e) => {
        let val = e.target.value.replace(/\D/g, '');
        if (val.length > 2) val = val.slice(0, 2);
        const num = parseInt(val);
        if (!isNaN(num) && num > 23) val = '23';
        e.target.value = val;
        updateSelectedOptions();
    });
    
    minuteInput.addEventListener('input', (e) => {
        let val = e.target.value.replace(/\D/g, '');
        if (val.length > 2) val = val.slice(0, 2);
        const num = parseInt(val);
        if (!isNaN(num) && num > 59) val = '59';
        e.target.value = val;
        updateSelectedOptions();
    });
    
    // Format on blur (add leading zero)
    hourInput.addEventListener('blur', () => {
        const val = parseInt(hourInput.value);
        if (!isNaN(val) && val >= 0 && val <= 23) {
            hourInput.value = val.toString().padStart(2, '0');
        }
    });
    
    minuteInput.addEventListener('blur', () => {
        const val = parseInt(minuteInput.value);
        if (!isNaN(val) && val >= 0 && val <= 59) {
            minuteInput.value = val.toString().padStart(2, '0');
        }
    });
    
    function updateSelectedOptions() {
        const hourVal = parseInt(hourInput.value);
        const minuteVal = parseInt(minuteInput.value);
        
        hourOptions.querySelectorAll('.time-picker-option').forEach(opt => {
            opt.classList.toggle('selected', parseInt(opt.dataset.value) === hourVal);
        });
        
        minuteOptions.querySelectorAll('.time-picker-option').forEach(opt => {
            opt.classList.toggle('selected', parseInt(opt.dataset.value) === minuteVal);
        });
    }
    
    function scrollToSelected() {
        const selectedHour = hourOptions.querySelector('.time-picker-option.selected');
        const selectedMinute = minuteOptions.querySelector('.time-picker-option.selected');
        
        if (selectedHour) {
            selectedHour.scrollIntoView({ block: 'center', behavior: 'instant' });
        }
        if (selectedMinute) {
            selectedMinute.scrollIntoView({ block: 'center', behavior: 'instant' });
        }
    }
}

// Shared visibility toggle helpers (calendar-style segmented control)
function initVisibilityToggles(toggles) {
    const targets = toggles ? Array.from(toggles) : Array.from(document.querySelectorAll('.visibility-toggle'));
    targets.forEach(toggle => {
        const targetName = toggle.dataset.target;
        let hiddenInput = targetName ? toggle.querySelector(`input[name="${targetName}"]`) : null;
        if (!hiddenInput && targetName) {
            hiddenInput = document.createElement('input');
            hiddenInput.type = 'hidden';
            hiddenInput.name = targetName;
            hiddenInput.value = 'team';
            toggle.appendChild(hiddenInput);
        }
        const buttons = toggle.querySelectorAll('.view-toggle-btn');
        const activate = (btn) => {
            buttons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            const value = btn.dataset.visibility || 'team';
            if (hiddenInput) hiddenInput.value = value;
        };
        buttons.forEach(btn => btn.addEventListener('click', () => activate(btn)));
        const preset = toggle.querySelector('.view-toggle-btn.active') || Array.from(buttons).find(b => b.dataset.visibility === (hiddenInput?.value || 'team')) || buttons[0];
        if (preset) activate(preset);
    });
}

function setVisibilitySelection(toggle, visibility) {
    if (!toggle) return;
    const buttons = toggle.querySelectorAll('.view-toggle-btn');
    let applied = false;
    buttons.forEach(btn => {
        const isSelected = btn.dataset.visibility === visibility;
        btn.classList.toggle('active', isSelected);
        if (isSelected) applied = true;
    });
    if (!applied && buttons.length) {
        buttons.forEach(btn => btn.classList.remove('active'));
        buttons[0].classList.add('active');
        visibility = buttons[0].dataset.visibility || 'team';
    }
    const hiddenInput = toggle.querySelector('input[type="hidden"]');
    if (hiddenInput) hiddenInput.value = visibility;
}

function getActiveVisibilityValue(targetName, fallback = 'team') {
    const toggle = document.querySelector(`.visibility-toggle[data-target="${targetName}"]`);
    const active = toggle?.querySelector('.view-toggle-btn.active');
    if (active?.dataset.visibility) return active.dataset.visibility;
    const hidden = toggle?.querySelector('input[type="hidden"]');
    return hidden?.value || fallback;
}

// Reset event visibility selector to default
function resetEventVisibility() {
    document.querySelectorAll('#eventModal .visibility-toggle').forEach(toggle => {
        setVisibilitySelection(toggle, 'team');
    });
}

// Reset event repeat selector to default
function resetEventRepeat() {
    document.querySelectorAll('.repeat-chip').forEach(opt => {
        const radio = opt.querySelector('input[type="radio"]');
        const isDefault = opt.dataset.repeat === 'none';
        opt.classList.toggle('selected', isDefault);
        if (radio) radio.checked = isDefault;
    });
    const repeatHelper = document.getElementById('repeatHelper');
    if (repeatHelper) repeatHelper.style.display = 'none';
}

// Set event repeat selector to specific value
function setEventRepeat(repeat) {
    document.querySelectorAll('.repeat-chip').forEach(opt => {
        const radio = opt.querySelector('input[type="radio"]');
        const isSelected = opt.dataset.repeat === repeat;
        opt.classList.toggle('selected', isSelected);
        if (radio) radio.checked = isSelected;
    });
}

// Set event visibility selector to specific value
function setEventVisibility(visibility) {
    document.querySelectorAll('#eventModal .visibility-toggle').forEach(toggle => {
        setVisibilitySelection(toggle, visibility);
    });
}

// Open edit event modal with existing event data
function openEditEventModal(event) {
    console.log('openEditEventModal called with:', event);
    
    // Populate the form with existing event data
    document.getElementById('eventTitle').value = event.title;
    document.getElementById('eventDescription').value = event.description || '';
    
    // Set date
    const eventDate = new Date(event.date);
    const dateStr = eventDate.toISOString().split('T')[0];
    document.getElementById('eventDate').value = dateStr;
    
    // Set start time
    document.getElementById('eventHour').value = String(eventDate.getHours()).padStart(2, '0');
    document.getElementById('eventMinute').value = String(eventDate.getMinutes()).padStart(2, '0');
    
    // Set end time
    const endDate = event.endDate ? new Date(event.endDate) : new Date(eventDate.getTime() + 60*60*1000);
    document.getElementById('eventEndHour').value = String(endDate.getHours()).padStart(2, '0');
    document.getElementById('eventEndMinute').value = String(endDate.getMinutes()).padStart(2, '0');
    
    // Set color
    const colorInput = document.getElementById('eventColor');
    colorInput.value = event.color || '#007AFF';
    
    // Update event color option selection (unified style)
    document.querySelectorAll('.unified-color-option').forEach(btn => {
        if (btn.dataset.color === colorInput.value) {
            btn.classList.add('selected');
        } else {
            btn.classList.remove('selected');
        }
    });
    
    // Set visibility
    setEventVisibility(event.visibility || 'team');
    
    // Set repeat option
    setEventRepeat(event.repeat || 'none');
    
    // Update repeat helper text if needed
    if (event.repeat && event.repeat !== 'none') {
        const repeatHelper = document.getElementById('repeatHelper');
        const repeatHelperText = document.getElementById('repeatHelperText');
        if (repeatHelper && repeatHelperText) {
            const startDate = new Date(event.date);
            const dayName = startDate.toLocaleDateString('en-US', { weekday: 'long' });
            const dayOfMonth = startDate.getDate();
            const monthName = startDate.toLocaleDateString('en-US', { month: 'long' });
            
            let helperText = '';
            switch (event.repeat) {
                case 'daily':
                    helperText = `This event repeats every day`;
                    break;
                case 'weekly':
                    helperText = `This event repeats every ${dayName}`;
                    break;
                case 'monthly':
                    helperText = `This event repeats on the ${dayOfMonth}${getOrdinalSuffix(dayOfMonth)} of every month`;
                    break;
                case 'yearly':
                    helperText = `This event repeats every ${monthName} ${dayOfMonth}${getOrdinalSuffix(dayOfMonth)}`;
                    break;
            }
            repeatHelperText.textContent = helperText;
            repeatHelper.style.display = 'flex';
        }
    }
    
    // Change modal title and button text (unified style)
    const titleEl = document.querySelector('#eventModal .unified-modal-title h2');
    if (titleEl) {
        titleEl.innerHTML = '<i class="fas fa-calendar-plus"></i> Edit Event';
    }
    const btnEl = document.querySelector('#eventModal .unified-btn-primary');
    if (btnEl) {
        btnEl.innerHTML = '<i class="fas fa-check"></i> Update Event';
    }
    
    // Store event ID for update
    document.getElementById('eventForm').dataset.editingEventId = event.id;
    
    // Trigger duration calculation by dispatching input event
    const startHourInput = document.getElementById('eventHour');
    if (startHourInput) {
        startHourInput.dispatchEvent(new Event('input', { bubbles: true }));
    }
    
    openModal('eventModal');
}

// View event details
async function viewEventDetails(eventId, occurrenceDateStr = '') {
    if (DEBUG) console.log('ðŸ” viewEventDetails called with:', eventId, 'occurrence:', occurrenceDateStr);
    
    try {
        const event = appState.events.find(e => e.id === eventId);
        if (!event) {
            console.error('âŒ Event not found');
            debugError('Event ID:', eventId);
            return;
        }
        
        if (DEBUG) console.log('âœ… Event found:', event);
        
        // Get team info to check permissions
        const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        const teamRef = doc(db, 'teams', appState.currentTeamId);
        const teamSnap = await getDoc(teamRef);
        
        const teamData = teamSnap.exists() ? teamSnap.data() : null;
        const members = teamData?.members || {};
        const isTeamMember = currentAuthUser.uid in members;
        const isOwner = teamData?.owner === currentAuthUser.uid;
        const userRole = getCurrentUserRole(teamData);
        const isAdmin = userRole === 'admin' || userRole === 'owner';
        
        if (DEBUG) {
            console.log('ðŸ‘¥ Team member:', isTeamMember, 'Owner:', isOwner, 'Admin:', isAdmin);
        }
    
    // Populate modal - new modern design
    // Use occurrence date if provided, otherwise use event date
    let eventDate;
    if (occurrenceDateStr && event.repeat && event.repeat !== 'none') {
        eventDate = new Date(occurrenceDateStr);
        // Preserve the original time
        const originalDate = new Date(event.date);
        eventDate.setHours(originalDate.getHours(), originalDate.getMinutes(), 0, 0);
    } else {
        eventDate = new Date(event.date);
    }
    
    // Calculate end date based on original event duration
    const originalStart = new Date(event.date);
    const originalEnd = event.endDate ? new Date(event.endDate) : new Date(originalStart.getTime() + 60*60*1000);
    const durationMs = originalEnd.getTime() - originalStart.getTime();
    const endDate = new Date(eventDate.getTime() + durationMs);
    
    const eventColor = event.color || '#007AFF';
    
    // Title and subtitle
    document.getElementById('eventDetailsTitle').textContent = event.title;
    document.getElementById('eventSubtitle').textContent = eventDate.toLocaleDateString('en-US', {
        weekday: 'long',
        month: 'short',
        day: 'numeric'
    });
    
    // Date
    document.getElementById('detailDate').textContent = eventDate.toLocaleDateString('en-US', {
        weekday: 'short',
        month: 'short',
        day: 'numeric',
        year: 'numeric'
    });
    
    // Time - use 24h format
    const startTime24 = formatTime24(eventDate.getHours(), eventDate.getMinutes());
    const endTime24 = formatTime24(endDate.getHours(), endDate.getMinutes());
    document.getElementById('detailTime').textContent = `${startTime24} â€“ ${endTime24}`;
    
    // Duration
    const diffMs = endDate - eventDate;
    const diffMinutes = Math.floor(diffMs / 60000);
    const hours = Math.floor(diffMinutes / 60);
    const minutes = diffMinutes % 60;
    let durationText = '';
    if (hours > 0) {
        durationText = `${hours}h ${minutes > 0 ? minutes + 'm' : ''}`;
    } else {
        durationText = `${minutes} min`;
    }
    document.getElementById('detailDuration').textContent = durationText;
    
    // Get the creator's username from team members
    let creatorName = event.createdByName || 'Unknown';
    if (teamData && teamData.members && event.createdBy) {
        const creatorMember = teamData.members[event.createdBy];
        if (creatorMember && creatorMember.name) {
            creatorName = creatorMember.name;
        }
    }
    document.getElementById('detailCreatedBy').textContent = creatorName;
    
    // Visibility (if set)
    const visibilityCard = document.getElementById('visibilityCard');
    const visibilityBadge = document.getElementById('detailVisibility');
    if (event.visibility && event.visibility !== 'team') {
        visibilityCard.style.display = 'flex';
        visibilityBadge.className = 'event-value-clean visibility-badge-clean';
        if (event.visibility === 'private') {
            visibilityBadge.innerHTML = '<i class="fas fa-lock"></i> Only Me';
        } else if (event.visibility === 'admins') {
            visibilityBadge.innerHTML = '<i class="fas fa-shield-alt"></i> Admins Only';
        }
    } else {
        visibilityCard.style.display = 'none';
    }
    
    // Recurrence info
    const repeatCard = document.getElementById('repeatCard');
    const repeatBadge = document.getElementById('detailRepeat');
    if (event.repeat && event.repeat !== 'none') {
        if (repeatCard) {
            repeatCard.style.display = 'flex';
            const repeatLabels = {
                'daily': 'Every day',
                'weekly': 'Every week',
                'monthly': 'Every month',
                'yearly': 'Every year'
            };
            repeatBadge.textContent = repeatLabels[event.repeat] || event.repeat;
        }
    } else if (repeatCard) {
        repeatCard.style.display = 'none';
    }
    
    // Description
    const descriptionEl = document.getElementById('detailDescription');
    const descriptionSection = document.getElementById('descriptionSection');
    if (event.description && event.description.trim()) {
        descriptionEl.textContent = event.description;
        descriptionSection.style.display = 'block';
    } else {
        descriptionEl.textContent = '';
        descriptionSection.style.display = 'none';
    }
    
    // Hidden color field for backward compatibility
    document.getElementById('detailColor').style.backgroundColor = eventColor;
    
    // Check if user is a team member (anyone in team can edit)
    const actionsDiv = document.getElementById('eventDetailsActions');
    const editBtnHeader = document.getElementById('editEventBtnHeader');
    const deleteBtn = document.getElementById('deleteEventBtn');
    
    if (isTeamMember) {
        // All team members can edit
        editBtnHeader.style.display = 'flex';
        
        // Set up edit button in header
        editBtnHeader.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('Edit button clicked, event:', event);
            closeModal('eventDetailsModal');
            setTimeout(() => {
                openEditEventModal(event);
            }, 100);
        };
        
        // Admin or owner can delete
        if (isAdmin) {
            deleteBtn.style.display = 'flex';
            deleteBtn.onclick = async () => {
                const confirmed = await showConfirmModal(`Are you sure you want to delete "${event.title}"?`, {
                    title: 'Delete Event',
                    confirmText: 'Delete',
                    type: 'danger'
                });
                if (confirmed) {
                    await deleteEvent(eventId);
                    closeModal('eventDetailsModal');
                }
            };
        } else {
            deleteBtn.style.display = 'none';
        }
    } else {
        editBtnHeader.style.display = 'none';
        deleteBtn.style.display = 'none';
    }
    
    console.log('ðŸ“‚ Opening event details modal...');
    openModal('eventDetailsModal');
    
    } catch (error) {
        console.error('âŒ Error in viewEventDetails:', error);
        showToast('Error loading event details: ' + error.message, 'error');
    }
}

// Delete event
async function deleteEvent(eventId) {
    if (!db || !currentAuthUser || !appState.currentTeamId) {
        showToast('Cannot delete event. Please try again.', 'error');
        return;
    }
    
    // Check permissions: admin/owner can delete any event, members can only delete their own
    try {
        const { doc, getDoc, deleteDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const teamRef = doc(db, 'teams', appState.currentTeamId);
        const teamDoc = await getDoc(teamRef);
        const teamData = teamDoc.data();
        
        const userRole = getCurrentUserRole(teamData);
        const isAdminOrOwner = userRole === 'admin' || userRole === 'owner';
        
        // Get the event to check creator
        const event = appState.events.find(e => e.id === eventId);
        const isCreator = event && event.createdBy === currentAuthUser.uid;
        
        if (!isAdminOrOwner && !isCreator) {
            showToast('You can only delete events you created. Admins and owners can delete any event.', 'warning');
            return;
        }
        
        const eventRef = doc(db, 'teams', appState.currentTeamId, 'events', eventId);
        await deleteDoc(eventRef);
        
        debugLog('âœ… Event deleted');
        
        // Use unified identity resolver for consistent name
        const identity = getIdentity(currentAuthUser.uid, currentAuthUser.email?.split('@')[0]);
        
        // Add activity
        addActivity({
            type: 'calendar',
            user: identity.displayName,
            description: 'deleted an event'
        });
        
    } catch (error) {
        console.error('Error deleting event:', error.code || error.message);
        debugError('Full error:', error);
        showToast('Error deleting event: ' + error.message, 'error', 5000, 'Delete Failed');
    }
}

// Make viewEventDetails globally accessible
window.viewEventDetails = viewEventDetails;

// ===================================
// TEAM MANAGEMENT
// ===================================

// Initialize or get user's team
async function initializeUserTeam() {
    if (!currentAuthUser || !db) {
        console.error('âŒ Cannot initialize team: User not authenticated or DB not ready');
        return;
    }

    try {
        debugLog('ðŸ”„ Checking if user has a team...');
        
        const { collection, query, where, getDocs, doc, getDoc, setDoc, addDoc, serverTimestamp, onSnapshot, updateDoc, deleteField } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');

        const userRef = doc(db, 'users', currentAuthUser.uid);
        
        // Check if user document exists
        let userDoc = await getDoc(userRef);
        let userTeams = [];
        
        if (userDoc.exists()) {
            userTeams = userDoc.data().teams || [];
            debugLog('ðŸ“‹ User has teams:', userTeams);
        } else {
            // Create user document if it doesn't exist
            debugLog('ðŸ“ Creating user document...');
            try {
                // Use unified identity resolver for consistent name
                const identity = getIdentity(currentAuthUser.uid, currentAuthUser.email?.split('@')[0]);
                
                await setDoc(userRef, {
                    email: currentAuthUser.email,
                    displayName: identity.displayName,
                    teams: [],
                    createdAt: serverTimestamp()
                });
                debugLog('âœ… User document created');
            } catch (createError) {
                console.warn('Could not create user document:', createError.code || createError.message);
                // Continue anyway - user can still be in team.members
            }
        }

        // Set up real-time listener on user's document to detect team changes
        onSnapshot(userRef, async (userDocSnapshot) => {
            if (userDocSnapshot.exists()) {
                const userData = userDocSnapshot.data();
                const newTeams = userData.teams || [];
                
                // Check if team has changed
                if (newTeams.length > 0 && newTeams[0] !== appState.currentTeamId) {
                    debugLog('ðŸ”„ Team changed detected! Reloading team data...');
                    appState.currentTeamId = newTeams[0];
                    appState.userTeams = newTeams;
                    await loadTeamData();
                }
            }
        }, (error) => {
            // Handle Firestore listener errors (permission-denied, network issues, etc.)
            if (error.code === 'permission-denied') {
                debugLog('âš ï¸ User document listener: permission denied (normal if logged out)');
            } else if (error.code === 'unavailable' || error.code === 'deadline-exceeded') {
                debugLog('âš ï¸ User document listener temporarily unavailable, will auto-retry');
            } else {
                console.error('Error in user document listener:', error.code || error.message);
            }
        });

        // CLEANUP: Verify user is actually a member of their listed team(s)
        if (userTeams.length > 0) {
            const validTeams = [];
            
            for (const teamId of userTeams) {
                try {
                    const teamRef = doc(db, 'teams', teamId);
                    const teamDoc = await getDoc(teamRef);
                    
                    if (teamDoc.exists()) {
                        const teamData = teamDoc.data();
                        const members = teamData.members || {};
                        
                        // Check if user is actually a member of this team
                        if (members[currentAuthUser.uid]) {
                            validTeams.push(teamId);
                            debugLog(`âœ… Verified membership in team: ${teamId}`);
                        } else {
                            console.warn(`âš ï¸ User listed in team ${teamId} but not a member! Removing...`);
                        }
                    } else {
                        console.warn(`âš ï¸ Team ${teamId} doesn't exist! Removing...`);
                    }
                } catch (error) {
                    console.warn('Error checking team:', error);
                }
            }
            
            // Update user's teams to only valid teams
            if (validTeams.length !== userTeams.length) {
                await updateDoc(userRef, {
                    teams: validTeams
                });
                userTeams = validTeams;
                console.log('âœ… Updated user teams to valid teams only:', validTeams);
            }
        }

        // CLEANUP: If user has multiple teams, keep the most active one (most members) and remove from others
        if (userTeams.length > 1) {
            console.warn('âš ï¸ User is in multiple teams! Selecting primary team...');
            
            // Find the team with the most members (likely the real/active team)
            let primaryTeam = userTeams[0];
            let maxMembers = 0;
            
            for (const teamId of userTeams) {
                try {
                    const teamRef = doc(db, 'teams', teamId);
                    const teamDoc = await getDoc(teamRef);
                    if (teamDoc.exists()) {
                        const teamData = teamDoc.data();
                        const memberCount = Object.keys(teamData.members || {}).length;
                        debugLog(`  Team ${teamId}: ${memberCount} members`);
                        
                        if (memberCount > maxMembers) {
                            maxMembers = memberCount;
                            primaryTeam = teamId;
                        }
                    }
                } catch (error) {
                    console.warn('Error checking team size:', error);
                }
            }
            
            debugLog(`âœ… Selected primary team: ${primaryTeam} (${maxMembers} members)`);
            
            // Just use the primary team, don't automatically remove from others
            // User should explicitly leave teams or join new ones
            appState.currentTeamId = primaryTeam;
            appState.userTeams = userTeams;
            await loadTeamData();
            return;
        }

        // If user has teams, load the first one
        if (userTeams.length > 0) {
            appState.currentTeamId = userTeams[0];
            appState.userTeams = userTeams;
            debugLog('âœ… Loaded existing team:', appState.currentTeamId);
            
            // Load team data
            await loadTeamData();
            return;
        }

        // No teams in user document - check userTeamMemberships first (fastest, most reliable)
        // This is written by admins when approving join requests
        debugLog('ðŸ” No teams in user doc - checking userTeamMemberships...');
        
        try {
            const membershipRef = doc(db, 'userTeamMemberships', currentAuthUser.uid);
            const membershipDoc = await getDoc(membershipRef);
            
            if (membershipDoc.exists()) {
                const membership = membershipDoc.data();
                debugLog(`âœ… Found team membership via userTeamMemberships: ${membership.teamId}`);
                
                // Verify we're actually in this team
                const teamRef = doc(db, 'teams', membership.teamId);
                const teamDoc = await getDoc(teamRef);
                
                if (teamDoc.exists()) {
                    const teamData = teamDoc.data();
                    if (teamData.members && teamData.members[currentAuthUser.uid]) {
                        // Update user's teams array
                        await setDoc(userRef, {
                            teams: [membership.teamId]
                        }, { merge: true });
                        
                        appState.currentTeamId = membership.teamId;
                        appState.userTeams = [membership.teamId];
                        
                        // Clean up the membership record since we've synced
                        try {
                            const { deleteDoc: delDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
                            await delDoc(membershipRef);
                            debugLog('âœ… Cleaned up userTeamMemberships record');
                        } catch (cleanupError) {
                            // Not critical if cleanup fails
                            debugLog('âš ï¸ Could not clean up membership record:', cleanupError.message);
                        }
                        
                        // Load team data
                        await loadTeamData();
                        return;
                    }
                }
            }
        } catch (membershipError) {
            debugLog('âš ï¸ Could not check userTeamMemberships:', membershipError.message);
        }

        // No teams found - don't auto-create, just log and return
        debugLog('â„¹ï¸ User has no teams. Waiting for user to create or join a team...');
        appState.currentTeamId = null;
        appState.userTeams = [];
        
        // Show the "no team" modal or UI
        const createBtn = document.getElementById('createTeamBtn');
        if (createBtn) {
            createBtn.style.display = 'block';
        }

    } catch (error) {
        console.error('âŒ Error initializing team:', error.code || error.message);
        
        // Show user-friendly error with retry option
        showTeamCreationError();
    }
}

// NEW: Separate function to actually CREATE a team (only called when user clicks Create Team button)
async function createTeamNow() {
    if (!currentAuthUser || !db) {
        console.error('âŒ Cannot create team: User not authenticated or DB not ready');
        showToast('Please sign in and try again.', 'error');
        return;
    }

    try {
        debugLog('ðŸ†• Creating new team...');
        
        const { collection, doc, addDoc, setDoc, serverTimestamp, getDoc, updateDoc, deleteField } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');

        // Use unified identity resolver for consistent name
        const identity = getIdentity(currentAuthUser.uid, currentAuthUser.email?.split('@')[0]);
        
        const teamCode = generateTeamCode();
        const teamName = `${identity.displayName}'s Team`;
        
        const teamData = {
            name: teamName,
            teamCode: teamCode,
            createdBy: currentAuthUser.uid,
            createdAt: serverTimestamp(),
            members: {
                [currentAuthUser.uid]: {
                    role: 'owner',
                    name: identity.displayName,
                    email: currentAuthUser.email,
                    joinedAt: serverTimestamp()
                }
            },
            pendingRequests: {}
        };

        // Create team document
        const teamRef = await addDoc(collection(db, 'teams'), teamData);
        appState.currentTeamId = teamRef.id;
        appState.userTeams = [teamRef.id];

        debugLog('âœ… Created new team:', teamRef.id);
        
        // Create public teamJoinInfo document for join-by-code flow
        // This allows non-members to look up team by code without exposing full team data
        await setDoc(doc(db, 'teamJoinInfo', teamCode), {
            teamId: teamRef.id,
            teamName: teamName,
            memberCount: 1,
            createdAt: serverTimestamp(),
            updatedAt: serverTimestamp()
        });
        debugLog('âœ… Created teamJoinInfo for code:', teamCode);

        // Check if user has old teams and remove them (single team policy)
        const userRef = doc(db, 'users', currentAuthUser.uid);
        const userDoc = await getDoc(userRef);
        
        if (userDoc.exists()) {
            const userData = userDoc.data();
            const oldTeams = userData.teams || [];
            
            // Remove user from old teams first
            for (const oldTeamId of oldTeams) {
                try {
                    const oldTeamRef = doc(db, 'teams', oldTeamId);
                    await updateDoc(oldTeamRef, {
                        [`members.${currentAuthUser.uid}`]: deleteField()
                    });
                    debugLog(`âœ… Left old team: ${oldTeamId}`);
                } catch (error) {
                    console.warn('Could not leave old team:', error);
                }
            }
        }
        
        // Update user document with new team reference
        await setDoc(userRef, {
            email: currentAuthUser.email,
            displayName: identity.displayName,
            teams: [teamRef.id],
            createdAt: serverTimestamp()
        }, { merge: true });

        debugLog('âœ… Team created successfully!');
        
        // Hide create team button since team now exists
        const createBtn = document.getElementById('createTeamBtn');
        if (createBtn) {
            createBtn.style.display = 'none';
        }
        
        // Show success message to user
        showTeamCreatedMessage(teamCode);
        
        // Load team data
        await loadTeamData();
        
        return teamRef.id;
        
    } catch (error) {
        console.error('âŒ Error creating team:', error);
        showToast('Failed to create team. Please try again.', 'error', 5000, 'Team Creation Failed');
        throw error;
    }
}

// Show success message with team code
function showTeamCreatedMessage(teamCode) {
    // Bug fix 4: Prevent duplicate modals
    const existingModal = document.getElementById('teamCreatedModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    const modalHtml = `
        <div class="modal-overlay" id="teamCreatedModal">
            <div class="modal-content" style="max-width: 500px;">
                <div style="text-align: center; padding: 20px;">
                    <div style="font-size: 48px; margin-bottom: 20px;">ðŸŽ‰</div>
                    <h2 style="color: #0078D4; margin-bottom: 10px;">Team Created Successfully!</h2>
                    <p style="color: #666; margin-bottom: 20px;">Your team has been set up and is ready to use.</p>
                    
                    <div style="background-color: #f5f5f5; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                        <p style="margin-bottom: 10px; color: #333; font-weight: 600;">Your Team Code:</p>
                        <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                            <code style="font-size: 24px; font-weight: bold; color: #0078D4; letter-spacing: 2px;">${escapeHtml(teamCode)}</code>
                            <button onclick="copyTeamCodeToClipboard('${escapeHtml(teamCode)}')" style="padding: 8px 15px; background-color: #0078D4; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                ðŸ“‹ Copy
                            </button>
                        </div>
                        <p style="margin-top: 10px; font-size: 12px; color: #666;">Share this code with others to invite them to your team</p>
                    </div>
                    
                    <button onclick="closeTeamCreatedModal()" style="padding: 12px 30px; background-color: #0078D4; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px;">
                        Got it!
                    </button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    
    // Also show a toast notification
    showToast('Your team has been created successfully!', 'success', 5000, 'Team Created ðŸŽ‰');
}

// Close team created modal
function closeTeamCreatedModal() {
    const modal = document.getElementById('teamCreatedModal');
    if (modal) {
        modal.remove();
    }
}

// Copy team code to clipboard
function copyTeamCodeToClipboard(code) {
    navigator.clipboard.writeText(code).then(() => {
        showToast('Team code copied to clipboard!', 'success', 3000, 'Copied');
    }).catch(error => {
        console.error('Failed to copy code:', error);
        showToast('Failed to copy code', 'error', 3000, 'Copy Failed');
    });
}

// Show team creation error with retry option
function showTeamCreationError() {
    showToast('We could not create your team. Open the Team tab and try again.', 'error', 6000, 'Team creation failed');
    const createBtn = document.getElementById('createTeamBtn');
    if (createBtn) {
        createBtn.style.display = 'block';
        createBtn.focus();
    }
}

// Manual team creation (can be triggered from button)
async function createNewTeamNow() {
    if (!currentAuthUser) {
        showToast('Please sign in first', 'error');
        return;
    }
    
    if (!db) {
        showToast('Database not initialized. Please refresh the page.', 'error');
        return;
    }
    
    // Show loading state on button
    const createBtn = document.getElementById('createTeamBtn');
    if (createBtn) {
        createBtn.disabled = true;
        createBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> <span>Creating Team...</span>';
    }
    
    debugLog('ðŸš€ Manual team creation triggered');
    
    try {
        await createTeamNow(); // Call the new dedicated function
    } catch (error) {
        console.error('Failed to create team:', error.code || error.message);
        debugError('Full error:', error);
    } finally {
        // Restore button state
        if (createBtn) {
            createBtn.disabled = false;
            createBtn.innerHTML = '<i class="fas fa-plus-circle"></i> <span>Create New Team</span>';
        }
    }
}

// Load all team data (tasks, messages, events, members)
async function loadTeamData() {
    if (!db || !currentAuthUser || !appState.currentTeamId) return;

    // Reset reply state when loading new team data
    if (typeof resetReplyState === 'function') {
        resetReplyState();
    }

    try {
        // Verify membership server-side - prevents manually switching currentTeamId via DevTools
        const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        const teamRef = doc(db, "teams", appState.currentTeamId);
        const teamSnap = await getDoc(teamRef);
        
        if (!teamSnap.exists()) {
            showToast("Team does not exist or you do not have permission.", 'error', 5000, 'Access Denied');
            console.error('Team does not exist');
            debugError('Team ID:', appState.currentTeamId);
            return;
        }
        
        const teamData = teamSnap.data();
        if (!teamData.members || !teamData.members[currentAuthUser.uid]) {
            showToast("You are not a member of this team.", 'error', 5000, 'Access Denied');
            console.error('User is not a member of team');
            debugError('Team ID:', appState.currentTeamId);
            return;
        }
        
        // Store team data for later use and compute metrics access
        appState.currentTeamData = teamData;
        appState.metricsVisibility = getMetricsVisibilitySetting(teamData);
        appState.metricsAccess = userCanViewMetrics(teamData, currentAuthUser.uid);
        debugLog('ðŸ“Š Metrics visibility:', appState.metricsVisibility);
        debugLog('ðŸ“Š Metrics access:', appState.metricsAccess);
        
        // Compute finances access
        appState.financesEnabled = getFinancesEnabledSetting(teamData);
        appState.financesVisibility = getFinancesVisibilitySetting(teamData);
        appState.financesAccess = userCanViewFinances(teamData, currentAuthUser.uid);
        debugLog('ðŸ’° Finances enabled:', appState.financesEnabled);
        debugLog('ðŸ’° Finances visibility:', appState.financesVisibility);
        debugLog('ðŸ’° Finances access:', appState.financesAccess);
        
        // Load public profiles for all team members (for identity resolution)
        await loadPublicProfilesForTeam();
        
        // Load metrics chart configuration from team settings
        loadMetricsChartConfig(appState.currentTeamId);
        
        // Update nav visibility for metrics
        updateNavVisibilityForMetrics();
        
        // Update nav visibility for finances
        updateNavVisibilityForFinances();
        
        debugLog('âœ… Membership verified for team:', appState.currentTeamId);
    } catch (error) {
        console.error('Error verifying team membership:', error.code || error.message);
        debugError('Full error:', error);
        showToast("Failed to verify team access.", 'error', 5000, 'Verification Failed');
        return;
    }

    // Clear previous team's data to prevent cross-contamination between users/teams
    appState.messages = [];
    appState.tasks = [];
    appState.events = [];
    appState.activities = [];
    appState.teammates = [];
    appState.spreadsheets = [];
    
    // Stop previous team's listeners
    stopTeamMembersListener();
    
    // Clear chat display immediately
    const chatMessages = document.getElementById('chatMessages');
    if (chatMessages) chatMessages.innerHTML = '';

    try {
        // Load teammates
        await loadTeammatesFromFirestore();
        
        // Start real-time listener for team member updates
        await startTeamMembersListener();
        
        // Populate task assignee dropdown with team members
        populateTaskAssigneeDropdown();
        
        // Clean up old tasks from localStorage
        await cleanupOldTasks();
        
        // Load tasks
        await loadTasksFromFirestore();
        
        // Load spreadsheets
        if (window.loadSpreadsheetsFromFirestore) {
            await window.loadSpreadsheetsFromFirestore();
        }
        
        // Clean up docs state from previous team and load docs for new team
        if (window.cleanupDocsState) {
            window.cleanupDocsState();
        }
        // Only load docs if we're in docs view (lazy loading)
        if (appState.tasksViewMode === 'docs' && window.loadDocsFromFirestore) {
            await window.loadDocsFromFirestore();
        }
        
        // Load messages
        await loadMessagesFromFirestore();
        
        // Load events
        await loadEventsFromFirestore();
        
        // Load activities
        await loadActivities();
        
        // Subscribe to Link Lobby groups
        await subscribeLinkLobbyGroups();
        
        // Ensure teamJoinInfo exists for join-by-code (for admins/owners)
        await ensureTeamJoinInfoExists();
        
        // Initialize team section display
        await initTeamSection();

        debugLog('Team data loaded successfully');
    } catch (error) {
        console.error('Error loading team data:', error.code || error.message);
        debugError('Full error:', error);
    }
}

/**
 * Ensure teamJoinInfo document exists for the current team
 * This is needed for the join-by-code flow to work with the new security model
 * Only admins/owners can create/update this document
 */
async function ensureTeamJoinInfoExists() {
    if (!db || !currentAuthUser || !appState.currentTeamId || !appState.currentTeamData) return;
    
    // Only admins/owners should ensure this exists
    const teamData = appState.currentTeamData;
    const userRole = teamData.members?.[currentAuthUser.uid]?.role;
    if (!userRole || !['owner', 'admin'].includes(userRole)) return;
    
    const teamCode = teamData.teamCode;
    if (!teamCode) return;
    
    try {
        const { doc, getDoc, setDoc, serverTimestamp } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const joinInfoRef = doc(db, 'teamJoinInfo', teamCode);
        const joinInfoDoc = await getDoc(joinInfoRef);
        
        if (!joinInfoDoc.exists()) {
            // Create the teamJoinInfo document
            const memberCount = Object.keys(teamData.members || {}).length;
            await setDoc(joinInfoRef, {
                teamId: appState.currentTeamId,
                teamName: teamData.name || 'Team',
                memberCount: memberCount,
                createdAt: serverTimestamp(),
                updatedAt: serverTimestamp()
            });
            debugLog('âœ… Created teamJoinInfo for code:', teamCode);
        } else {
            // Update member count if needed
            const joinInfo = joinInfoDoc.data();
            const currentMemberCount = Object.keys(teamData.members || {}).length;
            if (joinInfo.memberCount !== currentMemberCount || joinInfo.teamName !== teamData.name) {
                await setDoc(joinInfoRef, {
                    teamId: appState.currentTeamId,
                    teamName: teamData.name || 'Team',
                    memberCount: currentMemberCount,
                    updatedAt: serverTimestamp()
                }, { merge: true });
                debugLog('âœ… Updated teamJoinInfo for code:', teamCode);
            }
        }
    } catch (error) {
        // Non-critical - just log
        debugLog('Could not sync teamJoinInfo:', error.message);
    }
}

function initTeam() {
    // Load teammates from storage
    loadTeammates();
    
    // Update pending requests badge periodically
    updatePendingRequestsBadge();
    setInterval(updatePendingRequestsBadge, 30000); // Update every 30 seconds
}

// Update pending requests badge
async function updatePendingRequestsBadge() {
    const count = await getPendingRequestsCount();
    const badge = document.getElementById('pendingRequestsBadge');
    
    if (badge) {
        if (count > 0) {
            badge.textContent = count;
            badge.style.display = 'flex';
        } else {
            badge.style.display = 'none';
        }
    }
}

async function loadTeammates() {
    // Clear any old placeholder data
    localStorage.removeItem('teammates');
    
    // Only load real teammates from Firestore
    if (db && currentAuthUser && appState.currentTeamId) {
        await loadTeammatesFromFirestore();
    } else {
        // No team or not authenticated - show empty state
        appState.teammates = [];
        displayTeammates();
    }
}

function displayTeammates() {
    const teamList = document.getElementById('teamList');
    if (!teamList) return;
    
    teamList.innerHTML = '';
    
    if (!appState.teammates || appState.teammates.length === 0) {
        teamList.innerHTML = '<p style="text-align: center; color: var(--gray); font-size: 0.85rem; padding: var(--spacing-md);">No team members yet. Add your first teammate!</p>';
        return;
    }
    
    appState.teammates.forEach(teammate => {
        const teammateCard = createTeammateCard(teammate);
        teamList.appendChild(teammateCard);
    });
}

function createTeammateCard(teammate) {
    const card = document.createElement('div');
    card.className = 'teammate-card';
    card.title = `${teammate.name} - ${teammate.email}`;
    
    // Create avatar element
    const avatarDiv = document.createElement('div');
    avatarDiv.className = 'teammate-avatar';
    avatarDiv.textContent = teammate.avatar; // Use textContent for avatar initials
    
    // Create info container
    const infoDiv = document.createElement('div');
    infoDiv.className = 'teammate-info';
    
    const nameDiv = document.createElement('div');
    nameDiv.className = 'teammate-name';
    nameDiv.textContent = teammate.name; // Use textContent for name
    
    // Create occupation and role container
    const occupationDiv = document.createElement('div');
    occupationDiv.className = 'teammate-occupation';
    
    // Add occupation text if available, otherwise just show role
    if (teammate.occupation && teammate.occupation !== 'member' && teammate.occupation !== 'admin' && teammate.occupation !== 'owner') {
        const occupationText = document.createTextNode(teammate.occupation);
        occupationDiv.appendChild(occupationText);
        occupationDiv.appendChild(document.createTextNode(' â€¢ '));
    }
    
    // Add role badge
    const role = teammate.role || 'member';
    const roleBadge = document.createElement('span');
    roleBadge.className = `role-badge ${role}`;
    roleBadge.textContent = role.toUpperCase(); // Use textContent for role
    occupationDiv.appendChild(roleBadge);
    
    infoDiv.appendChild(nameDiv);
    infoDiv.appendChild(occupationDiv);
    
    card.appendChild(avatarDiv);
    card.appendChild(infoDiv);
    
    // Optional: Add click event to show teammate details
    card.addEventListener('click', () => {
        if (DEBUG) console.log('Teammate details logged');
        // Could open a modal with full teammate info
    });
    
    return card;
}

function generateAvatar(name) {
    if (!name) return '??';
    
    const parts = name.trim().split(' ');
    if (parts.length >= 2) {
        return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
    } else {
        return name.substring(0, 2).toUpperCase();
    }
}

/**
 * Generate unique team code with high entropy
 * 
 * SECURITY: Team codes are used for the join flow and should be hard to guess.
 * We use 12 characters from a 54-character alphabet (mixed case + digits, minus confusing chars)
 * This provides approximately 70 bits of entropy (54^12 â‰ˆ 2^70)
 * 
 * NOTE: Rate limiting for brute-force protection requires Cloud Functions or App Check.
 * Firestore rules cannot enforce rate limits on teamJoinInfo reads.
 * 
 * @returns {string} Team code in format "TM-XXXXXXXXXXXX" (12 random chars)
 */
function generateTeamCode() {
    // Mixed case alphanumeric, removed confusing chars: 0, O, o, I, l, 1
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz23456789';
    let code = 'TM-';
    
    // Use crypto.getRandomValues for better randomness
    const randomValues = new Uint8Array(12);
    crypto.getRandomValues(randomValues);
    
    for (let i = 0; i < 12; i++) {
        code += chars.charAt(randomValues[i] % chars.length);
    }
    return code;
}

// Show team code to owner
async function showTeamCode() {
    if (!currentAuthUser) {
        showToast('Please sign in first.', 'error');
        return;
    }

    if (!db || !appState.currentTeamId) {
        // Team not initialized, show options
        showNoTeamModal();
        return;
    }

    try {
        const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const teamRef = doc(db, 'teams', appState.currentTeamId);
        const teamDoc = await getDoc(teamRef);
        
        if (!teamDoc.exists()) {
            console.error('Team document not found');
            debugError('Team ID:', appState.currentTeamId);
            showNoTeamModal();
            return;
        }
        
        const teamData = teamDoc.data();
        const teamCode = teamData.teamCode;
        
        // Create modal
        const existingModal = document.getElementById('teamCodeModal');
        if (existingModal) {
            existingModal.remove();
        }
        
        const modal = document.createElement('div');
        modal.id = 'teamCodeModal';
        modal.className = 'modal active';
        modal.innerHTML = `
            <div class="modal-content" style="max-width: 500px;">
                <div class="modal-header">
                    <h2>Your Team Code</h2>
                    <span class="modal-close" onclick="closeTeamCodeModal()">&times;</span>
                </div>
                <div class="modal-body">
                    <p style="margin-bottom: 15px; color: #495057;">Share this code with people you want to join your team:</p>
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px; text-align: center;">
                        <div style="font-size: 32px; font-weight: bold; letter-spacing: 4px; color: #0078D4; font-family: monospace;">
                            ${escapeHtml(teamCode)}
                        </div>
                        <button onclick="copyTeamCode('${escapeHtml(teamCode)}')" class="btn btn-primary" style="margin-top: 15px;">
                            <i class="fas fa-copy"></i> Copy Code
                        </button>
                    </div>
                    <div style="background: #e7f3ff; padding: 15px; border-radius: 8px; border-left: 4px solid #0078D4;">
                        <p style="margin: 0; color: #004085; font-size: 0.9rem;">
                            <strong>ðŸ’¡ How it works:</strong><br>
                            1. Share this code with someone<br>
                            2. They click "Join Team" and enter the code<br>
                            3. You approve their request<br>
                            4. They join your team!
                        </p>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" onclick="closeTeamCodeModal()">Done</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
    } catch (error) {
        console.error('Error showing team code:', error.code || error.message);
        debugError('Full error:', error);
        showToast('Failed to load team code.', 'error');
    }
}

// Show modal when no team exists
function showNoTeamModal() {
    const modalHtml = `
        <div class="modal-overlay" id="noTeamModal">
            <div class="modal-content" style="max-width: 500px;">
                <div style="text-align: center; padding: 20px;">
                    <div style="font-size: 48px; margin-bottom: 20px;">ðŸš€</div>
                    <h2 style="color: #0078D4; margin-bottom: 10px;">No Team Found</h2>
                    <p style="color: #666; margin-bottom: 30px;">You don't have a team yet. Would you like to create one or join an existing team?</p>
                    
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button onclick="createNewTeamFromModal()" style="padding: 15px 30px; background-color: #0078D4; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; font-weight: 600;">
                            âœ¨ Create a New Team
                        </button>
                        <button onclick="joinTeamFromModal()" style="padding: 15px 30px; background-color: #f5f5f5; color: #333; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; font-weight: 600;">
                            âž¡ï¸ Join an Existing Team
                        </button>
                        <button onclick="closeNoTeamModal()" style="padding: 10px 20px; background-color: transparent; color: #666; border: none; cursor: pointer; font-size: 14px;">
                            Cancel
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

// Close no team modal
function closeNoTeamModal() {
    const modal = document.getElementById('noTeamModal');
    if (modal) {
        modal.remove();
    }
}

// Create team from modal
async function createNewTeamFromModal() {
    closeNoTeamModal();
    await createNewTeamNow();
}

// Join team from modal
function joinTeamFromModal() {
    closeNoTeamModal();
    joinTeamWithCode();
}

// Copy team code
window.copyTeamCode = function(code) {
    const textarea = document.createElement('textarea');
    textarea.value = code;
    document.body.appendChild(textarea);
    textarea.select();
    
    try {
        document.execCommand('copy');
        const btn = event.target.closest('button');
        const originalHTML = btn.innerHTML;
        btn.innerHTML = '<i class="fas fa-check"></i> Copied!';
        btn.style.background = '#28a745';
        
        setTimeout(() => {
            btn.innerHTML = originalHTML;
            btn.style.background = '';
        }, 2000);
    } catch (err) {
        showToast('Code: ' + code, 'info', 8000);
    }
    
    document.body.removeChild(textarea);
}

// Close team code modal
window.closeTeamCodeModal = function() {
    const modal = document.getElementById('teamCodeModal');
    if (modal) {
        modal.remove();
    }
}

// Join team with code
async function joinTeamWithCode() {
    // Create modal
    const existingModal = document.getElementById('joinTeamModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    const modal = document.createElement('div');
    modal.id = 'joinTeamModal';
    modal.className = 'modal active';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2><i class="fas fa-sign-in-alt"></i> Join a Team</h2>
                <span class="modal-close" onclick="closeJoinTeamModal()">&times;</span>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 15px; color: #495057;">Enter the team code you received:</p>
                <form id="joinTeamForm">
                    <div class="form-group">
                        <label for="teamCodeInput">Team Code</label>
                        <input 
                            type="text" 
                            id="teamCodeInput" 
                            placeholder="TEAM-XXXXXX"
                            style="text-transform: uppercase; letter-spacing: 2px; font-family: monospace; font-size: 18px;"
                            required
                        >
                    </div>
                    <div style="background: #fff3cd; padding: 12px; border-radius: 6px; margin: 15px 0; border-left: 4px solid #ffc107;">
                        <p style="margin: 0; color: #856404; font-size: 0.85rem;">
                            <i class="fas fa-info-circle"></i> The team owner will need to approve your request before you can join.
                        </p>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeJoinTeamModal()">Cancel</button>
                <button class="btn btn-primary" onclick="submitJoinRequest()">
                    <i class="fas fa-paper-plane"></i> Send Join Request
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Focus input
    setTimeout(() => {
        document.getElementById('teamCodeInput').focus();
    }, 100);
}

// Close join team modal
window.closeJoinTeamModal = function() {
    const modal = document.getElementById('joinTeamModal');
    if (modal) {
        modal.remove();
    }
}

// Generate shareable join link
window.generateJoinLink = function() {
    if (!appState.currentTeamData?.teamCode) {
        showToast('No team code available', 'error');
        return;
    }
    const baseUrl = window.location.origin;
    const joinUrl = `${baseUrl}/app?join=${appState.currentTeamData.teamCode}`;
    
    navigator.clipboard.writeText(joinUrl).then(() => {
        showToast('Join link copied to clipboard!', 'success');
    }).catch(() => {
        // Fallback - show the link in a toast with longer duration
        showToast('Copy this join link: ' + joinUrl, 'info', 10000);
    });
}

// Process join code from URL
async function processJoinCode(teamCode) {
    if (!currentAuthUser) {
        showToast('Please sign in first', 'error');
        return;
    }
    
    showToast('Processing join request...', 'info');
    
    try {
        const { doc, getDoc, updateDoc, serverTimestamp } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');

        // Look up team by code via teamJoinInfo (public collection)
        const normalizedCode = teamCode.toUpperCase().trim();
        const joinInfoRef = doc(db, 'teamJoinInfo', normalizedCode);
        const joinInfoDoc = await getDoc(joinInfoRef);

        if (!joinInfoDoc.exists()) {
            showToast('Invalid join link. Team not found.', 'error');
            return;
        }

        const joinInfo = joinInfoDoc.data();
        const teamId = joinInfo.teamId;
        const teamName = joinInfo.teamName;

        // Show confirmation dialog (we don't read team doc - use joinInfo instead)
        const confirmJoin = await showConfirmModal(
            `You've been invited to join "${teamName}"! Click Confirm to send a join request to the team owner.`,
            {
                title: 'Join Team',
                confirmText: 'Send Request'
            }
        );
        
        if (!confirmJoin) return;

        // Add join request to subcollection (prevents DoS via map growth)
        // Uses /teams/{teamId}/joinRequests/{userId} instead of deprecated pendingRequests map
        const { setDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        // Use unified identity resolver for consistent name
        const identity = getIdentity(currentAuthUser.uid, currentAuthUser.email?.split('@')[0]);
        
        const joinRequestRef = doc(db, 'teams', teamId, 'joinRequests', currentAuthUser.uid);
        await setDoc(joinRequestRef, {
            userId: currentAuthUser.uid,
            name: identity.displayName,
            email: currentAuthUser.email,
            photoURL: currentAuthUser.photoURL || null,
            requestedAt: serverTimestamp(),
            status: 'pending'
        });
        
        showToast(`Join request sent to "${teamName}"! The owner will review it.`, 'success');

    } catch (error) {
        console.error('Error processing join code:', error);
        if (error.code === 'permission-denied') {
            showToast('Unable to send join request. You may already be a member or have a pending request.', 'error');
        } else {
            showToast('Failed to process join link. Please try again.', 'error');
        }
    }
}

// Submit join request
window.submitJoinRequest = async function() {
    if (!currentAuthUser) {
        showToast('Please sign in first.', 'error');
        return;
    }

    // Check if user is already in a team
    if (appState.currentTeamId && appState.userTeams && appState.userTeams.length > 0) {
        const confirmLeave = await showConfirmModal(
            'You are already in a team. Joining a new team will remove you from your current team. Do you want to continue?',
            {
                title: 'Leave Current Team',
                confirmText: 'Continue',
                type: 'danger'
            }
        );
        if (!confirmLeave) {
            closeJoinTeamModal();
            return;
        }
    }

    const teamCodeInput = document.getElementById('teamCodeInput');
    const teamCode = teamCodeInput.value.trim().toUpperCase();
    
    if (!teamCode) {
        showToast('Please enter a team code.', 'warning');
        return;
    }

    const submitBtn = event.target.closest('button');
    const originalHTML = submitBtn.innerHTML;
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Sending...';

    try {
        const { doc, getDoc, setDoc, serverTimestamp } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');

        // Look up team by code via teamJoinInfo (public collection)
        const joinInfoRef = doc(db, 'teamJoinInfo', teamCode);
        const joinInfoDoc = await getDoc(joinInfoRef);

        if (!joinInfoDoc.exists()) {
            showToast('Team code not found. Please check and try again.', 'error', 5000, 'Invalid Code');
            submitBtn.disabled = false;
            submitBtn.innerHTML = originalHTML;
            return;
        }

        const joinInfo = joinInfoDoc.data();
        const teamId = joinInfo.teamId;
        const teamName = joinInfo.teamName;

        // Add join request to subcollection (prevents DoS via map growth)
        // Uses /teams/{teamId}/joinRequests/{userId} instead of deprecated pendingRequests map
        
        // Use unified identity resolver for consistent name
        const identity = getIdentity(currentAuthUser.uid, currentAuthUser.email?.split('@')[0]);
        
        const joinRequestRef = doc(db, 'teams', teamId, 'joinRequests', currentAuthUser.uid);
        await setDoc(joinRequestRef, {
            userId: currentAuthUser.uid,
            name: identity.displayName,
            email: currentAuthUser.email,
            photoURL: currentAuthUser.photoURL || null,
            requestedAt: serverTimestamp(),
            status: 'pending'
        });

        debugLog('âœ… Join request sent');
        
        closeJoinTeamModal();
        
        // Show success message
        showToast(`Join request sent to "${teamName}". The team owner will review your request.`, 'success', 5000, 'Request Sent');

    } catch (error) {
        console.error('Error sending join request:', error.code || error.message);
        debugError('Full error:', error);
        
        if (error.code === 'permission-denied') {
            // This might happen if they're already a member or have a pending request
            showToast('Unable to send request. You may already be a member or have a pending request.', 'error', 5000, 'Request Failed');
        } else {
            showToast('Failed to send join request. Please try again.', 'error', 5000, 'Request Failed');
        }
        
        submitBtn.disabled = false;
        submitBtn.innerHTML = originalHTML;
    }
}

// Show pending join requests (for team owner)
async function showPendingRequests() {
    if (!db || !currentAuthUser || !appState.currentTeamId) {
        showToast('Team not initialized.', 'error');
        return;
    }

    try {
        const { collection, getDocs, query, where } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        // Read from joinRequests subcollection instead of deprecated pendingRequests map
        const joinRequestsRef = collection(db, 'teams', appState.currentTeamId, 'joinRequests');
        const pendingQuery = query(joinRequestsRef, where('status', '==', 'pending'));
        const snapshot = await getDocs(pendingQuery);
        
        const requestsList = [];
        snapshot.forEach(doc => {
            requestsList.push({ id: doc.id, ...doc.data() });
        });

        if (requestsList.length === 0) {
            showToast('No pending join requests.', 'info');
            return;
        }

        // Create modal
        const existingModal = document.getElementById('pendingRequestsModal');
        if (existingModal) {
            existingModal.remove();
        }
        
        const modal = document.createElement('div');
        modal.id = 'pendingRequestsModal';
        modal.className = 'modal active';
        
        let requestsHTML = '';
        requestsList.forEach((request) => {
            const userId = request.id;
            requestsHTML += `
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="font-weight: 600; color: #333; margin-bottom: 4px;">
                            <i class="fas fa-user"></i> ${escapeHtml(request.name)}
                        </div>
                        <div style="font-size: 0.85rem; color: #666;">
                            <i class="fas fa-envelope"></i> ${escapeHtml(request.email)}
                        </div>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button onclick="approveJoinRequest('${escapeHtml(userId)}')" class="btn btn-primary" style="padding: 8px 16px;">
                            <i class="fas fa-check"></i> Approve
                        </button>
                        <button onclick="rejectJoinRequest('${escapeHtml(userId)}')" class="btn btn-secondary" style="padding: 8px 16px;">
                            <i class="fas fa-times"></i> Reject
                        </button>
                    </div>
                </div>
            `;
        });
        
        modal.innerHTML = `
            <div class="modal-content" style="max-width: 600px;">
                <div class="modal-header">
                    <h2><i class="fas fa-user-clock"></i> Pending Join Requests</h2>
                    <span class="modal-close" onclick="closePendingRequestsModal()">&times;</span>
                </div>
                <div class="modal-body">
                    <p style="margin-bottom: 15px; color: #495057;">
                        ${requestsList.length} ${requestsList.length === 1 ? 'person wants' : 'people want'} to join your team:
                    </p>
                    ${requestsHTML}
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" onclick="closePendingRequestsModal()">Close</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
    } catch (error) {
        console.error('Error loading pending requests:', error.code || error.message);
        debugError('Full error:', error);
        showToast('Failed to load pending requests.', 'error');
    }
}

// Close pending requests modal
window.closePendingRequestsModal = function() {
    const modal = document.getElementById('pendingRequestsModal');
    if (modal) {
        modal.remove();
    }
}

// Show approve join modal
window.showApproveJoinModal = function(userId, userName, userEmail) {
    const nameEl = document.getElementById('approveJoinName');
    const emailEl = document.getElementById('approveJoinEmail');
    const confirmBtn = document.getElementById('confirmApproveJoin');
    
    if (nameEl) nameEl.textContent = userName || 'this user';
    if (emailEl) emailEl.textContent = userEmail || '';
    
    // Store the userId for the confirm action
    if (confirmBtn) {
        confirmBtn.onclick = () => executeApproveJoinRequest(userId);
    }
    
    document.getElementById('approveJoinModal')?.classList.add('active');
};

window.closeApproveJoinModal = function() {
    document.getElementById('approveJoinModal')?.classList.remove('active');
};

// Approve join request (admin/owner only) - shows modal
window.approveJoinRequest = async function(userId) {
    try {
        const { doc, getDoc } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');

        // Check if user has admin permissions
        const teamRef = doc(db, 'teams', appState.currentTeamId);
        const teamDoc = await getDoc(teamRef);
        const teamData = teamDoc.data();
        
        if (!isAdmin(teamData)) {
            showToast('Only admins and owners can approve join requests.', 'error');
            return;
        }
        
        // Read from joinRequests subcollection
        const joinRequestRef = doc(db, 'teams', appState.currentTeamId, 'joinRequests', userId);
        const requestDoc = await getDoc(joinRequestRef);
        
        if (!requestDoc.exists()) {
            showToast('Join request not found.', 'error');
            return;
        }
        
        const request = requestDoc.data();
        
        // Show the approval modal
        showApproveJoinModal(userId, request.name, request.email);
        
    } catch (error) {
        console.error('Error checking join request:', error);
        showToast('Failed to load request details.', 'error');
    }
};

// Execute the actual approval after modal confirmation
async function executeApproveJoinRequest(userId) {
    try {
        const { doc, getDoc, updateDoc, deleteDoc, setDoc, serverTimestamp } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');

        const teamRef = doc(db, 'teams', appState.currentTeamId);
        const teamDoc = await getDoc(teamRef);
        const teamData = teamDoc.data();

        // Read from joinRequests subcollection
        const joinRequestRef = doc(db, 'teams', appState.currentTeamId, 'joinRequests', userId);
        const requestDoc = await getDoc(joinRequestRef);
        
        if (!requestDoc.exists()) {
            showToast('Join request not found.', 'error');
            closeApproveJoinModal();
            return;
        }
        
        const request = requestDoc.data();

        // Check for duplicate usernames and generate unique name if needed
        let finalName = request.name;
        const existingMembers = teamData.members || {};
        const existingNames = Object.values(existingMembers).map(m => (m.name || '').trim().toLowerCase());
        
        // If name already exists, append (1), (2), etc.
        if (existingNames.includes(finalName.trim().toLowerCase())) {
            let counter = 1;
            let newName = `${request.name} (${counter})`;
            while (existingNames.includes(newName.trim().toLowerCase())) {
                counter++;
                newName = `${request.name} (${counter})`;
            }
            finalName = newName;
            debugLog(`ðŸ“ Duplicate name detected - renamed "${request.name}" to "${finalName}"`);
        }

        // Add user to members
        await updateDoc(teamRef, {
            [`members.${userId}`]: {
                role: 'member',
                name: finalName,
                email: request.email,
                photoURL: request.photoURL || null,
                occupation: 'Team Member',
                joinedAt: serverTimestamp()
            }
        });
        
        // CRITICAL: Write to userTeamMemberships so the approved user can find their team
        // This solves the permission-denied issue when scanning for teams
        const membershipRef = doc(db, 'userTeamMemberships', userId);
        await setDoc(membershipRef, {
            teamId: appState.currentTeamId,
            teamName: teamData.name || teamData.teamName || 'Team',
            role: 'member',
            approvedAt: serverTimestamp(),
            approvedBy: currentAuthUser.uid
        });
        debugLog('âœ… Created userTeamMemberships record for:', userId);
        
        // Delete the join request from subcollection
        await deleteDoc(joinRequestRef);

        debugLog('âœ… Approved join request - user added to team members');
        
        // Add activity log for approval
        await addActivity({
            type: 'team',
            description: `approved ${finalName} to join the team`
        });
        
        // Reload team data
        await loadTeammatesFromFirestore();
        await initTeamSection();
        
        // Close modals
        closeApproveJoinModal();
        closePendingRequestsModal();
        
        // Show success message - mention if name was changed
        if (finalName !== request.name) {
            showToast(`${finalName} has been added to your team! (Name adjusted to avoid duplicate)`, 'success', 5000, 'Member Added');
        } else {
            showToast(`${finalName} has been added to your team!`, 'success', 4000, 'Member Added');
        }

    } catch (error) {
        console.error('Error approving request:', error.code || error.message);
        debugError('Full error:', error);
        closeApproveJoinModal();
        showToast('Failed to approve request. Please try again.', 'error', 5000, 'Approval Failed');
    }
}

// Show reject join modal
window.showRejectJoinModal = function(userId, userName, userEmail) {
    const nameEl = document.getElementById('rejectJoinName');
    const emailEl = document.getElementById('rejectJoinEmail');
    const confirmBtn = document.getElementById('confirmRejectJoin');
    
    if (nameEl) nameEl.textContent = userName || 'this user';
    if (emailEl) emailEl.textContent = userEmail || '';
    
    // Store the userId for the confirm action
    if (confirmBtn) {
        confirmBtn.onclick = () => executeRejectJoinRequest(userId);
    }
    
    document.getElementById('rejectJoinModal')?.classList.add('active');
};

window.closeRejectJoinModal = function() {
    document.getElementById('rejectJoinModal')?.classList.remove('active');
};

// Reject join request (shows modal)
window.rejectJoinRequest = async function(userId) {
    try {
        const { doc, getDoc } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');

        // Read from joinRequests subcollection
        const joinRequestRef = doc(db, 'teams', appState.currentTeamId, 'joinRequests', userId);
        const requestDoc = await getDoc(joinRequestRef);
        
        if (!requestDoc.exists()) {
            showToast('Join request not found.', 'error');
            return;
        }
        
        const request = requestDoc.data();
        
        // Show the reject modal
        showRejectJoinModal(userId, request.name, request.email);
        
    } catch (error) {
        console.error('Error checking join request:', error);
        showToast('Failed to load request details.', 'error');
    }
};

// Execute the actual rejection after modal confirmation
async function executeRejectJoinRequest(userId) {
    try {
        const { doc, getDoc, deleteDoc } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');

        // Read and delete from joinRequests subcollection
        const joinRequestRef = doc(db, 'teams', appState.currentTeamId, 'joinRequests', userId);
        const requestDoc = await getDoc(joinRequestRef);
        const request = requestDoc.exists() ? requestDoc.data() : null;
        
        await deleteDoc(joinRequestRef);

        debugLog('âŒ Rejected join request');
        
        // Add activity log for rejection
        await addActivity({
            type: 'team',
            description: `rejected join request from ${request?.name || 'a user'}`
        });
        
        // Close modals
        closeRejectJoinModal();
        closePendingRequestsModal();
        showToast('Join request rejected.', 'info');

    } catch (error) {
        console.error('Error rejecting request:', error.code || error.message);
        debugError('Full error:', error);
        closeRejectJoinModal();
        showToast('Failed to reject request. Please try again.', 'error');
    }
}

// Check for pending requests count
// SECURITY: Only admins/owners can query joinRequests - regular members will get permission-denied
async function getPendingRequestsCount() {
    if (!db || !currentAuthUser || !appState.currentTeamId) return 0;
    
    // Check user role first - only admins/owners can read join requests
    const teamData = appState.currentTeamData;
    if (!teamData) return 0;
    
    const userRole = getCurrentUserRole(teamData);
    if (userRole !== 'admin' && userRole !== 'owner') {
        // Non-admin users cannot query joinRequests - return 0 silently
        return 0;
    }

    try {
        const { collection, getDocs, query, where } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        // Read from joinRequests subcollection
        const joinRequestsRef = collection(db, 'teams', appState.currentTeamId, 'joinRequests');
        const pendingQuery = query(joinRequestsRef, where('status', '==', 'pending'));
        const snapshot = await getDocs(pendingQuery);
        
        return snapshot.size;
    } catch (error) {
        console.error('Error getting pending requests count:', error.code || error.message);
        debugError('Full error:', error);
        return 0;
    }
}

// Firestore integration for teammates
async function sendTeamInvitation(invitedEmail, invitedName, occupation) {
    if (!db || !currentAuthUser || !appState.currentTeamId) {
        throw new Error('Please sign in to invite team members');
    }

    try {
        const { collection, addDoc, doc, getDoc, serverTimestamp } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');

        // Get team info to check permissions
        const teamRef = doc(db, 'teams', appState.currentTeamId);
        const teamDoc = await getDoc(teamRef);
        
        if (!teamDoc.exists()) {
            throw new Error('Team not found');
        }
        
        const teamData = teamDoc.data();
        
        // Check if user has admin permissions
        if (!isAdmin(teamData)) {
            throw new Error('Only admins and owners can send invitations');
        }

        // Check rate limits AFTER permission check
        await checkInvitationRateLimits(invitedEmail);

        // Generate unique invitation token
        const invitationToken = generateInvitationToken();
        
        // Use unified identity resolver for consistent name
        const identity = getIdentity(currentAuthUser.uid, currentAuthUser.email?.split('@')[0]);

        // Create invitation document
        const invitationRef = await addDoc(collection(db, 'teamInvitations'), {
            teamId: appState.currentTeamId,
            teamName: teamData.name,
            invitedEmail: invitedEmail.toLowerCase(),
            invitedName: invitedName || '',
            occupation: occupation || '',
            invitedBy: currentAuthUser.uid,
            invitedByName: identity.displayName,
            invitedByEmail: currentAuthUser.email,
            status: 'pending',
            token: invitationToken,
            createdAt: serverTimestamp(),
            expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
        });

        debugLog('âœ… Invitation created successfully:', invitationRef.id);

        // Generate invite link
        const inviteLink = `${window.location.origin}/accept-invitation.html?token=${invitationToken}&id=${invitationRef.id}`;
        
        // Show the invite link to the user
        showInviteLink(inviteLink, invitedEmail, invitedName);

        return invitationRef.id;
    } catch (error) {
        console.error('âŒ Error creating invitation:', error.code || error.message);
        debugError('Full error:', error);
        throw error;
    }
}

// Generate cryptographically secure invitation token
// Uses crypto.getRandomValues() for high entropy (256 bits)
function generateInvitationToken() {
    // Generate 32 random bytes (256 bits of entropy)
    const randomBytes = new Uint8Array(32);
    crypto.getRandomValues(randomBytes);
    
    // Convert to hex string (64 characters)
    const hex = Array.from(randomBytes)
        .map(b => b.toString(16).padStart(2, '0'))
        .join('');
    
    // Return with prefix for easy identification (total = 68 chars, well above 32 minimum)
    return `inv_${hex}`;
}

// Generic secure token generator for any security-sensitive use
function generateSecureToken(bytes = 32) {
    const arr = new Uint8Array(bytes);
    crypto.getRandomValues(arr);
    return Array.from(arr).map(b => b.toString(16).padStart(2, '0')).join('');
}

/**
 * Sync public profile data for teammate visibility
 * This creates/updates the publicProfiles/{userId} document with limited fields
 * that other authenticated users can read (for teammate displays, assignees, etc.)
 * 
 * SECURITY: Email is NOT stored in publicProfiles to prevent cross-team scraping.
 * Email is available via team members map for users in the same team.
 * 
 * @param {Object} profileData - Profile data to sync
 * @param {string} profileData.displayName - User's display name
 * @param {string|null} profileData.photoURL - User's avatar URL
 * @param {string|null} profileData.occupation - User's job title/occupation
 */
async function syncPublicProfile(profileData) {
    if (!db || !currentAuthUser) {
        debugLog('Cannot sync public profile: not authenticated');
        return;
    }
    
    const path = `publicProfiles/${currentAuthUser.uid}`;
    
    try {
        const { doc, setDoc, updateDoc, getDoc, serverTimestamp, deleteField } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const publicProfileRef = doc(db, 'publicProfiles', currentAuthUser.uid);
        
        // SECURITY: Only include allowed fields (NO email - prevents cross-team scraping)
        // Ensure displayName is a string and within length limit
        let displayName = profileData.displayName || currentAuthUser.displayName || 'Unknown';
        if (typeof displayName !== 'string') displayName = String(displayName);
        if (displayName.length > 100) displayName = displayName.substring(0, 100);
        
        // Check if doc exists FIRST to handle legacy null fields
        const docSnap = await getDoc(publicProfileRef);
        const existingData = docSnap.exists() ? docSnap.data() : null;
        
        // Build publicData for CREATE or UPDATE
        const publicData = {
            displayName: displayName,
            updatedAt: serverTimestamp()
        };
        
        // Add optional fields only if they exist and are valid strings
        if (profileData.photoURL && typeof profileData.photoURL === 'string') {
            publicData.photoURL = profileData.photoURL;
        }
        if (profileData.occupation && typeof profileData.occupation === 'string') {
            // Clamp occupation length to 200 chars (matches rule)
            publicData.occupation = profileData.occupation.substring(0, 200);
        }
        if (profileData.avatarColor && typeof profileData.avatarColor === 'string') {
            publicData.avatarColor = profileData.avatarColor;
        }
        
        // FIX FOR LEGACY NULL FIELDS:
        // If existing doc has photoURL or occupation that is NOT a string (commonly null),
        // we must delete those fields to pass the rule check:
        //   (!('photoURL' in request.resource.data) || request.resource.data.photoURL is string)
        // updateDoc merges, so we use deleteField() to explicitly remove bad fields
        if (existingData) {
            // If existing photoURL is not a valid string and we're not setting a new one, delete it
            if (('photoURL' in existingData) && typeof existingData.photoURL !== 'string' && !publicData.photoURL) {
                publicData.photoURL = deleteField();
            }
            // If existing occupation is not a valid string and we're not setting a new one, delete it
            if (('occupation' in existingData) && typeof existingData.occupation !== 'string' && !publicData.occupation) {
                publicData.occupation = deleteField();
            }
        }
        
        // DEBUG_PERMS logging
        if (DEBUG_PERMS) {
            console.log('[DEBUG_PERMS] syncPublicProfile:', {
                path: path,
                operation: existingData ? 'UPDATE' : 'CREATE',
                keys: Object.keys(publicData),
                uid: currentAuthUser.uid,
                existingKeys: existingData ? Object.keys(existingData) : 'N/A',
                existingPhotoURL: existingData?.photoURL === null ? 'null (LEGACY)' : typeof existingData?.photoURL,
                existingOccupation: existingData?.occupation === null ? 'null (LEGACY)' : typeof existingData?.occupation
            });
        }
        
        if (existingData) {
            // UPDATE: Only send mutable fields
            await updateDoc(publicProfileRef, publicData);
        } else {
            // CREATE: Full doc
            await setDoc(publicProfileRef, publicData);
        }
        debugLog('âœ… Public profile synced successfully');
        
    } catch (error) {
        // Log detailed error info for permission-denied
        logFirestoreError('syncPublicProfile', path, { displayName: profileData.displayName }, {
            uid: currentAuthUser.uid,
            hasPhotoURL: !!profileData.photoURL,
            hasOccupation: !!profileData.occupation
        }, error);
        // Non-critical error - log but don't throw
        console.warn('Failed to sync public profile:', error.code || error.message);
    }
}

// Check invitation rate limits to prevent spam
/**
 * âš ï¸ SECURITY LIMITATION: CLIENT-SIDE RATE LIMITING âš ï¸
 * 
 * These rate limits are enforced CLIENT-SIDE only and can be bypassed by:
 * - Directly calling the Firestore API
 * - Modifying this JavaScript code
 * - Using multiple browser sessions/devices
 * 
 * The limits ARE enforced in Firestore rules for:
 * - Token length (min 32 chars)
 * - Schema validation (required fields)
 * - Permission checks (admin/owner only)
 * 
 * For TRUE server-side rate limiting, you need:
 * - Cloud Functions with rate limiting logic
 * - Firebase App Check to verify legitimate clients
 * - IP-based rate limiting at the infrastructure level
 * 
 * RECOMMENDATION: Implement Cloud Functions for invitation creation
 * to enforce rate limits server-side before production launch.
 * 
 * Current client-side limits (easily bypassed):
 * - 20 invitations per hour per user
 * - 100 invitations per day per user
 * - 15-minute cooldown per email address
 */
async function checkInvitationRateLimits(invitedEmail) {
    if (!db || !currentAuthUser) {
        throw new Error('Not authenticated');
    }

    try {
        const { collection, query, where, getDocs, Timestamp } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');

        const now = new Date();
        const oneHourAgo = Timestamp.fromDate(new Date(now.getTime() - 60 * 60 * 1000));
        const oneDayAgo = Timestamp.fromDate(new Date(now.getTime() - 24 * 60 * 60 * 1000));
        const fifteenMinutesAgo = Timestamp.fromDate(new Date(now.getTime() - 15 * 60 * 1000));

        const invitationsRef = collection(db, 'teamInvitations');

        // LIMIT 1: Check per-user hourly limit (max 20 invites per hour)
        // WARNING: This is client-side only - see comment above
        const hourlyQuery = query(
            invitationsRef,
            where('invitedBy', '==', currentAuthUser.uid),
            where('createdAt', '>=', oneHourAgo)
        );
        const hourlySnapshot = await getDocs(hourlyQuery);
        
        if (hourlySnapshot.size >= 20) {
            throw new Error('HOURLY_LIMIT_REACHED');
        }

        // LIMIT 2: Check per-user daily limit (max 100 invites per 24 hours)
        const dailyQuery = query(
            invitationsRef,
            where('invitedBy', '==', currentAuthUser.uid),
            where('createdAt', '>=', oneDayAgo)
        );
        const dailySnapshot = await getDocs(dailyQuery);
        
        if (dailySnapshot.size >= 100) {
            throw new Error('DAILY_LIMIT_REACHED');
        }

        // LIMIT 3: Check per-email rate limit (no duplicate pending invites within 15 minutes)
        const emailQuery = query(
            invitationsRef,
            where('invitedEmail', '==', invitedEmail.toLowerCase()),
            where('createdAt', '>=', fifteenMinutesAgo),
            where('status', '==', 'pending')
        );
        const emailSnapshot = await getDocs(emailQuery);
        
        if (!emailSnapshot.empty) {
            throw new Error('EMAIL_RECENTLY_INVITED');
        }

        console.log('âœ… Rate limit checks passed');
        return true;

    } catch (error) {
        if (error.message === 'HOURLY_LIMIT_REACHED') {
            throw new Error('Invite limit reached. You can send up to 20 invitations per hour. Please wait before sending more invitations.');
        }
        if (error.message === 'DAILY_LIMIT_REACHED') {
            throw new Error('Daily invite limit reached. You can send up to 100 invitations per day. Please try again tomorrow.');
        }
        if (error.message === 'EMAIL_RECENTLY_INVITED') {
            throw new Error('This email already has a recent pending invitation. Please wait at least 15 minutes before sending another one.');
        }
        throw error;
    }
}

// Show invite link modal
function showInviteLink(inviteLink, invitedEmail, invitedName) {
    // Close the add teammate modal
    closeModal('teammateModal');
    
    // Create and show invite link modal
    const existingModal = document.getElementById('inviteLinkModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    const modal = document.createElement('div');
    modal.id = 'inviteLinkModal';
    modal.className = 'modal active';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h2><i class="fas fa-link"></i> Invitation Link Created</h2>
                <span class="modal-close" onclick="closeInviteLinkModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                    <p style="margin-bottom: 15px; color: #495057;">
                        <strong>Invited:</strong> ${escapeHtml(invitedName || invitedEmail)}
                        <br>
                        <strong>Email:</strong> ${escapeHtml(invitedEmail)}
                    </p>
                    <p style="margin-bottom: 10px; color: #6c757d; font-size: 0.9rem;">
                        <i class="fas fa-info-circle"></i> Copy this link and send it to ${escapeHtml(invitedName || invitedEmail)}:
                    </p>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input 
                            type="text" 
                            id="inviteLinkInput" 
                            value="${escapeHtml(inviteLink)}" 
                            readonly
                            style="flex: 1; padding: 12px; border: 2px solid #0078D4; border-radius: 6px; font-family: monospace; font-size: 0.85rem;"
                        >
                        <button 
                            onclick="copyInviteLink()" 
                            class="btn btn-primary"
                            style="white-space: nowrap; padding: 12px 20px;"
                        >
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <p style="margin-top: 10px; color: #6c757d; font-size: 0.85rem;">
                        <i class="fas fa-clock"></i> This link expires in 7 days
                    </p>
                </div>
                <div style="background: #e7f3ff; padding: 15px; border-radius: 8px; border-left: 4px solid #0078D4;">
                    <p style="margin: 0; color: #004085; font-size: 0.9rem;">
                        <strong>ðŸ’¡ Tip:</strong> You can share this link via email, Slack, Teams, or any messaging app!
                    </p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeInviteLinkModal()">Done</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// Copy invite link to clipboard
window.copyInviteLink = function() {
    const input = document.getElementById('inviteLinkInput');
    input.select();
    input.setSelectionRange(0, 99999); // For mobile devices
    
    try {
        document.execCommand('copy');
        const btn = event.target.closest('button');
        const originalHTML = btn.innerHTML;
        btn.innerHTML = '<i class="fas fa-check"></i> Copied!';
        btn.style.background = '#28a745';
        
        setTimeout(() => {
            btn.innerHTML = originalHTML;
            btn.style.background = '';
        }, 2000);
    } catch (err) {
        showToast('Please manually copy the link: ' + input.value, 'info', 10000);
    }
}

// Close invite link modal
window.closeInviteLinkModal = function() {
    const modal = document.getElementById('inviteLinkModal');
    if (modal) {
        modal.remove();
    }
}

// Send invitation email (using EmailJS or similar service)
async function sendInvitationEmail(invitationData) {
    // For now, we'll use a simple approach
    // You can integrate with EmailJS, SendGrid, or other email service
    
    const invitationLink = `${window.location.origin}/accept-invitation.html?token=${invitationData.invitationToken}&id=${invitationData.invitationId}`;
    
    debugLog('ðŸ“§ Invitation created for team:', invitationData.teamId);
    debugLog('Invitation link (debug only):', invitationLink);
    
    // Store invitation link in memory for current session only (not persisted)
    window.lastInvitationLink = invitationLink;
    
    // TODO: Integrate with actual email service
    // Example with EmailJS (you'll need to set up an account):
    /*
    emailjs.send('YOUR_SERVICE_ID', 'YOUR_TEMPLATE_ID', {
        to_email: invitationData.invitedEmail,
        to_name: invitationData.invitedName,
        team_name: invitationData.teamName,
        inviter_name: invitationData.inviterName,
        invitation_link: invitationLink
    });
    */
    
    return true;
}

async function loadTeammatesFromFirestore() {
    if (!db || !currentAuthUser || !appState.currentTeamId) return;
    
    try {
        const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        // Get team document
        const teamRef = doc(db, 'teams', appState.currentTeamId);
        const teamDoc = await getDoc(teamRef);
        
        if (teamDoc.exists()) {
            const teamData = teamDoc.data();
            const members = teamData.members || {};
            
            debugLog('ðŸ“¥ Loading teammates from Firestore...', Object.keys(members).length, 'members');
            
            // Convert members object to array and fetch latest user data for each
            const teammatePromises = Object.keys(members).map(async userId => {
                const member = members[userId];
                
                // Fetch public profile data (or own private profile if it's the current user)
                let userData = null;
                try {
                    if (userId === currentAuthUser.uid) {
                        // Current user can read their own private profile
                        const userRef = doc(db, 'users', userId);
                        const userDoc = await getDoc(userRef);
                        if (userDoc.exists()) {
                            userData = userDoc.data();
                        }
                    } else {
                        // For other users, read from publicProfiles collection
                        const publicProfileRef = doc(db, 'publicProfiles', userId);
                        const publicProfileDoc = await getDoc(publicProfileRef);
                        if (publicProfileDoc.exists()) {
                            const publicData = publicProfileDoc.data();
                            userData = {
                                displayName: publicData.displayName,
                                occupation: publicData.occupation,
                                photoURL: publicData.photoURL,
                                avatarColor: publicData.avatarColor
                            };
                        }
                    }
                } catch (error) {
                    // Expected for users who haven't synced their public profile yet
                    debugLog('Could not fetch profile for:', userId);
                }
                
                // Merge all data sources and normalize using the canonical helper
                const mergedData = {
                    ...member,  // Base team membership data
                    ...userData, // Profile data overrides
                    email: member.email, // Always keep email from membership
                    role: member.role,   // Always keep role from membership
                    joinedAt: member.joinedAt
                };
                
                const teammate = normalizeProfile(userId, mergedData);
                
                // Update appState.currentUser with chosen name if this is current user
                if (userId === currentAuthUser.uid) {
                    appState.currentUser = teammate.displayName;
                    debugLog('ðŸ‘¤ Updated appState.currentUser to:', teammate.displayName);
                }
                
                // Log teammate data in debug mode
                if (DEBUG && userId === currentAuthUser.uid) {
                    debugLog('ðŸ‘¤ Current user teammate data:', teammate);
                }
                
                return teammate;
            });
            
            // Wait for all teammate data to be fetched
            appState.teammates = await Promise.all(teammatePromises);
            
            displayTeammates();
            debugLog('âœ… Loaded teammates from Firestore:', appState.teammates.length);
        }
    } catch (error) {
        console.error('Error loading teammates from Firestore:', error.code || error.message);
        debugError('Full error:', error);
    }
}

// ===================================
// SEARCH FUNCTIONALITY
// ===================================

/**
 * SEARCH_INDEX - Central search index for navigable app sections
 * 
 * Structure:
 * - id: Unique identifier for the search target
 * - label: Display name shown in search results
 * - description: Brief description of what the target does
 * - route: The section name used by switchTab() function
 * - sectionId: The DOM element ID of the section
 * - icon: FontAwesome icon class for visual identification
 * - keywords: Array of searchable terms including common misspellings
 * 
 * The keywords array should include:
 * - Primary terms and synonyms
 * - Common typos and misspellings
 * - Related concepts users might search for
 */
/**
 * SEARCH_INDEX - Command Palette / Global Search Index
 * 
 * Each entry has a `type` field:
 *   - 'navigation': Goes to a page/section (switches tabs, scrolls to elements)
 *   - 'command': Triggers an action (opens modals, runs functions, etc.)
 * 
 * To add new entries:
 *   - Navigation: Add route, sectionId, and optional category for breadcrumb
 *   - Command: Add action (function name to call) and any needed parameters
 * 
 * Keywords support fuzzy matching with common typos included.
 */
const SEARCH_INDEX = [
    // ==================== NAVIGATION ENTRIES ====================
    // Main tabs/sections
    {
        id: 'overview-main',
        type: 'navigation',
        label: 'Overview',
        description: 'Dashboard with activity feed and quick stats',
        route: 'activity',
        sectionId: 'activity-section',
        icon: 'fa-th-large',
        keywords: ['overview', 'overveiw', 'ovrview', 'dashboard', 'dashbord', 'home', 'main', 'activity', 'activty', 'feed', 'summary']
    },
    {
        id: 'team-main',
        type: 'navigation',
        label: 'Team',
        description: 'View and manage team members',
        route: 'team',
        sectionId: 'team-section',
        icon: 'fa-users',
        keywords: ['team', 'teem', 'tem', 'members', 'membrs', 'people', 'peple', 'users', 'usrs', 'colleagues', 'coworkers', 'staff']
    },
    {
        id: 'chat-main',
        type: 'navigation',
        label: 'Chat',
        description: 'Team chat and messages',
        route: 'chat',
        sectionId: 'chat-section',
        icon: 'fa-comments',
        keywords: ['chat', 'chatt', 'cht', 'messages', 'mesages', 'messges', 'dm', 'direct', 'talk', 'conversation', 'messaging']
    },
    {
        id: 'calendar-main',
        type: 'navigation',
        label: 'Calendar',
        description: 'View and manage events and schedule',
        route: 'calendar',
        sectionId: 'calendar-section',
        icon: 'fa-calendar-alt',
        keywords: ['calendar', 'calender', 'calandar', 'calander', 'events', 'evnts', 'schedule', 'shedule', 'dates', 'appointments', 'meetings']
    },
    {
        id: 'tasks-main',
        type: 'navigation',
        label: 'Sheets',
        description: 'View and manage spreadsheets and tables',
        route: 'tasks',
        sectionId: 'tasks-section',
        icon: 'fa-table-list',
        keywords: ['sheets', 'sheet', 'tasks', 'taks', 'task', 'tsks', 'todo', 'to-do', 'todos', 'checklist', 'work', 'items', 'assignments', 'spreadsheet', 'table', 'leads']
    },
    {
        id: 'docs-main',
        type: 'navigation',
        label: 'Docs',
        description: 'Create and collaborate on documents',
        route: 'tasks',
        sectionId: 'tasks-section',
        icon: 'fa-file-lines',
        keywords: ['docs', 'documents', 'notes', 'note', 'doc', 'write', 'writing', 'text', 'documentation'],
        afterNav: () => { if (window.switchTasksView) window.switchTasksView('docs'); }
    },
    {
        id: 'metrics-main',
        type: 'navigation',
        label: 'Metrics',
        description: 'Track performance across tasks, events and teamwork',
        route: 'metrics',
        sectionId: 'metrics-section',
        icon: 'fa-chart-line',
        keywords: ['metrics', 'metrcs', 'stats', 'statistics', 'analytics', 'anlytics', 'performance', 'performace', 'reports', 'reporting', 'insights', 'data', 'charts', 'graphs', 'productivity', 'kpi', 'kpis']
    },
    {
        id: 'settings-main',
        type: 'navigation',
        label: 'Settings',
        description: 'App settings and preferences',
        route: 'settings',
        sectionId: 'settings-section',
        icon: 'fa-cog',
        keywords: ['settings', 'settyngs', 'setings', 'setngs', 'preferences', 'preferances', 'prefs', 'config', 'configuration', 'options']
    },
    // Settings subsections
    {
        id: 'settings-notifications',
        type: 'navigation',
        label: 'Notification Preferences',
        description: 'Configure which notifications you receive',
        route: 'settings',
        sectionId: 'settings-section',
        category: 'Settings',
        icon: 'fa-bell',
        keywords: ['notifications', 'notifcations', 'notifs', 'alerts', 'alrts', 'bell', 'notify', 'notification preferences', 'notification settings'],
        afterNav: () => { 
            const notificationsTab = document.querySelector('[data-settings-tab="notifications"]');
            if (notificationsTab) notificationsTab.click();
        }
    },
    {
        id: 'settings-appearance',
        type: 'navigation',
        label: 'Dark Mode',
        description: 'Switch between light and dark themes',
        route: 'settings',
        sectionId: 'settings-section',
        category: 'Settings',
        icon: 'fa-moon',
        keywords: ['appearance', 'appearence', 'theme', 'theem', 'dark mode', 'darkmode', 'dark', 'light mode', 'lightmode', 'light', 'colors', 'visual', 'night mode'],
        afterNav: () => { 
            const appearanceTab = document.querySelector('[data-settings-tab="appearance"]');
            if (appearanceTab) appearanceTab.click();
        }
    },
    {
        id: 'settings-security',
        type: 'navigation',
        label: 'Security',
        description: 'Password, sessions, and logout options',
        route: 'settings',
        sectionId: 'settings-section',
        category: 'Settings',
        icon: 'fa-shield-halved',
        keywords: ['security', 'securty', 'password', 'pasword', 'change password', 'sessions', 'account security'],
        afterNav: () => { 
            const securityTab = document.querySelector('[data-settings-tab="security"]');
            if (securityTab) securityTab.click();
        }
    },
    {
        id: 'settings-profile',
        type: 'navigation',
        label: 'Profile',
        description: 'Edit your name, avatar, and account info',
        route: 'settings',
        sectionId: 'settings-section',
        category: 'Settings',
        icon: 'fa-user',
        keywords: ['profile', 'profle', 'avatar', 'avtar', 'photo', 'picture', 'name', 'display name', 'displayname', 'account', 'my account', 'job title'],
        afterNav: () => { 
            const profileTab = document.querySelector('[data-settings-tab="profile"]');
            if (profileTab) profileTab.click();
        }
    },
    {
        id: 'settings-chat-appearance',
        type: 'navigation',
        label: 'Chat Appearance',
        description: 'Customize chat bubble style and layout',
        route: 'settings',
        sectionId: 'settings-section',
        category: 'Settings',
        icon: 'fa-comments',
        keywords: ['chat appearance', 'chat style', 'bubble', 'bubbles', 'compact', 'timestamps', 'avatars in chat', 'message style'],
        afterNav: () => { 
            const advancedTab = document.querySelector('[data-settings-tab="advanced"]');
            if (advancedTab) advancedTab.click();
        }
    },
    
    // ==================== COMMAND ENTRIES ====================
    // Commands trigger actions like opening modals or running functions
    {
        id: 'cmd-add-task',
        type: 'command',
        label: 'Add task',
        description: 'Open the New Task dialog',
        icon: 'fa-plus-circle',
        keywords: ['add task', 'new task', 'create task', 'add taks', 'new taks', 'creat task', 'task']
    },
    {
        id: 'cmd-add-event',
        type: 'command',
        label: 'Add event',
        description: 'Open the New Event dialog',
        icon: 'fa-calendar-plus',
        keywords: ['add event', 'new event', 'create event', 'add evnt', 'new evnt', 'calendar event', 'schedule event']
    },
    {
        id: 'cmd-create-spreadsheet',
        type: 'command',
        label: 'Create spreadsheet',
        description: 'Create a new tasks spreadsheet',
        icon: 'fa-table',
        keywords: ['create spreadsheet', 'new spreadsheet', 'add spreadsheet', 'creat spreadsheet', 'table', 'tasks table', 'spreadsheet']
    },
    {
        id: 'cmd-create-doc',
        type: 'command',
        label: 'Create document',
        description: 'Create a new document',
        icon: 'fa-file-lines',
        keywords: ['create doc', 'new doc', 'create document', 'new document', 'add doc', 'add document', 'write', 'note']
    },
    {
        id: 'cmd-delete-messages',
        type: 'command',
        label: 'Delete messages',
        description: 'Go to chat to manage or delete messages',
        icon: 'fa-trash-alt',
        keywords: ['delete messages', 'remove messages', 'clear chat', 'delet messages', 'delete mesages', 'chat delete']
    },
    {
        id: 'cmd-logout',
        type: 'command',
        label: 'Log out',
        description: 'Sign out from Teamster',
        icon: 'fa-sign-out-alt',
        keywords: ['log out', 'logout', 'sign out', 'signout', 'logg out', 'log off', 'exit']
    },
    {
        id: 'cmd-change-password',
        type: 'command',
        label: 'Change password',
        description: 'Open password / security settings',
        icon: 'fa-key',
        keywords: ['change password', 'password', 'chang password', 'reset password', 'update password', 'new password']
    },
    {
        id: 'cmd-invite-member',
        type: 'command',
        label: 'Invite team member',
        description: 'Send an invitation to join your team',
        icon: 'fa-user-plus',
        keywords: ['invite', 'invit', 'add member', 'new member', 'invite member', 'team invite', 'add teammate']
    },
    {
        id: 'cmd-task-reference',
        type: 'command',
        label: 'Insert task reference',
        description: 'Add a task chip to the current document',
        icon: 'fa-check-circle',
        keywords: ['task reference', 'task referance', 'task ref', 'insert task', 'add task chip', 'task chip', 'reference task', 'referance task']
    },
    {
        id: 'cmd-sheet-reference',
        type: 'command',
        label: 'Insert sheet reference',
        description: 'Add a sheet chip to the current document',
        icon: 'fa-table',
        keywords: ['sheet reference', 'sheet referance', 'sheet ref', 'insert sheet', 'add sheet chip', 'sheet chip', 'reference sheet', 'referance sheet', 'spreadsheet reference', 'spreadsheet referance']
    }
];

/**
 * Compute Levenshtein distance between two strings
 * Used for fuzzy matching - finds "edit distance" (insertions, deletions, substitutions)
 * 
 * @param {string} a - First string
 * @param {string} b - Second string
 * @returns {number} - Number of edits needed to transform a into b
 */
function levenshteinDistance(a, b) {
    if (a.length === 0) return b.length;
    if (b.length === 0) return a.length;
    
    // Create matrix
    const matrix = [];
    
    // Initialize first column
    for (let i = 0; i <= b.length; i++) {
        matrix[i] = [i];
    }
    
    // Initialize first row
    for (let j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
    }
    
    // Fill in the rest of the matrix
    for (let i = 1; i <= b.length; i++) {
        for (let j = 1; j <= a.length; j++) {
            if (b.charAt(i - 1) === a.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            } else {
                matrix[i][j] = Math.min(
                    matrix[i - 1][j - 1] + 1, // substitution
                    matrix[i][j - 1] + 1,     // insertion
                    matrix[i - 1][j] + 1      // deletion
                );
            }
        }
    }
    
    return matrix[b.length][a.length];
}

/**
 * Search the app for navigable sections/targets
 * 
 * Scoring system:
 * - 100: Exact match on label
 * - 80: Label starts with query
 * - 60: Exact match on keyword
 * - 50: Keyword starts with query
 * - 40: Query is substring of label or keyword
 * - 30: Fuzzy match (Levenshtein distance <= 2)
 * - 20: Fuzzy match (Levenshtein distance <= 3, only for longer words)
 * 
 * @param {string} query - The search query
 * @param {number} limit - Maximum number of results to return (default: 7)
 * @returns {Array} - Array of matching results with scores
 */
function searchApp(query, limit = 7) {
    // Normalize query
    const normalizedQuery = (query || '').toLowerCase().trim();
    
    // Return empty array for empty queries
    if (!normalizedQuery) {
        return [];
    }
    
    const results = [];
    const minScoreThreshold = 15; // Minimum score to include in results
    
    for (const entry of SEARCH_INDEX) {
        let maxScore = 0;
        
        // Check label
        const labelLower = entry.label.toLowerCase();
        
        if (labelLower === normalizedQuery) {
            // Exact match on label - highest score
            maxScore = 100;
        } else if (labelLower.startsWith(normalizedQuery)) {
            // Label starts with query
            maxScore = Math.max(maxScore, 80);
        } else if (labelLower.includes(normalizedQuery)) {
            // Query is substring of label
            maxScore = Math.max(maxScore, 40);
        } else {
            // Try fuzzy match on label
            const labelDistance = levenshteinDistance(normalizedQuery, labelLower);
            if (labelDistance <= 2) {
                maxScore = Math.max(maxScore, 30);
            } else if (labelDistance <= 3 && normalizedQuery.length >= 4) {
                maxScore = Math.max(maxScore, 20);
            }
        }
        
        // Check keywords
        for (const keyword of entry.keywords) {
            const keywordLower = keyword.toLowerCase();
            
            if (keywordLower === normalizedQuery) {
                // Exact match on keyword
                maxScore = Math.max(maxScore, 60);
            } else if (keywordLower.startsWith(normalizedQuery)) {
                // Keyword starts with query
                maxScore = Math.max(maxScore, 50);
            } else if (keywordLower.includes(normalizedQuery)) {
                // Query is substring of keyword
                maxScore = Math.max(maxScore, 40);
            } else {
                // Try fuzzy match on keyword
                // Only for queries and keywords of reasonable length
                if (normalizedQuery.length >= 3 && keywordLower.length >= 3) {
                    const distance = levenshteinDistance(normalizedQuery, keywordLower);
                    
                    // Allow distance proportional to word length
                    // Shorter words need closer matches
                    const maxAllowedDistance = Math.min(2, Math.floor(keywordLower.length / 3));
                    
                    if (distance <= maxAllowedDistance) {
                        maxScore = Math.max(maxScore, 30 - (distance * 5));
                    } else if (distance <= 3 && normalizedQuery.length >= 5) {
                        // More lenient for longer queries
                        maxScore = Math.max(maxScore, 20);
                    }
                }
            }
            
            // Early exit if we already have max keyword score
            if (maxScore >= 60) break;
        }
        
        // Only include results above threshold
        if (maxScore >= minScoreThreshold) {
            results.push({
                id: entry.id,
                type: entry.type || 'navigation', // Include type field
                label: entry.label,
                description: entry.description,
                route: entry.route,
                sectionId: entry.sectionId,
                icon: entry.icon,
                category: entry.category, // Include category for breadcrumb
                score: maxScore
            });
        }
    }
    
    // Sort by score (descending), then by label (ascending) as tie-breaker
    results.sort((a, b) => {
        if (b.score !== a.score) {
            return b.score - a.score;
        }
        return a.label.localeCompare(b.label);
    });
    
    // Return limited results
    return results.slice(0, limit);
}

// ===================================
// SEARCH UI - DROPDOWN & KEYBOARD NAV
// ===================================

// Track the currently highlighted search result index
let searchActiveIndex = -1;

/**
 * Initialize the global search functionality
 * - Input handling with debounce
 * - Keyboard navigation (up/down/enter/escape)
 * - Click outside to close
 */
function initSearch() {
    const searchInput = document.getElementById('globalSearchInput');
    const searchClear = document.getElementById('searchClear');
    const searchResults = document.getElementById('searchResults');
    let searchTimeout;

    if (!searchInput) {
        console.warn('Search input not found');
        return;
    }

    // Handle input changes with debounce
    searchInput.addEventListener('input', (e) => {
        const query = e.target.value.trim();
        
        // Show/hide clear button
        if (searchClear) {
            searchClear.style.display = query ? 'flex' : 'none';
        }

        clearTimeout(searchTimeout);
        
        if (query) {
            searchTimeout = setTimeout(() => {
                performSearch(query);
            }, 150); // Faster response for command palette feel
        } else {
            hideSearchDropdown();
        }
    });

    // Keyboard navigation
    searchInput.addEventListener('keydown', (e) => {
        const searchResults = document.getElementById('searchResults');
        if (!searchResults || !searchResults.classList.contains('visible')) {
            // If dropdown isn't visible and user presses down, trigger search
            if (e.key === 'ArrowDown' && searchInput.value.trim()) {
                performSearch(searchInput.value.trim());
                e.preventDefault();
            }
            return;
        }

        const items = searchResults.querySelectorAll('.search-result-item');
        if (items.length === 0) return;

        switch (e.key) {
            case 'ArrowDown':
                e.preventDefault();
                searchActiveIndex = Math.min(searchActiveIndex + 1, items.length - 1);
                updateSearchActiveItem(items);
                break;
                
            case 'ArrowUp':
                e.preventDefault();
                searchActiveIndex = Math.max(searchActiveIndex - 1, 0);
                updateSearchActiveItem(items);
                break;
                
            case 'Enter':
                e.preventDefault();
                if (searchActiveIndex >= 0 && items[searchActiveIndex]) {
                    items[searchActiveIndex].click();
                } else if (items.length > 0) {
                    // If nothing selected, activate first result
                    items[0].click();
                }
                break;
                
            case 'Escape':
                e.preventDefault();
                hideSearchDropdown();
                searchInput.blur();
                break;
                
            case 'Tab':
                // Allow tab to close dropdown and move focus
                hideSearchDropdown();
                break;
        }
    });

    // Focus handling - show dropdown if there's a query
    searchInput.addEventListener('focus', () => {
        const query = searchInput.value.trim();
        if (query) {
            performSearch(query);
        }
    });

    // Clear button
    if (searchClear) {
        searchClear.addEventListener('click', () => {
            searchInput.value = '';
            searchClear.style.display = 'none';
            hideSearchDropdown();
            searchInput.focus();
        });
    }

    // Close results when clicking outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.search-wrapper')) {
            hideSearchDropdown();
            // Collapse search bar on mobile when clicking outside
            collapseSearchBar();
        }
    });

    // Mobile compact search bar - click to expand
    initMobileSearchBar();
}

/**
 * Initialize mobile compact search bar behavior
 * On small screens, the search bar is just an icon. Clicking expands it.
 */
function initMobileSearchBar() {
    const searchBar = document.querySelector('.search-bar');
    const searchInput = document.getElementById('globalSearchInput');
    
    if (!searchBar || !searchInput) return;

    // Click on the search bar (icon) to expand
    searchBar.addEventListener('click', (e) => {
        // Only apply on small screens (matches CSS @media max-width: 480px)
        if (window.innerWidth <= 480 && !searchBar.classList.contains('expanded')) {
            e.preventDefault();
            searchBar.classList.add('expanded');
            searchInput.focus();
        }
    });

    // Collapse on blur if empty
    searchInput.addEventListener('blur', () => {
        // Delay to allow click on search results
        setTimeout(() => {
            if (!searchInput.value.trim()) {
                collapseSearchBar();
            }
        }, 200);
    });
}

/**
 * Collapse the search bar on mobile
 */
function collapseSearchBar() {
    if (window.innerWidth <= 480) {
        const searchBar = document.querySelector('.search-bar');
        const searchInput = document.getElementById('globalSearchInput');
        if (searchBar && !searchInput?.value.trim()) {
            searchBar.classList.remove('expanded');
        }
    }
}

/**
 * Update the active/highlighted search result item
 */
function updateSearchActiveItem(items) {
    items.forEach((item, index) => {
        if (index === searchActiveIndex) {
            item.classList.add('active');
            // Scroll into view if needed
            item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        } else {
            item.classList.remove('active');
        }
    });
}

/**
 * Show the search dropdown with animation
 */
function showSearchDropdown() {
    const searchResults = document.getElementById('searchResults');
    if (searchResults) {
        searchResults.style.display = 'block';
        // Trigger reflow for animation
        searchResults.offsetHeight;
        searchResults.classList.add('visible');
    }
}

/**
 * Hide the search dropdown with animation
 */
function hideSearchDropdown() {
    const searchResults = document.getElementById('searchResults');
    if (searchResults) {
        searchResults.classList.remove('visible');
        // Reset active index
        searchActiveIndex = -1;
        // Hide after animation
        setTimeout(() => {
            if (!searchResults.classList.contains('visible')) {
                searchResults.style.display = 'none';
            }
        }, 150);
    }
}

/**
 * Navigate to a search result and close the dropdown
 */
/**
 * Execute a search result - handles both navigation and command types
 * @param {string} resultId - The ID of the search result entry
 * @param {string} type - 'navigation' or 'command'
 * @param {string} route - For navigation: the tab to switch to
 * @param {string} sectionId - For navigation: the element to scroll to
 */
function executeSearchResult(resultId, type, route, sectionId) {
    // Clear search input and close dropdown first
    clearSearchUI();
    
    if (type === 'command') {
        executeSearchCommand(resultId);
    } else {
        // Default: navigation
        navigateToSection(route, sectionId);
        
        // Check for afterNav callback in SEARCH_INDEX entry
        if (resultId) {
            const entry = SEARCH_INDEX.find(e => e.id === resultId);
            if (entry && typeof entry.afterNav === 'function') {
                setTimeout(() => entry.afterNav(), 100);
            }
        }
    }
}

/**
 * Execute a command from the search/command palette
 * @param {string} commandId - The command ID from SEARCH_INDEX
 */
function executeSearchCommand(commandId) {
    switch (commandId) {
        case 'cmd-add-task':
            // Open the Add Task modal (same as clicking Add Task button)
            openAddTaskModal();
            break;

        case 'cmd-add-event':
            // Navigate to Calendar and open Add Event modal
            switchTab('calendar');
            setTimeout(() => {
                openModal('eventModal');
            }, 100);
            break;

        case 'cmd-create-spreadsheet':
            // Navigate to Sheets and open Create Spreadsheet modal
            switchTab('tasks');
            setTimeout(() => {
                switchTasksView('sheets');
                openModal('spreadsheetModal');
            }, 100);
            break;

        case 'cmd-create-doc':
            // Navigate to Docs and open Create Doc modal
            switchTab('tasks');
            setTimeout(() => {
                switchTasksView('docs');
                if (window.openCreateDocModal) {
                    window.openCreateDocModal();
                }
            }, 100);
            break;

        case 'cmd-delete-messages':
            // Navigate to Chat and show hint about deleting
            switchTab('chat');
            setTimeout(() => {
                showToast('Hover over your messages to see delete options', 'info');
            }, 200);
            break;

        case 'cmd-logout':
            // Call the existing logout function
            if (typeof signOutUser === 'function') {
                signOutUser();
            } else if (typeof window.signOutUser === 'function') {
                window.signOutUser();
            }
            break;

        case 'cmd-change-password':
            // Navigate to Settings â†’ Security section
            navigateToSection('settings', 'settings-security-section');
            break;

        case 'cmd-invite-member':
            // Navigate to Team and open invite modal
            switchTab('team');
            setTimeout(() => {
                // Try to open the teammate modal (which is the invite form)
                if (document.getElementById('teammateModal')) {
                    openModal('teammateModal');
                }
            }, 100);
            break;

        case 'cmd-task-reference':
            // Navigate to Docs and open task reference picker
            switchTab('tasks');
            setTimeout(() => {
                switchTasksView('docs');
                setTimeout(() => {
                    if (typeof window.openReferencePickerModal === 'function') {
                        window.openReferencePickerModal('task');
                    } else {
                        showToast('Open a document first to insert references', 'info');
                    }
                }, 100);
            }, 100);
            break;

        case 'cmd-sheet-reference':
            // Navigate to Docs and open sheet reference picker
            switchTab('tasks');
            setTimeout(() => {
                switchTasksView('docs');
                setTimeout(() => {
                    if (typeof window.openReferencePickerModal === 'function') {
                        window.openReferencePickerModal('sheet');
                    } else {
                        showToast('Open a document first to insert references', 'info');
                    }
                }, 100);
            }, 100);
            break;

        default:
            console.warn('Unknown command:', commandId);
    }
}

/**
 * Helper: Open the Add Task modal in create mode
 */
function openAddTaskModal() {
    // Reset form for new task
    const taskForm = document.getElementById('taskForm');
    if (taskForm) {
        taskForm.reset();
    }
    
    // Clear any editing state
    const taskIdInput = document.getElementById('editingTaskId');
    if (taskIdInput) {
        taskIdInput.value = '';
    }
    
    // Set modal title for create mode
    const modalHeader = document.querySelector('#taskModal .unified-modal-title h2');
    const submitBtn = document.querySelector('#taskModal .unified-btn-primary');
    if (modalHeader) modalHeader.innerHTML = '<i class="fas fa-plus-circle"></i> New Task';
    if (submitBtn) submitBtn.innerHTML = '<i class="fas fa-check"></i> Create Task';
    
    // Set default due date to today
    const dueDateInput = document.getElementById('taskDueDate');
    if (dueDateInput) {
        dueDateInput.value = new Date().toISOString().split('T')[0];
    }
    
    // Reset show on calendar toggle to checked (default)
    const showOnCalendarCheckbox = document.getElementById('taskShowOnCalendar');
    if (showOnCalendarCheckbox) {
        showOnCalendarCheckbox.checked = true;
    }
    
    // Open the modal
    openModal('taskModal');
}

/**
 * Helper: Open the Add Lead modal in create mode
 */
function openAddLeadModal() {
    // Reset form for new lead
    const leadForm = document.getElementById('leadForm');
    if (leadForm) {
        leadForm.reset();
    }
    
    // Reset dropdowns to default
    resetLeadModalDropdowns();
    
    // Pre-select current spreadsheet if it's a leads type
    if (appState.currentSpreadsheet?.type === 'leads') {
        const leadSpreadsheetInput = document.getElementById('leadSpreadsheet');
        const leadSpreadsheetLabel = document.getElementById('leadSpreadsheetLabel');
        if (leadSpreadsheetInput) {
            leadSpreadsheetInput.value = appState.currentSpreadsheet.id;
        }
        if (leadSpreadsheetLabel) {
            leadSpreadsheetLabel.textContent = appState.currentSpreadsheet.name;
        }
    }
    
    // Populate spreadsheet dropdown with leads-type spreadsheets
    populateLeadSpreadsheetDropdown();
    
    // Open the modal
    openModal('leadModal');
}

/**
 * Smart modal opener - opens correct modal based on current spreadsheet type
 */
function openAddItemModal() {
    if (appState.currentSpreadsheet?.type === 'leads') {
        openAddLeadModal();
    } else {
        // For tasks or default, click the existing add task button
        const addTaskBtn = document.getElementById('addTaskPanelBtn');
        if (addTaskBtn) {
            addTaskBtn.click();
        } else {
            openAddTaskModal();
        }
    }
}

// Make it globally accessible
window.openAddItemModal = openAddItemModal;
window.openAddLeadModal = openAddLeadModal;
window.openAddTaskModal = openAddTaskModal;

/**
 * Initialize Lead Modal Dropdowns
 */
function initLeadModalDropdowns() {
    // Status dropdown
    const statusTrigger = document.getElementById('leadStatusTrigger');
    const statusMenu = document.getElementById('leadStatusMenu');
    const statusInput = document.getElementById('leadStatus');
    
    if (statusTrigger && statusMenu && statusInput) {
        statusTrigger.addEventListener('click', (e) => {
            e.stopPropagation();
            // Close other lead dropdowns first
            document.querySelectorAll('#leadModal .unified-dropdown-menu').forEach(m => {
                if (m !== statusMenu) {
                    m.classList.remove('visible');
                    m.style.display = 'none';
                }
            });
            const show = !statusMenu.classList.contains('visible');
            statusMenu.classList.toggle('visible', show);
            statusMenu.style.display = show ? 'block' : 'none';
        });
        
        // Use unified-dropdown-option class (matching HTML)
        statusMenu.querySelectorAll('.unified-dropdown-option').forEach(opt => {
            opt.addEventListener('click', (e) => {
                e.stopPropagation();
                const value = opt.dataset.value;
                const color = opt.dataset.color || '#007AFF';
                statusInput.value = value;
                const statusContent = statusTrigger.querySelector('.unified-dropdown-value');
                if (statusContent) {
                    statusContent.innerHTML = `
                        <span class="unified-status-dot" style="background: ${color};"></span>
                        <span>${escapeHtml(value)}</span>
                    `;
                }
                statusMenu.querySelectorAll('.unified-dropdown-option').forEach(o => {
                    o.classList.remove('selected');
                });
                opt.classList.add('selected');
                statusMenu.classList.remove('visible');
                statusMenu.style.display = 'none';
            });
        });
    }
    
    // Source dropdown
    const sourceTrigger = document.getElementById('leadSourceTrigger');
    const sourceMenu = document.getElementById('leadSourceMenu');
    const sourceInput = document.getElementById('leadSource');
    
    if (sourceTrigger && sourceMenu && sourceInput) {
        sourceTrigger.addEventListener('click', (e) => {
            e.stopPropagation();
            // Close other lead dropdowns first
            document.querySelectorAll('#leadModal .unified-dropdown-menu').forEach(m => {
                if (m !== sourceMenu) {
                    m.classList.remove('visible');
                    m.style.display = 'none';
                }
            });
            const show = !sourceMenu.classList.contains('visible');
            sourceMenu.classList.toggle('visible', show);
            sourceMenu.style.display = show ? 'block' : 'none';
        });
        
        // Use unified-dropdown-option class (matching HTML)
        sourceMenu.querySelectorAll('.unified-dropdown-option').forEach(opt => {
            opt.addEventListener('click', (e) => {
                e.stopPropagation();
                const value = opt.dataset.value;
                const color = opt.dataset.color || '#007AFF';
                sourceInput.value = value;
                const sourceContent = sourceTrigger.querySelector('.unified-dropdown-value');
                if (sourceContent) {
                    sourceContent.innerHTML = `
                        <span class="unified-status-dot" style="background: ${color};"></span>
                        <span>${escapeHtml(value)}</span>
                    `;
                }
                sourceMenu.querySelectorAll('.unified-dropdown-option').forEach(o => {
                    o.classList.remove('selected');
                });
                opt.classList.add('selected');
                sourceMenu.classList.remove('visible');
                sourceMenu.style.display = 'none';
            });
        });
    }
    
    // Spreadsheet dropdown
    const spreadsheetTrigger = document.getElementById('leadSpreadsheetTrigger');
    const spreadsheetMenu = document.getElementById('leadSpreadsheetMenu');
    const spreadsheetInput = document.getElementById('leadSpreadsheet');
    
    if (spreadsheetTrigger && spreadsheetMenu && spreadsheetInput) {
        spreadsheetTrigger.addEventListener('click', (e) => {
            e.stopPropagation();
            const show = !spreadsheetMenu.classList.contains('visible');
            spreadsheetMenu.classList.toggle('visible', show);
            spreadsheetMenu.style.display = show ? 'block' : 'none';
        });
    }
    
    // Close dropdowns on outside click
    document.addEventListener('click', (e) => {
        // Don't close if clicking inside a dropdown
        if (e.target.closest('.unified-dropdown')) return;
        document.querySelectorAll('#leadModal .unified-dropdown-menu').forEach(m => {
            m.classList.remove('visible');
            m.style.display = 'none';
        });
    });
}

/**
 * Populate Lead Spreadsheet Dropdown with leads-type spreadsheets
 */
function populateLeadSpreadsheetDropdown() {
    const menu = document.getElementById('leadSpreadsheetMenu');
    const input = document.getElementById('leadSpreadsheet');
    const label = document.getElementById('leadSpreadsheetLabel');
    
    if (!menu || !input) return;
    
    // Filter to only leads-type spreadsheets
    const leadsSpreadsheets = (appState.spreadsheets || []).filter(s => s.type === 'leads');
    
    if (leadsSpreadsheets.length === 0) {
        menu.innerHTML = '<div class="dropdown-no-options">No leads spreadsheets available</div>';
        return;
    }
    
    menu.innerHTML = leadsSpreadsheets.map(s => `
        <div class="dropdown-menu-option" data-value="${s.id}">
            <i class="fas ${s.icon || 'fa-table'}" style="color: ${s.color || '#007AFF'}"></i>
            <span>${escapeHtml(s.name)}</span>
        </div>
    `).join('');
    
    // Pre-select current spreadsheet if it's a leads type
    if (appState.currentSpreadsheet?.type === 'leads') {
        input.value = appState.currentSpreadsheet.id;
        if (label) label.textContent = appState.currentSpreadsheet.name;
    } else if (leadsSpreadsheets.length > 0) {
        input.value = leadsSpreadsheets[0].id;
        if (label) label.textContent = leadsSpreadsheets[0].name;
    }
    
    // Add click handlers
    menu.querySelectorAll('.dropdown-menu-option').forEach(opt => {
        opt.addEventListener('click', () => {
            const spreadsheet = leadsSpreadsheets.find(s => s.id === opt.dataset.value);
            if (spreadsheet) {
                input.value = spreadsheet.id;
                if (label) label.textContent = spreadsheet.name;
            }
            menu.classList.remove('visible');
            menu.style.display = 'none';
        });
    });
}

/**
 * Reset Lead Modal Dropdowns to default values
 */
function resetLeadModalDropdowns() {
    // Reset status
    const statusInput = document.getElementById('leadStatus');
    const statusTrigger = document.getElementById('leadStatusTrigger');
    if (statusInput) statusInput.value = 'New';
    if (statusTrigger) {
        const statusContent = statusTrigger.querySelector('.dropdown-trigger-content') || statusTrigger.querySelector('.unified-dropdown-value');
        if (statusContent) {
            statusContent.innerHTML = `
                <span class="status-dot" style="background: #007AFF;"></span>
                <span>New</span>
            `;
        }
    }
    
    // Reset source
    const sourceInput = document.getElementById('leadSource');
    const sourceTrigger = document.getElementById('leadSourceTrigger');
    if (sourceInput) sourceInput.value = 'Website';
    if (sourceTrigger) {
        const sourceContent = sourceTrigger.querySelector('.dropdown-trigger-content') || sourceTrigger.querySelector('.unified-dropdown-value');
        if (sourceContent) {
            sourceContent.innerHTML = `
                <span class="source-dot" style="background: #007AFF;"></span>
                <span>Website</span>
            `;
        }
    }
    
    // Reset spreadsheet label
    const spreadsheetLabel = document.getElementById('leadSpreadsheetLabel');
    if (spreadsheetLabel) spreadsheetLabel.textContent = 'Select spreadsheet';
}

/**
 * Navigate to a section/tab with optional scroll to element
 * @param {string} route - The tab to switch to
 * @param {string} sectionId - Optional element ID to scroll to
 */
function navigateToSection(route, sectionId) {
    // Use the existing switchTab function
    switchTab(route);
    
    // Scroll to specific subsection if provided
    if (sectionId && sectionId !== `${route}-section`) {
        // Wait for tab content to render
        requestAnimationFrame(() => {
            setTimeout(() => {
                scrollToElement(sectionId);
            }, 50);
        });
    }
}

/**
 * Navigate to the Team tab and highlight a specific teammate
 * @param {string} memberId - The user ID of the teammate to highlight
 */
function navigateToTeammate(memberId) {
    // Switch to team tab
    switchTab('team');
    
    // Wait for team section to render, then find and highlight the member card
    requestAnimationFrame(() => {
        setTimeout(() => {
            const memberCard = document.querySelector(`.team-member-card[data-member-id="${memberId}"]`);
            if (memberCard) {
                // Scroll the card into view
                memberCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                
                // Add highlight effect
                memberCard.style.transition = 'box-shadow 0.3s ease, transform 0.3s ease';
                memberCard.style.boxShadow = '0 0 0 3px var(--accent), 0 8px 24px rgba(0, 122, 255, 0.25)';
                memberCard.style.transform = 'scale(1.02)';
                
                // Remove highlight after delay
                setTimeout(() => {
                    memberCard.style.boxShadow = '';
                    memberCard.style.transform = '';
                }, 2000);
            }
        }, 150);
    });
}

/**
 * Scroll to an element with header offset and highlight effect
 * @param {string} elementId - The ID of the element to scroll to
 */
function scrollToElement(elementId) {
    const element = document.getElementById(elementId);
    if (element) {
        // Get the scrollable container (main content area)
        const contentArea = document.querySelector('.content-area');
        const headerOffset = 100; // Account for sticky header
        
        if (contentArea) {
            const elementTop = element.offsetTop;
            contentArea.scrollTo({
                top: elementTop - headerOffset,
                behavior: 'smooth'
            });
        } else {
            // Fallback: use scrollIntoView
            element.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        // Brief highlight effect
        element.classList.add('search-highlight');
        setTimeout(() => element.classList.remove('search-highlight'), 1500);
    }
}

/**
 * Clear search UI state (input, dropdown, selection)
 */
function clearSearchUI() {
    const searchInput = document.getElementById('globalSearchInput');
    const searchClear = document.getElementById('searchClear');
    
    if (searchInput) {
        searchInput.value = '';
    }
    if (searchClear) {
        searchClear.style.display = 'none';
    }
    
    // Hide dropdown and reset selection
    hideSearchDropdown();
    searchActiveIndex = -1;
}

/**
 * Legacy function for backwards compatibility
 * @deprecated Use executeSearchResult instead
 */
function navigateToSearchResult(route, sectionId) {
    clearSearchUI();
    navigateToSection(route, sectionId);
}

// Expose search functions globally for onclick handlers
window.executeSearchResult = executeSearchResult;
window.executeSearchCommand = executeSearchCommand;
window.navigateToSearchResult = navigateToSearchResult;
window.navigateToSection = navigateToSection;

/**
 * Perform the search and render results
 */
function performSearch(query) {
    const searchResults = document.getElementById('searchResults');
    if (!searchResults) return;

    const lowerQuery = query.toLowerCase();
    
    // Reset active index for new search
    searchActiveIndex = -1;

    // Search for app sections/navigation targets (fuzzy search)
    const sectionResults = searchApp(query, 5);

    // Search through messages, tasks, events, and teammates
    const results = {
        sections: sectionResults,
        messages: (appState.messages || []).filter(m => 
            m.text && m.text.toLowerCase().includes(lowerQuery)
        ).slice(0, 3),
        tasks: (appState.tasks || []).filter(t => 
            (t.title && t.title.toLowerCase().includes(lowerQuery)) || 
            (t.description && t.description.toLowerCase().includes(lowerQuery))
        ).slice(0, 3),
        events: (appState.events || []).filter(e => 
            (e.title && e.title.toLowerCase().includes(lowerQuery)) || 
            (e.description && e.description.toLowerCase().includes(lowerQuery))
        ).slice(0, 3),
        teammates: (appState.teammates || []).filter(tm => 
            (tm.displayName && tm.displayName.toLowerCase().includes(lowerQuery)) || 
            (tm.email && tm.email.toLowerCase().includes(lowerQuery))
        ).slice(0, 3)
    };

    // Build results HTML
    let html = '';
    let resultIndex = 0;

    // Separate commands and navigation from section results
    const commands = results.sections.filter(s => s.type === 'command');
    const navigation = results.sections.filter(s => s.type !== 'command');

    // Show commands first when query strongly matches a command
    if (commands.length > 0) {
        html += '<div class="search-results-section">';
        html += '<div class="search-section-title"><i class="fas fa-bolt"></i> Commands</div>';
        commands.forEach(cmd => {
            html += `
                <div class="search-result-item search-result-command" data-index="${resultIndex}" data-id="${cmd.id}" data-type="command" onclick="executeSearchResult('${cmd.id}', 'command')">
                    <div class="search-result-icon command-icon"><i class="fas ${cmd.icon}"></i></div>
                    <div class="search-result-content">
                        <div class="search-result-title">${escapeHtml(cmd.label)}</div>
                        <div class="search-result-description"><span class="search-result-tag">Command</span> ${escapeHtml(cmd.description)}</div>
                    </div>
                    <div class="search-result-hint">â†µ</div>
                </div>
            `;
            resultIndex++;
        });
        html += '</div>';
    }

    // Show navigation results
    if (navigation.length > 0) {
        html += '<div class="search-results-section">';
        html += '<div class="search-section-title"><i class="fas fa-compass"></i> Go to</div>';
        navigation.forEach(section => {
            const breadcrumb = section.category ? `<span class="search-result-breadcrumb">${escapeHtml(section.category)} â€º </span>` : '';
            html += `
                <div class="search-result-item" data-index="${resultIndex}" data-id="${section.id}" data-type="navigation" onclick="executeSearchResult('${section.id}', 'navigation', '${section.route}', '${section.sectionId}')">
                    <div class="search-result-icon"><i class="fas ${section.icon}"></i></div>
                    <div class="search-result-content">
                        <div class="search-result-title">${breadcrumb}${escapeHtml(section.label)}</div>
                        <div class="search-result-description">${escapeHtml(section.description)}</div>
                    </div>
                    <div class="search-result-hint">â†µ</div>
                </div>
            `;
            resultIndex++;
        });
        html += '</div>';
    }

    if (results.messages.length > 0) {
        html += '<div class="search-results-section">';
        html += '<div class="search-section-title"><i class="fas fa-comment"></i> Messages</div>';
        results.messages.forEach(msg => {
            html += `
                <div class="search-result-item" data-index="${resultIndex}" data-type="navigation" onclick="executeSearchResult(null, 'navigation', 'chat', 'chat-section')">
                    <div class="search-result-icon"><i class="fas fa-comment"></i></div>
                    <div class="search-result-content">
                        <div class="search-result-title">${escapeHtml(msg.username || 'Unknown')}</div>
                        <div class="search-result-description">${escapeHtml(msg.text)}</div>
                    </div>
                </div>
            `;
            resultIndex++;
        });
        html += '</div>';
    }

    if (results.tasks.length > 0) {
        html += '<div class="search-results-section">';
        html += '<div class="search-section-title"><i class="fas fa-table-list"></i> Sheets</div>';
        results.tasks.forEach(task => {
            html += `
                <div class="search-result-item" data-index="${resultIndex}" data-type="navigation" onclick="navigateToTaskSheet('${task.id}')">
                    <div class="search-result-icon"><i class="fas fa-check-circle"></i></div>
                    <div class="search-result-content">
                        <div class="search-result-title">${escapeHtml(task.title)}</div>
                        <div class="search-result-description">${escapeHtml(task.description || 'No description')}</div>
                    </div>
                </div>
            `;
            resultIndex++;
        });
        html += '</div>';
    }

    if (results.events.length > 0) {
        html += '<div class="search-results-section">';
        html += '<div class="search-section-title"><i class="fas fa-calendar"></i> Events</div>';
        results.events.forEach(event => {
            html += `
                <div class="search-result-item" data-index="${resultIndex}" data-type="navigation" onclick="executeSearchResult(null, 'navigation', 'calendar', 'calendar-section')">
                    <div class="search-result-icon"><i class="fas fa-calendar-day"></i></div>
                    <div class="search-result-content">
                        <div class="search-result-title">${escapeHtml(event.title)}</div>
                        <div class="search-result-description">${escapeHtml(event.description || (event.date ? new Date(event.date).toLocaleDateString() : ''))}</div>
                    </div>
                </div>
            `;
            resultIndex++;
        });
        html += '</div>';
    }

    if (results.teammates.length > 0) {
        html += '<div class="search-results-section">';
        html += '<div class="search-section-title"><i class="fas fa-users"></i> Team Members</div>';
        results.teammates.forEach(member => {
            html += `
                <div class="search-result-item" data-index="${resultIndex}" data-type="navigation" onclick="executeSearchResult(null, 'navigation', 'team', 'team-section')">
                    <div class="search-result-icon"><i class="fas fa-user"></i></div>
                    <div class="search-result-content">
                        <div class="search-result-title">${escapeHtml(member.displayName)}</div>
                        <div class="search-result-description">${escapeHtml(member.email)}</div>
                    </div>
                </div>
            `;
            resultIndex++;
        });
        html += '</div>';
    }

    // No results message
    if (html === '') {
        html = `
            <div class="search-no-results">
                <i class="fas fa-search" style="font-size: 28px; opacity: 0.3; margin-bottom: 12px;"></i>
                <div style="font-size: 14px; font-weight: 500; margin-bottom: 4px;">No results found</div>
                <div style="font-size: 12px; opacity: 0.7;">Try a different search term</div>
            </div>
        `;
    }

    searchResults.innerHTML = html;
    showSearchDropdown();
    
    // Add hover listeners to sync with keyboard navigation
    const items = searchResults.querySelectorAll('.search-result-item');
    items.forEach((item, index) => {
        item.addEventListener('mouseenter', () => {
            searchActiveIndex = index;
            updateSearchActiveItem(items);
        });
    });
}

// ===================================
// SETTINGS & USER MENU
// ===================================
function initSettings() {
    // Initialize settings tab navigation
    initSettingsTabs();
    
    // Initialize account settings form
    loadAccountSettings();
    
    // Setup color picker
    setupAvatarColorPicker();
    
    // Setup form submission
    const settingsForm = document.getElementById('accountSettingsForm');
    if (settingsForm) {
        settingsForm.addEventListener('submit', saveAccountSettings);
    }
    
    // Initialize chat appearance settings
    initChatAppearanceForm();
    
    // Initialize animation settings
    initAnimationsForm();
    
    // Initialize sidebar icons settings
    initSidebarIconsToggle();
    
    // Initialize notification settings
    initNotificationForm();
    
    // Initialize appearance settings (dark mode)
    initAppearanceForm();
    
    // Initialize accent color settings
    initAccentColorPicker();
    
    // Initialize inline avatar upload (dropzone)
    initInlineAvatarUpload();
    
    // Initialize bio character counter
    initBioCharCounter();
    
    // Initialize avatar dropzone drag and drop
    initAvatarDropzone();
}

// Initialize settings tabs navigation
function initSettingsTabs() {
    const tabs = document.querySelectorAll('.settings-tab');
    const panes = document.querySelectorAll('.settings-tab-pane');
    
    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            const targetTab = tab.dataset.settingsTab;
            
            // Update tab active state
            tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            
            // Update pane active state
            panes.forEach(pane => {
                pane.classList.remove('active');
                if (pane.id === `settings-pane-${targetTab}`) {
                    pane.classList.add('active');
                }
            });
        });
    });
    
    // Initialize theme selector in Appearance tab
    initThemeSelectorModern();
    // Initialize custom selects for settings (replace native select UI with styled list)
    initCustomSelects();
}

/**
 * Initialize custom select UI components for settings selects
 * Keeps original <select> hidden for form submission but renders a styled list of children
 */
function initCustomSelects() {
    const selects = document.querySelectorAll('.settings-select-minimal select');
    if (!selects || selects.length === 0) return;

    function closeAll() {
        document.querySelectorAll('.custom-select-list.show').forEach(l => l.classList.remove('show'));
        document.querySelectorAll('.custom-select-button.open').forEach(b => b.classList.remove('open'));
    }

    selects.forEach(select => {
        if (select.dataset.customized) return;

        // Hide original select but keep it in the DOM for forms
        select.style.display = 'none';

        const wrapper = document.createElement('div');
        wrapper.className = 'custom-select';

        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'custom-select-button';
        const label = document.createElement('span');
        label.className = 'custom-select-label';
        label.textContent = select.options[select.selectedIndex]?.text || '';
        const arrow = document.createElement('span');
        arrow.className = 'arrow';
        btn.appendChild(label);
        btn.appendChild(arrow);

        const list = document.createElement('div');
        list.className = 'custom-select-list';

        Array.from(select.options).forEach((opt, idx) => {
            const item = document.createElement('div');
            item.className = 'custom-select-item';
            item.textContent = opt.text;
            item.dataset.value = opt.value;
            if (select.selectedIndex === idx) item.classList.add('active');
            item.addEventListener('click', (e) => {
                e.stopPropagation();
                // Update original select value
                select.value = item.dataset.value;
                // Trigger change event
                select.dispatchEvent(new Event('change', { bubbles: true }));
                // Update label and styles
                list.querySelectorAll('.custom-select-item').forEach(i => i.classList.remove('active'));
                item.classList.add('active');
                label.textContent = item.textContent;
                list.classList.remove('show');
                btn.classList.remove('open');
            });
            list.appendChild(item);
        });

        wrapper.appendChild(btn);
        wrapper.appendChild(list);
        select.parentNode.appendChild(wrapper);

        select.dataset.customized = '1';

        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const open = list.classList.toggle('show');
            btn.classList.toggle('open', open);
            // close other selects
            document.querySelectorAll('.custom-select-list').forEach(l => { if (l !== list) l.classList.remove('show'); });
        });

        // reflect programmatic changes on original select
        select.addEventListener('change', () => {
            const val = select.value;
            const activeItem = list.querySelector(`.custom-select-item[data-value="${val}"]`);
            if (activeItem) {
                list.querySelectorAll('.custom-select-item').forEach(i => i.classList.remove('active'));
                activeItem.classList.add('active');
                label.textContent = activeItem.textContent;
            }
        });
    });

    // Close on outside click
    document.addEventListener('click', closeAll);
}

// Initialize modern theme selector buttons
function initThemeSelectorModern() {
    // Support both .theme-option-modern and .theme-btn (minimal)
    const themeButtons = document.querySelectorAll('.theme-option-modern, .theme-btn');
    const themeInput = document.getElementById('themePreference');
    
    // Get current theme from localStorage
    const currentTheme = localStorage.getItem('themePreference') || 'system';
    
    // Set initial active state
    themeButtons.forEach(btn => {
        if (btn.dataset.theme === currentTheme) {
            btn.classList.add('active');
        }
        
        btn.addEventListener('click', () => {
            // Update active state
            themeButtons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            // Update hidden input
            if (themeInput) {
                themeInput.value = btn.dataset.theme;
            }
            
            // Apply theme
            applyThemePreference(btn.dataset.theme);
            
            // Save preference
            localStorage.setItem('themePreference', btn.dataset.theme);
        });
    });
    
    // Initialize minimal color pickers
    initMinimalColorPickers();
}

// Initialize minimal color pickers (avatar + accent)
function initMinimalColorPickers() {
    // Avatar color picker (minimal dots)
    const avatarColorDots = document.querySelectorAll('.avatar-color-picker-minimal .color-dot');
    const avatarColorInput = document.getElementById('settingsAvatarColor');
    
    if (avatarColorDots.length && avatarColorInput) {
        // Set initial selected state
        const currentColor = avatarColorInput.value;
        avatarColorDots.forEach(dot => {
            if (dot.dataset.color === currentColor) {
                dot.classList.add('selected');
            }
            
            dot.addEventListener('click', () => {
                avatarColorDots.forEach(d => d.classList.remove('selected'));
                dot.classList.add('selected');
                avatarColorInput.value = dot.dataset.color;
                
                // Update avatar preview
                const avatarPreview = document.getElementById('profileAvatarPreview');
                if (avatarPreview) {
                    avatarPreview.style.backgroundColor = dot.dataset.color;
                }
            });
        });
    }
    
    // Accent color picker (minimal dots)
    const accentDots = document.querySelectorAll('.accent-color-picker-minimal .accent-dot');
    if (accentDots.length) {
        const savedAccent = localStorage.getItem('accentColor') || 'blue';
        
        accentDots.forEach(dot => {
            if (dot.dataset.accent === savedAccent) {
                dot.classList.add('selected');
            }
            
            dot.addEventListener('click', () => {
                accentDots.forEach(d => d.classList.remove('selected'));
                dot.classList.add('selected');
                
                // Apply accent color
                const isDark = document.body.classList.contains('dark-mode');
                const color = isDark ? dot.dataset.dark : dot.dataset.color;
                const hover = isDark ? dot.dataset.darkHover : dot.dataset.hover;
                const soft = isDark ? dot.dataset.darkSoft : dot.dataset.soft;
                
                document.documentElement.style.setProperty('--accent', color);
                document.documentElement.style.setProperty('--accent-hover', hover);
                document.documentElement.style.setProperty('--accent-soft', soft);
                
                localStorage.setItem('accentColor', dot.dataset.accent);
            });
        });
    }
}

// Apply theme preference
function applyThemePreference(preference) {
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    
    const shouldBeDark = preference === 'dark' || (preference === 'system' && prefersDark);

    if (shouldBeDark) {
        document.body.classList.add('dark-mode');
        document.documentElement.classList.add('dark-mode');
        localStorage.setItem('darkMode', 'true');
    } else {
        document.body.classList.remove('dark-mode');
        document.documentElement.classList.remove('dark-mode');
        localStorage.setItem('darkMode', 'false');
    }

    if (window.__setThemeMeta) {
        window.__setThemeMeta(shouldBeDark);
    }
}

// Initialize bio character counter
function initBioCharCounter() {
    const bioTextarea = document.getElementById('settingsBio');
    const charCount = document.getElementById('bioCharCount');
    
    if (!bioTextarea || !charCount) return;
    
    const updateCount = () => {
        charCount.textContent = bioTextarea.value.length;
    };
    
    bioTextarea.addEventListener('input', updateCount);
    updateCount();
}

// Initialize avatar dropzone with drag and drop
function initAvatarDropzone() {
    const dropzone = document.getElementById('avatarDropzone');
    const fileInput = document.getElementById('avatarFileInputInline');
    
    if (!dropzone || !fileInput) return;
    
    // Prevent default drag behaviors
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropzone.addEventListener(eventName, (e) => {
            e.preventDefault();
            e.stopPropagation();
        });
    });
    
    // Highlight on drag
    ['dragenter', 'dragover'].forEach(eventName => {
        dropzone.addEventListener(eventName, () => {
            dropzone.classList.add('drag-over');
        });
    });
    
    ['dragleave', 'drop'].forEach(eventName => {
        dropzone.addEventListener(eventName, () => {
            dropzone.classList.remove('drag-over');
        });
    });
    
    // Handle drop
    dropzone.addEventListener('drop', (e) => {
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            handleAvatarFile(files[0]);
        }
    });
    
    // Handle click to open file picker
    dropzone.addEventListener('click', () => {
        fileInput.click();
    });
    
    // Handle file selection
    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            handleAvatarFile(file);
        }
    });
}

// Handle avatar file upload
async function handleAvatarFile(file) {
    // Validate file size (max 10MB as per dropzone text)
    if (file.size > 10 * 1024 * 1024) {
        showToast('Image must be under 10MB', 'error');
        return;
    }
    
    // Validate file type
    const validTypes = ['image/svg+xml', 'image/jpeg', 'image/jpg', 'image/png'];
    if (!validTypes.includes(file.type)) {
        showToast('Please select a SVG, JPG, or PNG file', 'error');
        return;
    }
    
    try {
        showToast('Avatar upload feature requires Firebase Storage setup', 'info');
    } catch (error) {
        console.error('Avatar upload error:', error);
        showToast('Failed to upload avatar', 'error');
    }
}

// Initialize inline avatar upload (legacy support - now handled by initAvatarDropzone)
function initInlineAvatarUpload() {
    // The avatar upload is now handled by the dropzone in initAvatarDropzone
    // This function is kept for backwards compatibility
    const uploadBtn = document.getElementById('uploadAvatarBtn');
    const fileInput = document.getElementById('avatarFileInput');
    
    if (!uploadBtn || !fileInput) return;
    
    // Trigger file input when button clicked (legacy)
    uploadBtn.addEventListener('click', () => {
        fileInput.click();
    });
    
    // Handle file selection (legacy)
    fileInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        handleAvatarFile(file);
        fileInput.value = '';
    });
}

// Load current account settings
async function loadAccountSettings() {
    if (!currentAuthUser) {
        debugLog('No authenticated user');
        return;
    }
    
    try {
        // Get user data from Firestore
        let userData = {
            displayName: currentAuthUser.displayName || currentAuthUser.email.split('@')[0],
            email: currentAuthUser.email,
            jobTitle: '',
            avatarColor: '#0078D4'
        };
        
        if (db && appState.currentTeamId) {
            const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
            
            // Get user settings from users collection
            const userRef = doc(db, 'users', currentAuthUser.uid);
            const userDoc = await getDoc(userRef);
            
            if (userDoc.exists()) {
                const data = userDoc.data();
                userData.jobTitle = data.jobTitle || '';
                userData.avatarColor = data.avatarColor || '#0078D4';
                userData.displayName = data.displayName || userData.displayName;
            }
        }
        
        // Update form fields
        document.getElementById('settingsDisplayName').value = userData.displayName;
        document.getElementById('settingsEmail').value = userData.email;
        document.getElementById('settingsJobTitle').value = userData.jobTitle;
        document.getElementById('settingsAvatarColor').value = userData.avatarColor;
        
        // Update preview
        updateProfilePreview(userData);
        
        // Update sidebar profile to match settings
        updateSidebarProfile(userData.displayName, userData.avatarColor);
        
        // Select the color option
        selectColorOption(userData.avatarColor);
        
    } catch (error) {
        console.error('Error loading account settings:', error.code || error.message);
        debugError('Full error:', error);
    }
}

// Update profile preview
function updateProfilePreview(userData) {
    const previewName = document.getElementById('profilePreviewName');
    const previewEmail = document.getElementById('profilePreviewEmail');
    const avatarPreview = document.getElementById('profileAvatarPreview');
    const avatarText = document.getElementById('profileAvatarText');
    
    if (previewName) previewName.textContent = userData.displayName;
    if (previewEmail) previewEmail.textContent = userData.email;
    
    // Update avatar
    const initials = generateAvatar(userData.displayName);
    if (avatarText) avatarText.textContent = initials;
    
    // Get lighter color for gradient
    const darkerColor = shadeColor(userData.avatarColor, -20);
    if (avatarPreview) {
        avatarPreview.style.background = `linear-gradient(135deg, ${userData.avatarColor} 0%, ${darkerColor} 100%)`;
    }
}

// Setup avatar color picker - supports both old (.color-option), (.color-circle), and new (.color-dot) styles
function setupAvatarColorPicker() {
    const colorOptions = document.querySelectorAll('.color-option, .color-circle, .color-dot');
    
    colorOptions.forEach(option => {
        // Make options keyboard accessible
        option.tabIndex = 0;
        option.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                this.click();
            }
        });

        option.addEventListener('click', function() {
            // Remove selected class from all
            colorOptions.forEach(opt => opt.classList.remove('selected'));
            
            // Add selected class to clicked option
            this.classList.add('selected');
            
            // Update hidden input
            const color = this.getAttribute('data-color');
            document.getElementById('settingsAvatarColor').value = color;
            
            // Update preview
            const userData = {
                displayName: document.getElementById('settingsDisplayName').value,
                email: document.getElementById('settingsEmail').value,
                avatarColor: color
            };
            updateProfilePreview(userData);
        });
    });
}

// Select color option - supports old (.color-option), (.color-circle), and new (.color-dot') styles
function selectColorOption(color) {
    const colorOptions = document.querySelectorAll('.color-option, .color-circle, .color-dot');
    colorOptions.forEach(option => {
        if (option.getAttribute('data-color') === color) {
            option.classList.add('selected');
        } else {
            option.classList.remove('selected');
        }
    });
}

// Shade color (darken or lighten)
function shadeColor(color, percent) {
    const num = parseInt(color.replace("#",""), 16);
    const amt = Math.round(2.55 * percent);
    const R = (num >> 16) + amt;
    const G = (num >> 8 & 0x00FF) + amt;
    const B = (num & 0x0000FF) + amt;
    return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 +
        (G<255?G<1?0:G:255)*0x100 +
        (B<255?B<1?0:B:255))
        .toString(16).slice(1);
}

// Save account settings
async function saveAccountSettings(e) {
    e.preventDefault();
    
    if (!currentAuthUser || !db) {
        showToast('Cannot save settings. Please sign in again.', 'error');
        return;
    }
    
    // Get raw input values
    let displayName = document.getElementById('settingsDisplayName').value;
    const jobTitle = document.getElementById('settingsJobTitle').value.trim();
    const avatarColor = document.getElementById('settingsAvatarColor').value;
    
    // === NORMALIZE displayName (Phase 3) ===
    // 1. Trim whitespace
    displayName = displayName.trim();
    // 2. Collapse multiple spaces to single space
    displayName = displayName.replace(/\s+/g, ' ');
    // 3. Enforce max length (100 chars to match Firestore rules)
    if (displayName.length > 100) {
        displayName = displayName.substring(0, 100);
    }
    
    if (!displayName) {
        showToast('Display name is required', 'warning');
        return;
    }
    
    // === DEBUG: Log the normalization ===
    console.log('ðŸ“ [IDENTITY DEBUG] saveAccountSettings normalization:');
    console.log('  - Normalized displayName:', JSON.stringify(displayName));
    console.log('  - avatarColor:', avatarColor);
    console.log('  - Firebase Auth displayName (before):', JSON.stringify(currentAuthUser.displayName));
    
    try {
        const { doc, setDoc, updateDoc, getDoc, serverTimestamp } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        const { updateProfile } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-auth.js');
        
        // Check if user document exists first
        const userRef = doc(db, 'users', currentAuthUser.uid);
        
        const userData = {
            displayName: displayName,
            email: currentAuthUser.email,
            jobTitle: jobTitle,
            avatarColor: avatarColor,
            updatedAt: serverTimestamp()
        };
        
        // Write to /users/{uid}
        console.log('ðŸ“¤ [IDENTITY DEBUG] Writing to /users:', userData);
        await setDoc(userRef, userData, { merge: true });
        console.log('âœ… [IDENTITY DEBUG] User document updated successfully');
        
        // Sync public profile for teammate visibility (/publicProfiles/{uid})
        console.log('ðŸ“¤ [IDENTITY DEBUG] Syncing to /publicProfiles...');
        await syncPublicProfile({
            displayName: displayName,
            email: currentAuthUser.email,
            photoURL: currentAuthUser.photoURL || null,
            occupation: jobTitle || null,
            avatarColor: avatarColor
        });
        console.log('âœ… [IDENTITY DEBUG] Public profile synced');
        
        // === SYNC TO FIREBASE AUTH (Phase 3) ===
        // This ensures currentAuthUser.displayName stays in sync with our saved value
        // Legacy code paths that still use currentAuthUser.displayName will work correctly
        try {
            await updateProfile(currentAuthUser, { displayName: displayName });
            console.log('âœ… [IDENTITY DEBUG] Firebase Auth displayName updated to:', JSON.stringify(displayName));
            console.log('  - Firebase Auth displayName (after):', JSON.stringify(currentAuthUser.displayName));
        } catch (authUpdateError) {
            // Non-critical - log but continue
            console.warn('âš ï¸ [IDENTITY DEBUG] Could not update Firebase Auth profile:', authUpdateError.message);
        }
        
        // Update publicProfilesById cache for immediate effect
        if (!appState.publicProfilesById) appState.publicProfilesById = {};
        appState.publicProfilesById[currentAuthUser.uid] = {
            displayName: displayName,
            avatarColor: avatarColor,
            photoURL: currentAuthUser.photoURL || null,
            occupation: jobTitle || null
        };
        console.log('âœ… [IDENTITY DEBUG] publicProfilesById cache updated');
        
        // Update sidebar display
        updateSidebarProfile(displayName, avatarColor);
        
        // Reload team members display
        await loadTeammatesFromFirestore();
        await loadPublicProfilesForTeam();
        await initTeamSection();
        
        // Show success message
        showSuccessMessage('Settings saved successfully!');
        // ===============================
        // Avatar Settings UI Logic
        // ===============================
        function initAvatarSettings() {
            const previewEl = document.getElementById('avatarSettingsPreview');
            const uploadBtn = document.getElementById('uploadAvatarBtn');
            const fileInput = document.getElementById('avatarFileInput');
            if (!previewEl || !uploadBtn || !fileInput) return;

            // Render current avatar (image or initials)
            function renderAvatarPreview() {
                previewEl.innerHTML = '';
                const user = appState.currentUser;
                if (user && user.avatarUrl) {
                    const img = document.createElement('img');
                    img.src = user.avatarUrl;
                    img.alt = `Avatar of ${user.displayName || user.email || 'user'}`;
                    img.style.width = '72px';
                    img.style.height = '72px';
                    img.style.borderRadius = '50%';
                    img.style.objectFit = 'cover';
                    img.onerror = function() {
                        img.style.display = 'none';
                        renderInitialsAvatar();
                    };
                    previewEl.appendChild(img);
                } else {
                    renderInitialsAvatar();
                }
            }
            function renderInitialsAvatar() {
                const user = appState.currentUser;
                const initials = generateAvatar(user.displayName || user.email || 'U');
                const avatarDiv = document.createElement('div');
                avatarDiv.textContent = initials;
                avatarDiv.style.width = '72px';
                avatarDiv.style.height = '72px';
                avatarDiv.style.borderRadius = '50%';
                avatarDiv.style.background = `linear-gradient(135deg, ${user.avatarColor || '#0078D4'} 0%, ${shadeColor(user.avatarColor || '#0078D4', -20)} 100%)`;
                avatarDiv.style.color = 'white';
                avatarDiv.style.display = 'flex';
                avatarDiv.style.alignItems = 'center';
                avatarDiv.style.justifyContent = 'center';
                avatarDiv.style.fontSize = '2rem';
                avatarDiv.style.fontWeight = '700';
                previewEl.appendChild(avatarDiv);
            }
            renderAvatarPreview();

            // Button triggers file input
            uploadBtn.onclick = () => fileInput.click();

            // Handle file selection and upload
            fileInput.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                uploadBtn.disabled = true;
                uploadBtn.textContent = 'Uploadingâ€¦';
                try {
                    const url = await uploadUserAvatar(file);
                    renderAvatarPreview();
                    showToast('Avatar updated.', 'success');
                } catch (err) {
                    showToast(err.message || 'Failed to upload avatar.', 'error');
                }
                uploadBtn.disabled = false;
                uploadBtn.textContent = 'Upload new avatar';
                fileInput.value = '';
            };
        }
        
        console.log('âœ… Account settings saved');
        
    } catch (error) {
        console.error('âŒ Error saving account settings:', error.code || error.message);
        showToast('Error saving settings. Please try again.', 'error', 5000, 'Save Failed');
    }
}

// Update sidebar profile
function updateSidebarProfile(displayName, avatarColor) {
    const sidebarName = document.getElementById('sidebarUserName');
    const sidebarAvatar = document.getElementById('sidebarAvatar');
    const topBarAvatar = document.getElementById('topBarAvatar');
    
    if (sidebarName) {
        sidebarName.textContent = displayName;
    }
    
    if (sidebarAvatar) {
        const initials = generateAvatar(displayName);
        const darkerColor = shadeColor(avatarColor, -20);
        
        // Clear any existing content (like default icon)
        sidebarAvatar.innerHTML = '';
        
        // Apply styles
        sidebarAvatar.style.background = `linear-gradient(135deg, ${avatarColor} 0%, ${darkerColor} 100%)`;
        sidebarAvatar.style.color = 'white';
        sidebarAvatar.style.display = 'flex';
        sidebarAvatar.style.alignItems = 'center';
        sidebarAvatar.style.justifyContent = 'center';
        sidebarAvatar.style.fontSize = '16px';
        sidebarAvatar.style.fontWeight = '700';
        
        // Set the initials
        sidebarAvatar.textContent = initials;
    }

    if (topBarAvatar) {
        const initials = generateAvatar(displayName);
        const darkerColor = shadeColor(avatarColor, -20);
        topBarAvatar.innerHTML = '';
        topBarAvatar.style.background = `linear-gradient(135deg, ${avatarColor} 0%, ${darkerColor} 100%)`;
        topBarAvatar.style.color = 'white';
        topBarAvatar.style.alignItems = 'center';
        topBarAvatar.style.justifyContent = 'center';
        topBarAvatar.style.fontSize = '14px';
        topBarAvatar.style.fontWeight = '700';
        topBarAvatar.textContent = initials;
        topBarAvatar.onclick = () => openSettings();
    }
}

// Show success message
function showSuccessMessage(message) {
    const toast = document.createElement('div');
    toast.className = 'success-toast';
    toast.innerHTML = `
        <i class="fas fa-check-circle"></i>
        <span>${message}</span>
    `;
    toast.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #4CAF50;
        color: white;
        padding: 16px 24px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        display: flex;
        align-items: center;
        gap: 12px;
        font-weight: 600;
        z-index: 10000;
        animation: slideIn 0.3s ease;
    `;
    
    document.body.appendChild(toast);
    
    setTimeout(() => {
        toast.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => toast.remove(), 300);
    }, 3000);
}

// Add animations to CSS
const style = document.createElement('style');
style.textContent = `
    @keyframes slideIn {
        from {
            transform: translateX(400px);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }
    @keyframes slideOut {
        from {
            transform: translateX(0);
            opacity: 1;
        }
        to {
            transform: translateX(400px);
            opacity: 0;
        }
    }
`;
document.head.appendChild(style);

// Cancel settings (reload original values)
window.cancelSettings = function() {
    loadAccountSettings();
    showSuccessMessage('Changes cancelled');
};

// Open settings from profile click
window.openSettings = function() {
    // Switch to settings section
    const settingsNav = document.querySelector('[data-section="settings"]');
    if (settingsNav) {
        settingsNav.click();
    }
};

// ===================================
// CHAT APPEARANCE SETTINGS
// ===================================

// Default chat preferences
const defaultChatPreferences = {
    showAvatars: true,
    compactMode: false,
    timestampsStyle: 'inline',
    bubbleStyle: 'filled'
};

// Load chat appearance settings
async function loadChatAppearanceSettings() {
    if (!currentAuthUser || !db) {
        return defaultChatPreferences;
    }
    
    try {
        const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        const userRef = doc(db, 'users', currentAuthUser.uid);
        const userDoc = await getDoc(userRef);
        
        if (userDoc.exists()) {
            const data = userDoc.data();
            const chatPrefs = data.preferences?.chat || {};
            
            // Merge with defaults
            return {
                showAvatars: chatPrefs.showAvatars !== undefined ? chatPrefs.showAvatars : defaultChatPreferences.showAvatars,
                compactMode: chatPrefs.compactMode !== undefined ? chatPrefs.compactMode : defaultChatPreferences.compactMode,
                timestampsStyle: chatPrefs.timestampsStyle || defaultChatPreferences.timestampsStyle,
                bubbleStyle: chatPrefs.bubbleStyle || defaultChatPreferences.bubbleStyle
            };
        }
    } catch (error) {
        console.error('Error loading chat preferences:', error);
    }
    
    return defaultChatPreferences;
}

// Apply chat appearance settings to UI
function applyChatAppearance(preferences) {
    const chatContainer = document.querySelector('.chat-container');
    if (!chatContainer) return;
    
    console.log('Applying chat preferences:', preferences);
    
    // Show/hide avatars
    if (preferences.showAvatars) {
        chatContainer.classList.remove('chat-hide-avatars');
    } else {
        chatContainer.classList.add('chat-hide-avatars');
    }
    
    // Compact mode
    if (preferences.compactMode) {
        chatContainer.classList.add('chat-compact');
    } else {
        chatContainer.classList.remove('chat-compact');
    }
    
    // Timestamp style
    chatContainer.classList.remove('timestamp-inline', 'timestamp-subtle');
    chatContainer.classList.add(`timestamp-${preferences.timestampsStyle}`);
    
    // Bubble style
    if (preferences.bubbleStyle === 'minimal') {
        chatContainer.classList.add('bubble-style-minimal');
    } else {
        chatContainer.classList.remove('bubble-style-minimal');
    }
}

// Initialize chat appearance form
function initChatAppearanceForm() {
    const form = document.getElementById('chatAppearanceForm');
    if (!form) return;
    
    // Load and apply current preferences
    loadChatAppearanceSettings().then(preferences => {
        // Set form values
        document.getElementById('chatShowAvatars').checked = preferences.showAvatars;
        document.getElementById('chatCompactMode').checked = preferences.compactMode;
        
        const timestampRadios = document.querySelectorAll('input[name="timestampStyle"]');
        timestampRadios.forEach(radio => {
            if (radio.value === preferences.timestampsStyle) {
                radio.checked = true;
            }
        });
        
        const bubbleRadios = document.querySelectorAll('input[name="bubbleStyle"]');
        bubbleRadios.forEach(radio => {
            if (radio.value === preferences.bubbleStyle) {
                radio.checked = true;
            }
        });
        
        // Apply to chat UI
        applyChatAppearance(preferences);
    });
    
    // Auto-save on toggle changes
    document.getElementById('chatShowAvatars').addEventListener('change', () => saveChatAppearanceSettings());
    document.getElementById('chatCompactMode').addEventListener('change', () => saveChatAppearanceSettings());
    
    // Auto-save on radio changes
    const timestampRadios = document.querySelectorAll('input[name="timestampStyle"]');
    timestampRadios.forEach(radio => {
        radio.addEventListener('change', () => saveChatAppearanceSettings());
    });
    
    const bubbleRadios = document.querySelectorAll('input[name="bubbleStyle"]');
    bubbleRadios.forEach(radio => {
        radio.addEventListener('change', () => saveChatAppearanceSettings());
    });
}

// Save chat appearance settings
async function saveChatAppearanceSettings() {
    if (!currentAuthUser || !db) {
        showToast('Cannot save preferences. Please sign in again.', 'error');
        return;
    }
    
    const preferences = {
        showAvatars: document.getElementById('chatShowAvatars').checked,
        compactMode: document.getElementById('chatCompactMode').checked,
        timestampsStyle: document.querySelector('input[name="timestampStyle"]:checked')?.value || 'inline',
        bubbleStyle: document.querySelector('input[name="bubbleStyle"]:checked')?.value || 'filled'
    };
    
    console.log('Saving chat preferences:', preferences);
    
    try {
        await updateUserPreferences({ chat: preferences });
        
        // Apply to UI immediately
        applyChatAppearance(preferences);
    } catch (error) {
        console.error('Error saving chat preferences:', error);
        showToast('Error saving preferences. Please try again.', 'error', 5000, 'Save Failed');
    }
}

// Update user preferences helper function
async function updateUserPreferences(preferences) {
    if (!currentAuthUser || !db) {
        throw new Error('Not authenticated');
    }
    
    const { doc, setDoc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
    const userRef = doc(db, 'users', currentAuthUser.uid);
    
    // Get existing preferences
    const userDoc = await getDoc(userRef);
    const existingPrefs = userDoc.exists() ? (userDoc.data().preferences || {}) : {};
    
    // Recursive deep merge helper function for nested objects
    function deepMerge(target, source) {
        const result = { ...target };
        for (const [key, value] of Object.entries(source)) {
            if (value && typeof value === 'object' && !Array.isArray(value)) {
                // If both target and source values are objects, recursively merge
                if (result[key] && typeof result[key] === 'object' && !Array.isArray(result[key])) {
                    result[key] = deepMerge(result[key], value); // RECURSIVE
                } else {
                    result[key] = { ...value };
                }
            } else {
                // Direct assignment for primitives and arrays
                result[key] = value;
            }
        }
        return result;
    }
    
    // Deep merge with new preferences to preserve nested objects like notificationPreferences
    const updatedPrefs = deepMerge(existingPrefs, preferences);
    
    // Update document
    await setDoc(userRef, { preferences: updatedPrefs }, { merge: true });
}

// Reset chat appearance to defaults
window.resetChatAppearance = async function() {
    const confirmed = await showConfirmModal('Reset chat appearance to defaults?', {
        title: 'Reset Chat Appearance',
        confirmText: 'Reset'
    });
    if (confirmed) {
        document.getElementById('chatShowAvatars').checked = defaultChatPreferences.showAvatars;
        document.getElementById('chatCompactMode').checked = defaultChatPreferences.compactMode;
        
        const timestampRadios = document.querySelectorAll('input[name="timestampStyle"]');
        timestampRadios.forEach(radio => {
            if (radio.value === defaultChatPreferences.timestampsStyle) {
                radio.checked = true;
            }
        });
        
        const bubbleRadios = document.querySelectorAll('input[name="bubbleStyle"]');
        bubbleRadios.forEach(radio => {
            if (radio.value === defaultChatPreferences.bubbleStyle) {
                radio.checked = true;
            }
        });
        
        applyChatAppearance(defaultChatPreferences);
        showSuccessMessage('Reset to defaults');
    }
};

// ===================================
// APPEARANCE SETTINGS (THEME PREFERENCE)
// Supports system/light/dark with Firestore persistence
// ===================================

// Initialize appearance form with theme selector
function initAppearanceForm() {
    const form = document.getElementById('appearanceForm');
    if (!form) return;
    
    // Support both old (.theme-option) and new (.theme-option-modern) selectors
    const themeOptions = document.querySelectorAll('.theme-option, .theme-option-modern');
    const themeInput = document.getElementById('themePreference');
    
    if (!themeOptions.length) {
        console.warn('Theme options not found');
        return;
    }
    
    // Load theme from localStorage first (for instant UI)
    let localTheme = localStorage.getItem('themePreference') || 'system';
    
    // Handle migration from old darkMode
    if (!localStorage.getItem('themePreference')) {
        const oldDarkMode = localStorage.getItem('darkMode');
        if (oldDarkMode === 'true') {
            localTheme = 'dark';
        } else if (oldDarkMode === 'false') {
            localTheme = 'light';
        }
    }
    
    // Set initial UI state
    updateThemeUI(localTheme);
    applyTheme(localTheme);
    
    // Then load from Firestore and override if set
    loadThemePreference().then(savedTheme => {
        if (savedTheme) {
            updateThemeUI(savedTheme);
            applyTheme(savedTheme);
            localStorage.setItem('themePreference', savedTheme);
        }
    });
    
    // Handle theme option clicks
    themeOptions.forEach(option => {
        option.addEventListener('click', async () => {
            const theme = option.dataset.theme;
            updateThemeUI(theme);
            applyTheme(theme);
            localStorage.setItem('themePreference', theme);
            await saveThemePreference(theme);
        });
    });
}

/**
 * Update the theme selector UI to show active option
 * @param {string} theme - 'system', 'light', or 'dark'
 */
function updateThemeUI(theme) {
    // Support both old (.theme-option) and new (.theme-option-modern) selectors
    const themeOptions = document.querySelectorAll('.theme-option, .theme-option-modern');
    const themeInput = document.getElementById('themePreference');
    
    themeOptions.forEach(option => {
        if (option.dataset.theme === theme) {
            option.classList.add('active');
        } else {
            option.classList.remove('active');
        }
    });
    
    if (themeInput) {
        themeInput.value = theme;
    }
}

/**
 * Load theme preference from Firestore
 * @returns {Promise<string|null>} Theme preference or null if not set
 */
async function loadThemePreference() {
    if (!currentAuthUser || !db) {
        return null;
    }
    
    try {
        const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        const userRef = doc(db, 'users', currentAuthUser.uid);
        const userDoc = await getDoc(userRef);
        
        if (userDoc.exists()) {
            const data = userDoc.data();
            // Check for new theme preference first
            if (data.preferences?.appearance?.theme) {
                return data.preferences.appearance.theme;
            }
            // Fall back to old darkMode for migration
            if (data.preferences?.appearance?.darkMode !== undefined) {
                return data.preferences.appearance.darkMode ? 'dark' : 'light';
            }
        }
        
        return null;
    } catch (error) {
        console.error('Error loading theme preference:', error);
        return null;
    }
}

/**
 * Apply theme to the page
 * @param {string} theme - 'system', 'light', or 'dark'
 */
function applyTheme(theme) {
    const shouldBeDark = resolveTheme(theme);
    
    if (shouldBeDark) {
        document.body.classList.add('dark-mode');
    } else {
        document.body.classList.remove('dark-mode');
    }
    
    // Also update settings cards immediately
    document.querySelectorAll('.settings-card').forEach(card => {
        if (shouldBeDark) {
            card.classList.add('dark-mode');
        } else {
            card.classList.remove('dark-mode');
        }
    });
}

// Keep old applyDarkMode for backward compatibility with other code
function applyDarkMode(isDark) {
    applyTheme(isDark ? 'dark' : 'light');
}

/**
 * Save theme preference to Firestore
 * @param {string} theme - 'system', 'light', or 'dark'
 */
async function saveThemePreference(theme) {
    if (!currentAuthUser || !db) {
        console.warn('Cannot save theme preference - not authenticated');
        return;
    }
    
    try {
        await updateUserPreferences({ 
            appearance: { 
                theme: theme,
                // Keep darkMode for backward compatibility
                darkMode: theme === 'dark' || (theme === 'system' && systemPrefersDark())
            } 
        });
        
        showToast('Theme updated', 'success', 2000);
    } catch (error) {
        console.error('Error saving theme preference:', error);
        showToast('Error saving theme. Please try again.', 'error', 5000, 'Save Failed');
    }
}

// Legacy function for backward compatibility
async function saveDarkModePreference() {
    const themeInput = document.getElementById('themePreference');
    if (themeInput) {
        await saveThemePreference(themeInput.value);
    }
}

// ===================================
// ACCENT COLOR SETTINGS
// ===================================

// Apply accent color theme
function applyAccentColor(accentName, colorData) {
    const isDark = document.body.classList.contains('dark-mode');
    const root = document.documentElement;
    
    // Apply the appropriate colors based on light/dark mode
    if (isDark) {
        root.style.setProperty('--accent', colorData.dark);
        root.style.setProperty('--accent-hover', colorData.darkHover);
        root.style.setProperty('--accent-soft', colorData.darkSoft);
    } else {
        root.style.setProperty('--accent', colorData.color);
        root.style.setProperty('--accent-hover', colorData.hover);
        root.style.setProperty('--accent-soft', colorData.soft);
    }
    
    // Also update the primary-blue alias for backward compatibility
    root.style.setProperty('--primary-blue', isDark ? colorData.dark : colorData.color);
    root.style.setProperty('--primary-dark', isDark ? colorData.darkHover : colorData.hover);
}

// Initialize accent color picker
function initAccentColorPicker() {
    const picker = document.getElementById('accentColorPicker');
    if (!picker) return;
    
    // Load saved accent from localStorage first for instant load
    const savedAccent = localStorage.getItem('accentColor') || 'blue';
    
    // Select the saved option and apply colors
    picker.querySelectorAll('.accent-color-option').forEach(opt => {
        opt.classList.remove('selected');
        if (opt.dataset.accent === savedAccent) {
            opt.classList.add('selected');
            applyAccentColor(savedAccent, {
                color: opt.dataset.color,
                hover: opt.dataset.hover,
                soft: opt.dataset.soft,
                dark: opt.dataset.dark,
                darkHover: opt.dataset.darkHover,
                darkSoft: opt.dataset.darkSoft
            });
        }
    });
    
    // Load from Firestore and override if set
    loadAccentColorPreference().then(accentData => {
        if (accentData && accentData.name) {
            const option = picker.querySelector(`[data-accent="${accentData.name}"]`);
            if (option) {
                picker.querySelectorAll('.accent-color-option').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                applyAccentColor(accentData.name, accentData);
                localStorage.setItem('accentColor', accentData.name);
            }
        }
    });
    
    // Add click handlers for each color option
    picker.querySelectorAll('.accent-color-option').forEach(option => {
        option.addEventListener('click', async () => {
            // Update selected state
            picker.querySelectorAll('.accent-color-option').forEach(opt => opt.classList.remove('selected'));
            option.classList.add('selected');
            
            // Get color data from data attributes
            const accentName = option.dataset.accent;
            const colorData = {
                name: accentName,
                color: option.dataset.color,
                hover: option.dataset.hover,
                soft: option.dataset.soft,
                dark: option.dataset.dark,
                darkHover: option.dataset.darkHover,
                darkSoft: option.dataset.darkSoft
            };
            
            // Apply instantly
            applyAccentColor(accentName, colorData);
            
            // Save to localStorage for instant load next time
            localStorage.setItem('accentColor', accentName);
            
            // Save to Firestore
            await saveAccentColorPreference(colorData);
            
            showToast('Accent color updated', 'success');
        });
    });
    
    // Listen for dark mode changes to re-apply accent with correct dark/light variant
    const darkModeObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.attributeName === 'class') {
                const selectedOption = picker.querySelector('.accent-color-option.selected');
                if (selectedOption) {
                    applyAccentColor(selectedOption.dataset.accent, {
                        color: selectedOption.dataset.color,
                        hover: selectedOption.dataset.hover,
                        soft: selectedOption.dataset.soft,
                        dark: selectedOption.dataset.dark,
                        darkHover: selectedOption.dataset.darkHover,
                        darkSoft: selectedOption.dataset.darkSoft
                    });
                }
            }
        });
    });
    darkModeObserver.observe(document.body, { attributes: true });
}

// Load accent color preference from Firestore
async function loadAccentColorPreference() {
    if (!currentAuthUser || !db) {
        return null;
    }
    
    try {
        const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        const userRef = doc(db, 'users', currentAuthUser.uid);
        const userDoc = await getDoc(userRef);
        
        if (userDoc.exists()) {
            return userDoc.data().preferences?.style?.accentColor || null;
        }
        
        return null;
    } catch (error) {
        console.error('Error loading accent color preference:', error);
        return null;
    }
}

// Save accent color preference to Firestore
async function saveAccentColorPreference(colorData) {
    if (!currentAuthUser || !db) {
        console.warn('Cannot save accent preference - not logged in');
        return;
    }
    
    try {
        await updateUserPreferences({ 
            style: { 
                accentColor: colorData 
            } 
        });
    } catch (error) {
        console.error('Error saving accent color preference:', error);
    }
}

// Apply accent color early (before page fully loads) from localStorage
function applyAccentColorEarly() {
    const savedAccent = localStorage.getItem('accentColor');
    if (!savedAccent || savedAccent === 'blue') return; // Default blue, no need to change
    
    const accentPresets = {
        blue: { color: '#0070F3', hover: '#0051CC', soft: 'rgba(0, 112, 243, 0.12)', dark: '#0A84FF', darkHover: '#0070F3', darkSoft: 'rgba(10, 132, 255, 0.15)' },
        purple: { color: '#AF52DE', hover: '#9340C7', soft: 'rgba(175, 82, 222, 0.12)', dark: '#BF5AF2', darkHover: '#AF52DE', darkSoft: 'rgba(191, 90, 242, 0.15)' },
        green: { color: '#34C759', hover: '#2DB04E', soft: 'rgba(52, 199, 89, 0.12)', dark: '#32D74B', darkHover: '#34C759', darkSoft: 'rgba(50, 215, 75, 0.15)' },
        orange: { color: '#FF9500', hover: '#E68600', soft: 'rgba(255, 149, 0, 0.12)', dark: '#FF9F0A', darkHover: '#FF9500', darkSoft: 'rgba(255, 159, 10, 0.15)' },
        pink: { color: '#FF2D55', hover: '#E6264D', soft: 'rgba(255, 45, 85, 0.12)', dark: '#FF375F', darkHover: '#FF2D55', darkSoft: 'rgba(255, 55, 95, 0.15)' },
        teal: { color: '#00C7BE', hover: '#00ADA6', soft: 'rgba(0, 199, 190, 0.12)', dark: '#64D2FF', darkHover: '#00C7BE', darkSoft: 'rgba(100, 210, 255, 0.15)' }
    };
    
    const preset = accentPresets[savedAccent];
    if (preset) {
        const isDark = localStorage.getItem('darkMode') === 'true';
        const root = document.documentElement;
        
        if (isDark) {
            root.style.setProperty('--accent', preset.dark);
            root.style.setProperty('--accent-hover', preset.darkHover);
            root.style.setProperty('--accent-soft', preset.darkSoft);
        } else {
            root.style.setProperty('--accent', preset.color);
            root.style.setProperty('--accent-hover', preset.hover);
            root.style.setProperty('--accent-soft', preset.soft);
        }
        root.style.setProperty('--primary-blue', isDark ? preset.dark : preset.color);
        root.style.setProperty('--primary-dark', isDark ? preset.darkHover : preset.hover);
    }
}

// Call early application
applyAccentColorEarly();

// ===================================
// ANIMATION SETTINGS
// ===================================

// Default animation preference
const defaultAnimationsEnabled = true;

// Load animation preference
async function loadAnimationPreference() {
    if (!currentAuthUser || !db) {
        // Check system preference as fallback
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        return !prefersReducedMotion;
    }
    
    try {
        const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        const userRef = doc(db, 'users', currentAuthUser.uid);
        const userDoc = await getDoc(userRef);
        
        if (userDoc.exists()) {
            const data = userDoc.data();
            const animationsEnabled = data.preferences?.ui?.animationsEnabled;
            
            // If user hasn't set preference, check system preference
            if (animationsEnabled === undefined) {
                const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                return !prefersReducedMotion;
            }
            
            return animationsEnabled;
        }
    } catch (error) {
        console.error('Error loading animation preference:', error);
    }
    
    // Default to enabled
    return defaultAnimationsEnabled;
}

// Apply animation preference to DOM
function applyAnimationPreference(enabled) {
    console.log('Applying animation preference:', enabled);
    
    if (enabled) {
        document.body.classList.remove('no-animations');
    } else {
        document.body.classList.add('no-animations');
    }
}

// Initialize animations form
function initAnimationsForm() {
    const form = document.getElementById('animationsForm');
    if (!form) return;
    
    // Load and apply current preference
    loadAnimationPreference().then(enabled => {
        document.getElementById('enableAnimations').checked = enabled;
        applyAnimationPreference(enabled);
    });
    
    // Auto-save when toggle changes
    const toggle = document.getElementById('enableAnimations');
    if (toggle) {
        toggle.addEventListener('change', async () => {
            applyAnimationPreference(toggle.checked);
            await saveAnimationPreference();
        });
    }
}

// Save animation preference
async function saveAnimationPreference() {
    if (!currentAuthUser || !db) {
        showToast('Cannot save preferences. Please sign in again.', 'error');
        return;
    }
    
    const enabled = document.getElementById('enableAnimations').checked;
    
    console.log('Saving animation preference:', enabled);
    
    try {
        await updateUserPreferences({ ui: { animationsEnabled: enabled } });
        
        // Apply to UI immediately
        applyAnimationPreference(enabled);
    } catch (error) {
        console.error('Error saving animation preference:', error);
        showToast('Error saving preferences. Please try again.', 'error', 5000, 'Save Failed');
    }
}

// ===================================
// SIDEBAR ICONS TOGGLE
// ===================================

// Initialize sidebar icons toggle
function initSidebarIconsToggle() {
    const toggle = document.getElementById('showSidebarIcons');
    if (!toggle) return;
    
    // Load and apply current preference
    loadSidebarIconsPreference().then(enabled => {
        toggle.checked = enabled;
        applySidebarIconsPreference(enabled);
    });
    
    // Auto-save when toggle changes
    toggle.addEventListener('change', async () => {
        applySidebarIconsPreference(toggle.checked);
        await saveSidebarIconsPreference();
    });
}

// Load sidebar icons preference
async function loadSidebarIconsPreference() {
    if (!currentAuthUser || !db) {
        // Fallback to localStorage if not authenticated
        const stored = localStorage.getItem('sidebarIconsEnabled');
        return stored !== null ? stored === 'true' : true; // Default to enabled
    }
    
    try {
        const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        const userDoc = await getDoc(doc(db, 'users', currentAuthUser.uid));
        if (userDoc.exists()) {
            const preferences = userDoc.data().preferences || {};
            const enabled = preferences.ui?.sidebarIconsEnabled !== false; // Default to true
            // Also save to localStorage for offline access
            localStorage.setItem('sidebarIconsEnabled', enabled);
            return enabled;
        }
    } catch (error) {
        console.error('Error loading sidebar icons preference:', error);
        // Fallback to localStorage on error
        const stored = localStorage.getItem('sidebarIconsEnabled');
        return stored !== null ? stored === 'true' : true;
    }
    return true;
}

// Apply sidebar icons preference
function applySidebarIconsPreference(enabled) {
    const sidebar = document.querySelector('.sidebar');
    if (!sidebar) return;
    
    if (enabled) {
        sidebar.classList.remove('hide-sidebar-icons');
    } else {
        sidebar.classList.add('hide-sidebar-icons');
    }
}

// Save sidebar icons preference
async function saveSidebarIconsPreference() {
    const enabled = document.getElementById('showSidebarIcons')?.checked ?? true;
    
    // Always save to localStorage for immediate persistence
    localStorage.setItem('sidebarIconsEnabled', enabled);
    
    if (!currentAuthUser || !db) {
        console.log('Saving sidebar icons preference to localStorage only (not authenticated)');
        return;
    }
    
    console.log('Saving sidebar icons preference to Firestore:', enabled);
    
    try {
        await updateUserPreferences({ ui: { sidebarIconsEnabled: enabled } });
        
        // Apply to UI immediately
        applySidebarIconsPreference(enabled);
    } catch (error) {
        console.error('Error saving sidebar icons preference:', error);
        showToast('Error saving preferences. Please try again.', 'error', 5000, 'Save Failed');
    }
}

// ===================================
// NOTIFICATION PREFERENCES
// ===================================

// Default notification preferences structure
// Used for new users and as fallback
const defaultNotificationPreferences = {
    tasks: {
        assignedToMe: true,
        taskUpdated: true,
        taskCompleted: false
    },
    chat: {
        mentions: true,
        replies: true
    },
    team: {
        newMembers: true,
        teamChanges: false
    }
};

// Cache for current user's notification preferences
let cachedNotificationPreferences = null;

// Update settings visibility based on user role
function updateSettingsVisibility() {
    const currentUserRole = appState.teammates?.find(t => t.id === currentAuthUser?.uid)?.role;
    const hasTeam = !!appState.currentTeamId;
    
    // Owner-only settings
    const deleteChatHistorySection = document.getElementById('deleteChatHistorySection');
    if (deleteChatHistorySection) {
        deleteChatHistorySection.style.display = (currentUserRole === 'owner' && hasTeam) ? 'block' : 'none';
    }
    
    // Metrics settings (owner only)
    const metricsSettingsCard = document.getElementById('metricsSettingsCard');
    if (metricsSettingsCard) {
        metricsSettingsCard.style.display = (currentUserRole === 'owner' && hasTeam) ? 'block' : 'none';
        // Initialize the form with current value
        if (currentUserRole === 'owner' && hasTeam) {
            initMetricsVisibilityForm();
        }
    }
    
    // Finances settings (owner only)
    const financesSettingsCard = document.getElementById('financesSettingsCard');
    if (financesSettingsCard) {
        financesSettingsCard.style.display = (currentUserRole === 'owner' && hasTeam) ? 'block' : 'none';
        // Initialize the form with current value
        if (currentUserRole === 'owner' && hasTeam) {
            initFinancesVisibilityForm();
        }
    }
    
    // Admin/Owner settings
    const advancedSettingsCard = document.getElementById('settings-chat-appearance-section');
    const animationsSettingsCard = document.getElementById('animationsSettingsCard');
    const advancedSettingsTab = document.getElementById('advancedSettingsTab');
    const isAdminOrOwner = (currentUserRole === 'admin' || currentUserRole === 'owner') && hasTeam;
    
    if (advancedSettingsCard) {
        advancedSettingsCard.style.display = isAdminOrOwner ? 'block' : 'none';
    }
    if (animationsSettingsCard) {
        animationsSettingsCard.style.display = isAdminOrOwner ? 'block' : 'none';
    }
    // Show/hide the Advanced tab in the new settings UI
    if (advancedSettingsTab) {
        advancedSettingsTab.style.display = isAdminOrOwner ? 'inline-block' : 'none';
    }
}

// ===================================
// METRICS VISIBILITY SETTINGS
// ===================================

/**
 * Initialize the metrics visibility form with current setting
 */
function initMetricsVisibilityForm() {
    const form = document.getElementById('metricsVisibilityForm');
    if (!form) return;
    
    // Get current setting from appState
    const currentSetting = appState.metricsVisibility || 'owner-only';
    
    // Select the correct radio button
    const radio = form.querySelector(`input[name="metricsVisibility"][value="${currentSetting}"]`);
    if (radio) {
        radio.checked = true;
    }
    
    // Remove existing listener and add new one
    form.removeEventListener('submit', handleMetricsVisibilitySave);
    form.addEventListener('submit', handleMetricsVisibilitySave);
}

/**
 * Handle metrics visibility form submission
 */
async function handleMetricsVisibilitySave(event) {
    event.preventDefault();
    
    const form = event.target;
    const selectedValue = form.querySelector('input[name="metricsVisibility"]:checked')?.value;
    
    if (!selectedValue) {
        showToast('Please select a visibility option', 'error');
        return;
    }
    
    // Check if user is owner
    const currentUserRole = appState.teammates?.find(t => t.id === currentAuthUser?.uid)?.role;
    if (currentUserRole !== 'owner') {
        showToast('Only the team owner can change metrics visibility', 'error');
        return;
    }
    
    if (!db || !appState.currentTeamId) {
        showToast('Unable to save settings. Please try again.', 'error');
        return;
    }
    
    try {
        const { doc, updateDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        const teamRef = doc(db, 'teams', appState.currentTeamId);
        
        await updateDoc(teamRef, {
            'settings.metricsVisibility': selectedValue
        });
        
        // Update local state
        appState.metricsVisibility = selectedValue;
        
        // Update team data cache
        if (appState.currentTeamData) {
            if (!appState.currentTeamData.settings) {
                appState.currentTeamData.settings = {};
            }
            appState.currentTeamData.settings.metricsVisibility = selectedValue;
        }
        
        // Recompute access for all users (affects current user's view)
        const newAccess = userCanViewMetrics(appState.currentTeamData, currentAuthUser?.uid);
        const oldAccess = appState.metricsAccess;
        appState.metricsAccess = newAccess;
        
        // Update nav visibility
        updateNavVisibilityForMetrics();
        
        // If metrics tab is currently active, refresh it
        if (appState.currentSection === 'metrics') {
            if (newAccess.canAccess) {
                renderMetrics();
            } else {
                // This shouldn't happen for owner, but just in case
                showToast("Access to metrics has changed.", 'info', 3000);
                window.switchTab('activity');
            }
        }
        
        showToast('Metrics visibility settings saved', 'success');
        debugLog('ðŸ“Š Metrics visibility updated to:', selectedValue);
        
    } catch (error) {
        console.error('Error saving metrics visibility:', error);
        showToast('Failed to save metrics settings', 'error');
    }
}

/**
 * Refresh metrics access and nav visibility after team data changes.
 * Call this after loading team data or when settings change.
 */
function refreshMetricsAccess() {
    if (!appState.currentTeamData || !currentAuthUser) {
        appState.metricsAccess = { canAccess: false, mode: 'none' };
        appState.metricsVisibility = 'owner-only';
    } else {
        appState.metricsVisibility = getMetricsVisibilitySetting(appState.currentTeamData);
        appState.metricsAccess = userCanViewMetrics(appState.currentTeamData, currentAuthUser.uid);
    }
    
    // Update nav visibility
    updateNavVisibilityForMetrics();
    
    // If user lost access while on metrics tab, redirect them
    if (appState.currentSection === 'metrics' && !appState.metricsAccess.canAccess) {
        showToast("Your access to metrics has been changed.", 'info', 3000);
        window.switchTab('activity');
    }
}

// ===================================
// FINANCES TAB VISIBILITY SETTINGS
// ===================================

/**
 * Initialize the finances visibility form with current settings
 */
function initFinancesVisibilityForm() {
    const form = document.getElementById('financesVisibilityForm');
    if (!form) return;
    
    // Get current settings from appState
    const isEnabled = appState.financesEnabled || false;
    const currentVisibility = appState.financesVisibility || 'owner-only';
    
    // Set the enabled toggle
    const enabledToggle = document.getElementById('financesEnabledToggle');
    if (enabledToggle) {
        enabledToggle.checked = isEnabled;
    }
    
    // Set the visibility select value (HTML uses select, not radio buttons)
    const visibilitySelect = document.getElementById('financesVisibilitySelect');
    if (visibilitySelect) {
        visibilitySelect.value = currentVisibility;
    }
    
    // Show/hide visibility options based on enabled state
    const visibilityOptions = document.getElementById('financesVisibilityOptions');
    if (visibilityOptions) {
        visibilityOptions.style.display = isEnabled ? 'block' : 'none';
    }
    
    // Add toggle change listener - auto-save on change
    if (enabledToggle) {
        enabledToggle.removeEventListener('change', handleFinancesSettingsChange);
        enabledToggle.addEventListener('change', handleFinancesSettingsChange);
    }
    
    // Add visibility select change listener - auto-save on change
    if (visibilitySelect) {
        visibilitySelect.removeEventListener('change', handleFinancesSettingsChange);
        visibilitySelect.addEventListener('change', handleFinancesSettingsChange);
    }
}

/**
 * Handle finances settings change - auto-save on any change
 */
async function handleFinancesSettingsChange(event) {
    const enabledToggle = document.getElementById('financesEnabledToggle');
    const visibilitySelect = document.getElementById('financesVisibilitySelect');
    const isEnabled = enabledToggle?.checked || false;
    const selectedVisibility = visibilitySelect?.value || 'owner-only';
    
    // Show/hide visibility options based on enabled state
    const visibilityOptions = document.getElementById('financesVisibilityOptions');
    if (visibilityOptions) {
        visibilityOptions.style.display = isEnabled ? 'block' : 'none';
    }
    
    // Auto-save the settings
    await saveFinancesSettings(isEnabled, selectedVisibility);
}

/**
 * Save finances settings to Firestore
 */
async function saveFinancesSettings(isEnabled, selectedVisibility) {
    // Check if user is owner
    const currentUserRole = appState.teammates?.find(t => t.id === currentAuthUser?.uid)?.role;
    if (currentUserRole !== 'owner') {
        // Silently fail for non-owners - they shouldn't see this form anyway
        return;
    }
    
    if (!db || !appState.currentTeamId) {
        return;
    }
    
    try {
        const { doc, updateDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        const teamRef = doc(db, 'teams', appState.currentTeamId);
        
        await updateDoc(teamRef, {
            'settings.financesEnabled': isEnabled,
            'settings.financesVisibility': selectedVisibility
        });
        
        // Update local state
        appState.financesEnabled = isEnabled;
        appState.financesVisibility = selectedVisibility;
        
        // Update team data cache
        if (appState.currentTeamData) {
            if (!appState.currentTeamData.settings) {
                appState.currentTeamData.settings = {};
            }
            appState.currentTeamData.settings.financesEnabled = isEnabled;
            appState.currentTeamData.settings.financesVisibility = selectedVisibility;
        }
        
        // Recompute access
        const newAccess = userCanViewFinances(appState.currentTeamData, currentAuthUser?.uid);
        appState.financesAccess = newAccess;
        
        // Update nav visibility
        updateNavVisibilityForFinances();
        
        // If finances tab is currently active, handle the change
        if (appState.currentSection === 'finances') {
            if (newAccess.canAccess) {
                renderFinances();
            } else {
                showToast("Access to finances has changed.", 'info', 3000);
                window.switchTab('activity');
            }
        }
        
        showToast('Finances settings saved', 'success');
        debugLog('ðŸ’° Finances settings updated:', { isEnabled, selectedVisibility });
        
    } catch (error) {
        console.error('Error saving finances settings:', error);
        showToast('Failed to save finances settings', 'error');
    }
}

/**
 * Refresh finances access and nav visibility after team data changes.
 * Call this after loading team data or when settings change.
 */
function refreshFinancesAccess() {
    if (!appState.currentTeamData || !currentAuthUser) {
        appState.financesAccess = { canAccess: false, mode: 'none' };
        appState.financesEnabled = false;
        appState.financesVisibility = 'owner-only';
    } else {
        appState.financesEnabled = getFinancesEnabledSetting(appState.currentTeamData);
        appState.financesVisibility = getFinancesVisibilitySetting(appState.currentTeamData);
        appState.financesAccess = userCanViewFinances(appState.currentTeamData, currentAuthUser.uid);
    }
    
    // Update nav visibility
    updateNavVisibilityForFinances();
    
    // If user lost access while on finances tab, redirect them
    if (appState.currentSection === 'finances' && !appState.financesAccess.canAccess) {
        showToast("Your access to finances has been changed.", 'info', 3000);
        window.switchTab('activity');
    }
}

// Load notification preferences from Firestore
// Returns merged preferences (defaults + user overrides)
async function loadNotificationPreferences() {
    if (!currentAuthUser || !db) {
        return { ...defaultNotificationPreferences };
    }
    
    try {
        const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        const userRef = doc(db, 'users', currentAuthUser.uid);
        const userDoc = await getDoc(userRef);
        
        if (userDoc.exists()) {
            const data = userDoc.data();
            const savedPrefs = data.preferences?.notificationPreferences || {};
            
            // Deep merge: defaults + saved preferences
            // This ensures new preference keys are added for existing users
            cachedNotificationPreferences = {
                tasks: { ...defaultNotificationPreferences.tasks, ...savedPrefs.tasks },
                chat: { ...defaultNotificationPreferences.chat, ...savedPrefs.chat },
                team: { ...defaultNotificationPreferences.team, ...savedPrefs.team }
            };
            
            return cachedNotificationPreferences;
        }
        
        cachedNotificationPreferences = { ...defaultNotificationPreferences };
        return cachedNotificationPreferences;
    } catch (error) {
        console.error('Error loading notification preferences:', error);
        return { ...defaultNotificationPreferences };
    }
}

// Get cached notification preferences (synchronous)
// Falls back to defaults if cache is empty
function getNotificationPreferences() {
    return cachedNotificationPreferences || { ...defaultNotificationPreferences };
}

// Initialize notification preferences form
// Sets up toggles and event listeners
async function initNotificationForm() {
    const form = document.getElementById('notificationsForm');
    if (!form) return;
    
    console.log('ðŸ“‹ Initializing notification form...');
    const preferences = await loadNotificationPreferences();
    console.log('Loaded notification preferences:', preferences);
    
    // Map of toggle IDs to preference paths
    const toggleMap = {
        'notifTaskAssigned': { category: 'tasks', key: 'assignedToMe' },
        'notifTaskUpdated': { category: 'tasks', key: 'taskUpdated' },
        'notifTaskCompleted': { category: 'tasks', key: 'taskCompleted' },
        'notifChatMentions': { category: 'chat', key: 'mentions' },
        'notifChatReplies': { category: 'chat', key: 'replies' },
        'notifTeamMembers': { category: 'team', key: 'newMembers' },
        'notifTeamChanges': { category: 'team', key: 'teamChanges' }
    };
    
    // Initialize each toggle with saved value and add change listener
    Object.entries(toggleMap).forEach(([toggleId, { category, key }]) => {
        const toggle = document.getElementById(toggleId);
        if (toggle) {
            // Set initial state from preferences
            const savedValue = preferences[category]?.[key];
            const defaultValue = defaultNotificationPreferences[category][key];
            toggle.checked = savedValue ?? defaultValue;
            console.log(`  Toggle ${toggleId}: ${toggle.checked} (saved: ${savedValue}, default: ${defaultValue})`);
            
            // Add change listener for instant save
            toggle.addEventListener('change', async () => {
                await saveNotificationPreference(category, key, toggle.checked);
            });
        }
    });
}

// Save a single notification preference
// Updates Firestore and local cache
async function saveNotificationPreference(category, key, value) {
    if (!currentAuthUser || !db) {
        showToast('Cannot save preferences. Please sign in again.', 'error');
        return;
    }
    
    try {
        // Update local cache first for responsive UI
        if (!cachedNotificationPreferences) {
            cachedNotificationPreferences = { ...defaultNotificationPreferences };
        }
        if (!cachedNotificationPreferences[category]) {
            cachedNotificationPreferences[category] = {};
        }
        cachedNotificationPreferences[category][key] = value;
        
        // Save to Firestore
        console.log(`ðŸ’¾ Saving notification preference: ${category}.${key} = ${value}`);
        console.log('Full preferences being saved:', cachedNotificationPreferences);
        await updateUserPreferences({ 
            notificationPreferences: cachedNotificationPreferences 
        });
        
        console.log(`âœ… Notification preference saved successfully: ${category}.${key} = ${value}`);
        debugLog(`âœ… Notification preference saved: ${category}.${key} = ${value}`);
    } catch (error) {
        console.error('âŒ Error saving notification preference:', error);
        showToast('Error saving preference. Please try again.', 'error');
    }
}

// Check if a notification should be shown based on user preferences
// activityType: 'task', 'message', 'team', 'calendar'
// activityContext: additional context like 'assigned', 'completed', 'mention', etc.
function shouldShowNotification(activityType, activityContext = {}) {
    const prefs = getNotificationPreferences();
    
    switch (activityType) {
        case 'task':
            // Check specific task notification types
            if (activityContext.isAssignment) {
                return prefs.tasks?.assignedToMe !== false;
            }
            if (activityContext.isCompletion) {
                return prefs.tasks?.taskCompleted !== false;
            }
            // Default: task updates
            return prefs.tasks?.taskUpdated !== false;
            
        case 'message':
            // Check specific chat notification types
            if (activityContext.isMention) {
                return prefs.chat?.mentions !== false;
            }
            if (activityContext.isReply) {
                return prefs.chat?.replies !== false;
            }
            // Default: show all chat (can be extended later)
            return true;
            
        case 'team':
            // Check specific team notification types
            if (activityContext.isNewMember) {
                return prefs.team?.newMembers !== false;
            }
            if (activityContext.isSettingsChange) {
                return prefs.team?.teamChanges !== false;
            }
            // Default: show team activity
            return true;
            
        case 'calendar':
            // Calendar notifications always shown (could add preferences later)
            return true;
            
        default:
            return true;
    }
}

// ===================================
// TEAM MEMBERS REAL-TIME LISTENER
// ===================================

let teamMembersUnsubscribe = null;
let userProfileUnsubscribes = []; // Array of unsubscribe functions for user profile listeners

// Start listening for team member changes (name updates, role changes, etc.)
async function startTeamMembersListener() {
    if (!db || !currentAuthUser || !appState.currentTeamId) {
        return;
    }
    
    // Clean up existing listeners
    stopTeamMembersListener();
    
    try {
        const { doc, onSnapshot } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const teamRef = doc(db, 'teams', appState.currentTeamId);
        
        // Listen for changes to team document (includes member list and member info)
        teamMembersUnsubscribe = onSnapshot(teamRef, async (docSnapshot) => {
            if (!docSnapshot.exists()) return;
            
            const teamData = docSnapshot.data();
            const members = teamData.members || {};
            
            // Update team data in appState
            appState.currentTeamData = teamData;
            
            // Reload public profiles for identity resolution
            await loadPublicProfilesForTeam();
            
            // Set up listeners for each team member's user profile
            setupUserProfileListeners(Object.keys(members));
            
            // Reload teammates with latest data from user profiles
            await loadTeammatesFromFirestore();
            
            // Update UI elements that show team member info
            populateTaskAssigneeDropdown();
            
            debugLog('ðŸ”„ Team members updated in real-time');
        }, (error) => {
            // Handle Firestore listener errors (permission-denied, network issues, etc.)
            if (error.code === 'permission-denied') {
                debugLog('âš ï¸ Team members listener: permission denied');
            } else if (error.code === 'unavailable' || error.code === 'deadline-exceeded') {
                debugLog('âš ï¸ Team members listener temporarily unavailable, will auto-retry');
            } else {
                console.error('Error in team members listener:', error.code || error.message);
            }
        });
        
        debugLog('ðŸ‘¥ Team members listener started');
    } catch (error) {
        console.error('Error setting up team members listener:', error);
    }
}

// Set up listeners for individual user profile changes
async function setupUserProfileListeners(memberUserIds) {
    if (!db || !memberUserIds || memberUserIds.length === 0) return;
    
    try {
        const { doc, onSnapshot } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        // Clear old user profile listeners
        userProfileUnsubscribes.forEach(unsub => {
            if (typeof unsub === 'function') unsub();
        });
        userProfileUnsubscribes = [];
        
        // Set up listener for each team member's user profile
        memberUserIds.forEach(userId => {
            const userRef = doc(db, 'users', userId);
            
            const unsubscribe = onSnapshot(userRef, async (userDocSnapshot) => {
                if (!userDocSnapshot.exists()) return;
                
                // User profile changed - reload teammates to get updated names
                await loadTeammatesFromFirestore();
                
                // Update UI elements that show team member info
                populateTaskAssigneeDropdown();
                
                debugLog(`ðŸ”„ User profile updated for ${userId}`);
            }, (error) => {
                // Handle Firestore listener errors (permission-denied, network issues, etc.)
                if (error.code === 'permission-denied') {
                    debugLog(`âš ï¸ User profile listener for ${userId}: permission denied`);
                } else if (error.code === 'unavailable' || error.code === 'deadline-exceeded') {
                    debugLog(`âš ï¸ User profile listener for ${userId} temporarily unavailable`);
                } else {
                    console.error(`Error in user profile listener for ${userId}:`, error.code || error.message);
                }
            });
            
            userProfileUnsubscribes.push(unsubscribe);
        });
        
        debugLog(`ðŸ‘¤ User profile listeners set up for ${memberUserIds.length} members`);
    } catch (error) {
        console.error('Error setting up user profile listeners:', error);
    }
}

// Stop team members listener
function stopTeamMembersListener() {
    if (teamMembersUnsubscribe) {
        teamMembersUnsubscribe();
        teamMembersUnsubscribe = null;
    }
    
    // Clean up user profile listeners
    userProfileUnsubscribes.forEach(unsub => {
        if (typeof unsub === 'function') unsub();
    });
    userProfileUnsubscribes = [];
    
    debugLog('ðŸ‘¥ Team members listeners stopped');
}

// ===================================
// SECURITY SETTINGS - FORCE LOGOUT
// ===================================

let forceLogoutUnsubscribe = null;

// Show logout all devices modal
window.showLogoutAllModal = function() {
    openModal('logoutAllModal');
};

// Send password reset email from settings
window.sendPasswordResetFromSettings = async function() {
    if (!currentAuthUser) {
        showToast('Please sign in to change your password.', 'error', 5000, 'Authentication Required');
        return;
    }
    
    const email = currentAuthUser.email;
    
    if (!email) {
        showToast('No email address associated with this account.', 'error', 5000, 'Error');
        return;
    }
    
    try {
        const { sendPasswordResetEmail } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-auth.js');
        
        await sendPasswordResetEmail(auth, email);
        
        showToast(
            `Password reset link sent to ${email}. Check your inbox and spam folder.`,
            'success',
            7000,
            'Email Sent'
        );
        
    } catch (error) {
        console.error('Error sending password reset email:', error);
        
        let errorMessage = 'Failed to send reset email. Please try again.';
        
        if (error.code === 'auth/too-many-requests') {
            errorMessage = 'Too many requests. Please wait a few minutes and try again.';
        } else if (error.code === 'auth/user-not-found') {
            errorMessage = 'No account found with this email address.';
        }
        
        showToast(errorMessage, 'error', 5000, 'Reset Failed');
    }
};

// Force logout from all devices
async function forceLogoutEverywhere() {
    if (!currentAuthUser || !db) {
        showToast('Cannot perform this action. Please sign in again.', 'error');
        return;
    }
    
    try {
        const { doc, updateDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        // Update the forceLogoutAt timestamp in user document
        const userRef = doc(db, 'users', currentAuthUser.uid);
        await updateDoc(userRef, {
            'preferences.security.forceLogoutAt': Date.now()
        });
        
        console.log('Force logout timestamp set - signing out');
        
        // Sign out current session
        await signOutUser();
        
    } catch (error) {
        console.error('Error forcing logout:', error);
        showToast('Error logging out of all devices. Please try again.', 'error', 5000, 'Logout Failed');
    }
}

// Start listening for force logout events
function startForceLogoutListener() {
    if (!currentAuthUser || !db || forceLogoutUnsubscribe) {
        return; // Already listening or not ready
    }
    
    (async () => {
        try {
            const { doc, onSnapshot } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
            
            const userRef = doc(db, 'users', currentAuthUser.uid);
            
            // Listen for changes to user document
            forceLogoutUnsubscribe = onSnapshot(userRef, (docSnapshot) => {
                if (!docSnapshot.exists()) return;
                
                const data = docSnapshot.data();
                const forceLogoutAt = data.preferences?.security?.forceLogoutAt;
                
                // Check if force logout timestamp exists and is valid
                if (forceLogoutAt && typeof forceLogoutAt === 'number') {
                    const sessionLoginAt = parseInt(localStorage.getItem('sessionLoginAt')) || 0;
                    
                    // If force logout timestamp is newer than session start, sign out
                    if (forceLogoutAt > sessionLoginAt) {
                        console.log('Force logout detected - session invalidated');
                        
                        // Unsubscribe to prevent multiple triggers
                        if (forceLogoutUnsubscribe) {
                            forceLogoutUnsubscribe();
                            forceLogoutUnsubscribe = null;
                        }
                        
                        // Show message and sign out
                        showToast('You have been signed out from all devices.', 'info', 5000, 'Session Ended');
                        
                        setTimeout(() => {
                            signOutUser();
                        }, 1000);
                    }
                }
            }, (error) => {
                console.error('Error listening for force logout:', error);
            });
            
        } catch (error) {
            console.error('Error setting up force logout listener:', error);
        }
    })();
}

// Clean up listener on sign out (called in signOutUser)
function stopForceLogoutListener() {
    if (forceLogoutUnsubscribe) {
        forceLogoutUnsubscribe();
        forceLogoutUnsubscribe = null;
    }
}

// ===================================
// UTILITY FUNCTIONS
// ===================================
function formatTime(date) {
    return date.toLocaleTimeString('en-US', { 
        hour: 'numeric', 
        minute: '2-digit',
        hour12: true 
    });
}

function getTimeAgo(timestamp) {
    const now = new Date();
    const past = new Date(timestamp);
    const diffInSeconds = Math.floor((now - past) / 1000);

    if (diffInSeconds < 60) return 'Just now';
    if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)} minutes ago`;
    if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)} hours ago`;
    if (diffInSeconds < 604800) return `${Math.floor(diffInSeconds / 86400)} days ago`;
    return past.toLocaleDateString();
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function saveToLocalStorage(key, data) {
    try {
        localStorage.setItem(key, JSON.stringify(data));
    } catch (error) {
        console.error('Error saving to localStorage:', error.code || error.message);
        debugError('Full error:', error);
    }
}

function loadFromLocalStorage(key) {
    try {
        const data = localStorage.getItem(key);
        return data ? JSON.parse(data) : null;
    } catch (error) {
        console.error('Error loading from localStorage:', error.code || error.message);
        debugError('Full error:', error);
        return null;
    }
}

// Clean up old tasks that don't exist in Firestore
async function cleanupOldTasks() {
    if (!db || !currentAuthUser || !appState.currentTeamId) return;
    
    try {
        debugLog('ðŸ§¹ Cleaning up old tasks from localStorage...');
        
        const { collection, getDocs } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        // Get all tasks from Firestore
        const tasksRef = collection(db, 'teams', appState.currentTeamId, 'tasks');
        const querySnapshot = await getDocs(tasksRef);
        const firestoreTaskIds = new Set();
        
        querySnapshot.forEach((doc) => {
            firestoreTaskIds.add(doc.id);
        });
        
        // Filter local tasks to only keep those that exist in Firestore
        const localTasks = loadFromLocalStorage('tasks') || [];
        const validTasks = localTasks.filter(task => firestoreTaskIds.has(String(task.id)));
        
        if (validTasks.length < localTasks.length) {
            debugLog(`ðŸ—‘ï¸ Removed ${localTasks.length - validTasks.length} old tasks from localStorage`);
            saveToLocalStorage('tasks', validTasks);
            appState.tasks = validTasks;
        } else {
            debugLog('âœ… No old tasks to clean up');
        }
    } catch (error) {
        console.error('Error cleaning up old tasks:', error.code || error.message);
        debugError('Full error:', error);
    }
}

// ===================================
// TEAM SECTION MANAGEMENT
// ===================================

// Initialize and display team section
async function initTeamSection() {
    if (!currentAuthUser || !db) {
        debugLog('Cannot init team section: no auth or db');
        return;
    }
    
    const hasTeam = appState.currentTeamId && appState.teammates.length > 0;
    const memberCount = appState.teammates.length;
    
    const teamOverviewCard = document.getElementById('teamOverviewCard');
    const noTeamCard = document.getElementById('noTeamCard');
    const joinTeamHeaderBtn = document.getElementById('joinTeamHeaderBtn');
    const leaveTeamHeaderBtn = document.getElementById('leaveTeamHeaderBtn');
    
    // Button visibility logic
    if (!hasTeam || memberCount === 1) {
        // Show "Join Team" button if no team or alone in team
        if (joinTeamHeaderBtn) joinTeamHeaderBtn.style.display = 'inline-flex';
        if (leaveTeamHeaderBtn) leaveTeamHeaderBtn.style.display = 'none';
    } else if (memberCount >= 2) {
        // Show "Leave Team" button if 2+ members
        if (joinTeamHeaderBtn) joinTeamHeaderBtn.style.display = 'none';
        if (leaveTeamHeaderBtn) leaveTeamHeaderBtn.style.display = 'inline-flex';
    }
    
    if (hasTeam) {
        // Show team overview
        if (teamOverviewCard) teamOverviewCard.style.display = 'block';
        if (noTeamCard) noTeamCard.style.display = 'none';
        
        await displayTeamSection();
    } else {
        // Show no team state
        if (teamOverviewCard) teamOverviewCard.style.display = 'none';
        if (noTeamCard) noTeamCard.style.display = 'block';
    }
}

// Display comprehensive team section
async function displayTeamSection() {
    if (!db || !currentAuthUser || !appState.currentTeamId) return;
    
    try {
        const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const teamRef = doc(db, 'teams', appState.currentTeamId);
        const teamDoc = await getDoc(teamRef);
        
        if (!teamDoc.exists()) {
            console.error('Team not found');
            debugError('Team ID:', appState.currentTeamId);
            return;
        }
        
        const teamData = teamDoc.data();
        
        // Update team name and code
        const teamNameDisplay = document.getElementById('teamNameDisplay');
        const teamCodeDisplay = document.getElementById('teamCodeDisplay');
        const teamMemberCount = document.getElementById('teamMemberCount');
        
        if (teamNameDisplay) teamNameDisplay.textContent = teamData.name || 'My Team';
        if (teamCodeDisplay) teamCodeDisplay.textContent = teamData.teamCode || '------';
        if (teamMemberCount) teamMemberCount.textContent = appState.teammates.length;
        
        // Show/hide leave button - everyone can leave the team now
        const leaveTeamBtn = document.getElementById('leaveTeamBtn');
        if (leaveTeamBtn) {
            leaveTeamBtn.style.display = 'inline-flex';
        }
        
        // Display current user's role
        const currentUserRole = getCurrentUserRole(teamData);
        const roleDisplay = document.getElementById('currentUserRoleDisplay');
        const roleBadge = document.getElementById('currentUserRoleBadge');
        if (roleDisplay && roleBadge) {
            roleDisplay.style.display = 'block';
            roleBadge.className = `member-role-badge ${currentUserRole}`;
            roleBadge.textContent = currentUserRole === 'owner' ? 'OWNER' : 
                                   currentUserRole === 'admin' ? 'ADMIN' : 'MEMBER';
        }
        
        // Show role info section
        const roleInfoSection = document.getElementById('roleInfoSection');
        if (roleInfoSection) {
            roleInfoSection.style.display = 'block';
        }
        
        // Show/hide team name edit button (owner-only)
        const editTeamNameBtn = document.getElementById('editTeamNameBtn');
        if (editTeamNameBtn) {
            editTeamNameBtn.style.display = isOwner(teamData) ? 'inline-flex' : 'none';
        }
        
        // Initialize team name editing (owner-only)
        initTeamNameEditing(teamData);
        
        // Display team members
        displayTeamMembers(teamData);
        
        // Display join requests (only for admin/owner)
        if (isAdmin(teamData)) {
            await displayJoinRequests();
        } else {
            // Hide join requests section for non-admins
            const joinRequestsSection = document.getElementById('joinRequestsSection');
            if (joinRequestsSection) {
                joinRequestsSection.style.display = 'none';
            }
        }
        
    } catch (error) {
        console.error('Error displaying team section:', error.code || error.message);
        debugError('Full error:', error);
    }
}

/**
 * Initialize team name editing functionality (Owner-only)
 * Allows owner to click edit button, modify name, and save to Firestore
 */
function initTeamNameEditing(teamData) {
    const editBtn = document.getElementById('editTeamNameBtn');
    const saveBtn = document.getElementById('saveTeamNameBtn');
    const cancelBtn = document.getElementById('cancelTeamNameBtn');
    const nameDisplay = document.getElementById('teamNameDisplay');
    const nameWrapper = document.querySelector('.team-name-wrapper');
    const editWrapper = document.getElementById('teamNameEditWrapper');
    const nameInput = document.getElementById('teamNameInput');
    
    if (!editBtn || !saveBtn || !cancelBtn || !nameDisplay || !nameWrapper || !editWrapper || !nameInput) return;
    
    // Only allow editing for owners
    if (!isOwner(teamData)) return;
    
    // Remove old event listeners by cloning elements
    const newEditBtn = editBtn.cloneNode(true);
    const newSaveBtn = saveBtn.cloneNode(true);
    const newCancelBtn = cancelBtn.cloneNode(true);
    editBtn.parentNode.replaceChild(newEditBtn, editBtn);
    saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
    cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
    
    // Enter edit mode
    newEditBtn.addEventListener('click', () => {
        nameInput.value = nameDisplay.textContent;
        nameWrapper.style.display = 'none';
        editWrapper.style.display = 'flex';
        nameInput.focus();
        nameInput.select();
    });
    
    // Cancel editing
    newCancelBtn.addEventListener('click', () => {
        editWrapper.style.display = 'none';
        nameWrapper.style.display = 'flex';
    });
    
    // Save team name
    newSaveBtn.addEventListener('click', () => saveTeamName());
    
    // Save on Enter key
    nameInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            saveTeamName();
        } else if (e.key === 'Escape') {
            editWrapper.style.display = 'none';
            nameWrapper.style.display = 'flex';
        }
    });
    
    async function saveTeamName() {
        const newName = nameInput.value.trim();
        
        if (!newName) {
            showToast('Team name cannot be empty', 'error');
            return;
        }
        
        if (newName === nameDisplay.textContent) {
            // No change, just close
            editWrapper.style.display = 'none';
            nameWrapper.style.display = 'flex';
            return;
        }
        
        try {
            const { doc, updateDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
            
            // Update Firestore
            const teamRef = doc(db, 'teams', appState.currentTeamId);
            await updateDoc(teamRef, { 
                name: newName,
                updatedAt: serverTimestamp()
            });
            
            // Update UI immediately
            nameDisplay.textContent = newName;
            editWrapper.style.display = 'none';
            nameWrapper.style.display = 'flex';
            
            showToast('Team name updated', 'success');
            
        } catch (error) {
            console.error('Error updating team name:', error);
            if (error.code === 'permission-denied') {
                showToast('Only team owners can rename the team', 'error');
            } else {
                showToast('Failed to update team name', 'error');
            }
        }
    }
}

// Display team members in grid
function displayTeamMembers(teamData) {
    const grid = document.getElementById('teamMembersGrid');
    if (!grid) return;
    
    grid.innerHTML = '';
    
    if (!appState.teammates || appState.teammates.length === 0) {
        grid.innerHTML = '<p style="text-align: center; color: var(--gray); grid-column: 1/-1;">No team members yet.</p>';
        return;
    }
    
    appState.teammates.forEach(teammate => {
        const card = createTeamMemberCard(teammate, teamData);
        grid.appendChild(card);
    });
    
    // Load pending leave requests for admins
    loadAndDisplayPendingLeaveRequests(teamData);
}

// Load and display pending leave requests (admin only)
async function loadAndDisplayPendingLeaveRequests(teamData) {
    const section = document.getElementById('pendingLeaveRequestsSection');
    const list = document.getElementById('pendingLeaveRequestsList');
    
    if (!section || !list) return;
    
    // Check if current user is admin/owner
    const currentUserRole = teamData?.members?.[currentAuthUser?.uid]?.role;
    if (currentUserRole !== 'admin' && currentUserRole !== 'owner') {
        section.style.display = 'none';
        return;
    }
    
    try {
        const requests = await loadPendingLeaveRequests();
        
        if (!requests || requests.length === 0) {
            section.style.display = 'none';
            return;
        }
        
        section.style.display = 'block';
        list.innerHTML = '';
        
        requests.forEach(request => {
            const requestEl = document.createElement('div');
            requestEl.className = 'leave-request-item';
            
            const timeAgo = request.requestedAt?.toDate ? 
                formatTimeAgo(request.requestedAt.toDate()) : 'Recently';
            
            requestEl.innerHTML = `
                <div class="leave-request-info">
                    <span class="leave-request-name">${escapeHtml(request.userName || request.userEmail)}</span>
                    <span class="leave-request-time">Requested ${timeAgo}</span>
                </div>
                <div class="leave-request-actions">
                    <button class="btn-approve-leave" onclick="approveLeaveRequest('${request.id}', '${request.userId}', '${escapeHtml(request.userName || 'User')}')">
                        <i class="fas fa-check"></i> Approve
                    </button>
                    <button class="btn-deny-leave" onclick="denyLeaveRequest('${request.id}', '${escapeHtml(request.userName || 'User')}')">
                        <i class="fas fa-times"></i> Deny
                    </button>
                </div>
            `;
            
            list.appendChild(requestEl);
        });
        
    } catch (error) {
        console.error('Error loading leave requests:', error);
        section.style.display = 'none';
    }
}

// Create enhanced team member card
function createTeamMemberCard(member, teamData) {
    const card = document.createElement('div');
    card.className = 'team-member-card';
    card.dataset.memberId = member.id; // Store member ID for navigation
    
    // Determine role display
    const role = member.role || 'member';
    const roleBadge = role;
    const roleDisplay = role === 'owner' ? 'OWNER' : role === 'admin' ? 'ADMIN' : 'MEMBER';
    const jobPosition = member.occupation || 'No position set';
    
    // Get avatar initials and color
    const initials = member.avatar || generateAvatar(member.name);
    const avatarColor = member.avatarColor || '#0078D4';
    const darkerColor = shadeColor(avatarColor, -20);
    
    // Create member header
    const headerDiv = document.createElement('div');
    headerDiv.className = 'member-header';
    
    const avatarDiv = document.createElement('div');
    avatarDiv.className = 'member-avatar';
    avatarDiv.style.background = `linear-gradient(135deg, ${avatarColor} 0%, ${darkerColor} 100%)`;
    avatarDiv.textContent = initials; // Use textContent for initials
    
    const infoDiv = document.createElement('div');
    infoDiv.className = 'member-info';
    
    const nameDiv = document.createElement('div');
    nameDiv.className = 'member-name';
    nameDiv.textContent = member.name; // Use textContent for name
    
    const emailDiv = document.createElement('div');
    emailDiv.className = 'member-email';
    emailDiv.textContent = member.email; // Use textContent for email
    
    infoDiv.appendChild(nameDiv);
    infoDiv.appendChild(emailDiv);
    headerDiv.appendChild(avatarDiv);
    headerDiv.appendChild(infoDiv);
    
    // Create member details
    const detailsDiv = document.createElement('div');
    detailsDiv.className = 'member-details';
    
    // Job position row
    const jobRow = document.createElement('div');
    jobRow.className = 'member-detail-row';
    const briefcaseIcon = document.createElement('i');
    briefcaseIcon.className = 'fas fa-briefcase';
    const jobSpan = document.createElement('span');
    jobSpan.textContent = jobPosition; // Use textContent for job position
    jobRow.appendChild(briefcaseIcon);
    jobRow.appendChild(jobSpan);
    
    // Role row
    const roleRow = document.createElement('div');
    roleRow.className = 'member-detail-row';
    const shieldIcon = document.createElement('i');
    shieldIcon.className = 'fas fa-shield-alt';
    const roleSpan = document.createElement('span');
    roleSpan.className = `member-role-badge ${roleBadge}`;
    roleSpan.textContent = roleDisplay; // Use textContent for role
    roleRow.appendChild(shieldIcon);
    roleRow.appendChild(roleSpan);
    
    detailsDiv.appendChild(jobRow);
    detailsDiv.appendChild(roleRow);
    
    // Joined date row (optional)
    if (member.joinedAt) {
        const joinRow = document.createElement('div');
        joinRow.className = 'member-detail-row';
        const calendarIcon = document.createElement('i');
        calendarIcon.className = 'fas fa-calendar-plus';
        const joinSpan = document.createElement('span');
        joinSpan.textContent = 'Joined ' + formatDate(member.joinedAt); // Use textContent for date
        joinRow.appendChild(calendarIcon);
        joinRow.appendChild(joinSpan);
        detailsDiv.appendChild(joinRow);
    }
    
    card.appendChild(headerDiv);
    card.appendChild(detailsDiv);
    
    // Add role management actions (only for owners)
    const currentUserRole = getCurrentUserRole(teamData);
    const isCurrentUser = currentAuthUser && member.id === currentAuthUser.uid;
    
    if (currentUserRole === 'owner' && !isCurrentUser && role !== 'owner') {
        const actionsDiv = document.createElement('div');
        actionsDiv.className = 'member-actions';
        
        // Promote/Demote buttons
        if (role === 'member') {
            const promoteBtn = document.createElement('button');
            promoteBtn.className = 'btn-role-action promote';
            promoteBtn.innerHTML = '<i class="fas fa-arrow-up"></i> Promote';
            promoteBtn.onclick = () => {
                console.log('Promote button clicked for:', member.id, member.name);
                console.log('showPromoteModal function exists:', typeof window.showPromoteModal);
                if (window.showPromoteModal) {
                    window.showPromoteModal(member.id, member.name);
                } else {
                    console.error('showPromoteModal is not defined!');
                }
            };
            actionsDiv.appendChild(promoteBtn);
        } else if (role === 'admin') {
            const demoteBtn = document.createElement('button');
            demoteBtn.className = 'btn-role-action demote';
            demoteBtn.innerHTML = '<i class="fas fa-arrow-down"></i> Demote';
            demoteBtn.onclick = () => {
                console.log('Demote button clicked for:', member.id, member.name);
                console.log('showDemoteModal function exists:', typeof window.showDemoteModal);
                if (window.showDemoteModal) {
                    window.showDemoteModal(member.id, member.name);
                } else {
                    console.error('showDemoteModal is not defined!');
                }
            };
            actionsDiv.appendChild(demoteBtn);
        }
        
        // Kick button
        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn-role-action remove';
        removeBtn.innerHTML = '<i class="fas fa-user-times"></i> Kick';
        removeBtn.onclick = () => {
            console.log('Kick button clicked for:', member.id, member.name);
            console.log('showKickModal function exists:', typeof window.showKickModal);
            if (window.showKickModal) {
                window.showKickModal(member.id, member.name);
            } else {
                console.error('showKickModal is not defined!');
            }
        };
        actionsDiv.appendChild(removeBtn);
        
        card.appendChild(actionsDiv);
    }
    
    return card;
}

// Format timestamp to readable date
function formatDate(timestamp) {
    if (!timestamp) return 'Unknown';
    
    let date;
    if (timestamp.toDate) {
        date = timestamp.toDate();
    } else if (timestamp instanceof Date) {
        date = timestamp;
    } else {
        date = new Date(timestamp);
    }
    
    // Return formatted date: e.g., "Oct 25, 2025"
    return date.toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'short', 
        day: 'numeric'
    });
}

// ===================================
// ROLE MANAGEMENT FUNCTIONS
// ===================================
// Modal functions for promote, demote, and kick
// (Variables declared at top of file before event listeners)

window.showPromoteModal = function(userId, userName) {
    console.log('showPromoteModal called with:', userId, userName);
    window.pendingPromoteUserId = userId;
    window.pendingPromoteUserName = userName;
    console.log('pendingPromoteUserId set to:', window.pendingPromoteUserId);
    
    const modalElement = document.getElementById('promoteModal');
    const nameElement = document.getElementById('promoteMemberName');
    
    console.log('Modal element:', modalElement);
    console.log('Name element:', nameElement);
    
    if (nameElement) {
        nameElement.textContent = userName;
    }
    if (modalElement) {
        modalElement.classList.add('active');
        console.log('Modal should now be visible');
    } else {
        console.error('promoteModal element not found!');
    }
};

window.closePromoteModal = function() {
    document.getElementById('promoteModal').classList.remove('active');
    window.pendingPromoteUserId = null;
    window.pendingPromoteUserName = null;
};

window.showDemoteModal = function(userId, userName) {
    window.pendingDemoteUserId = userId;
    window.pendingDemoteUserName = userName;
    document.getElementById('demoteMemberName').textContent = userName;
    document.getElementById('demoteModal').classList.add('active');
};

window.closeDemoteModal = function() {
    document.getElementById('demoteModal').classList.remove('active');
    window.pendingDemoteUserId = null;
    window.pendingDemoteUserName = null;
};

window.showKickModal = function(userId, userName) {
    window.pendingKickUserId = userId;
    window.pendingKickUserName = userName;
    document.getElementById('kickMemberName').textContent = userName;
    document.getElementById('kickModal').classList.add('active');
};

window.closeKickModal = function() {
    document.getElementById('kickModal').classList.remove('active');
    window.pendingKickUserId = null;
    window.pendingKickUserName = null;
};

// Make clearAllMessages globally accessible
window.clearAllMessages = clearAllMessages;

async function promoteToAdmin(userId, userName) {
    if (!db || !currentAuthUser || !appState.currentTeamId) {
        showToast('Error: Cannot promote user', 'error');
        return;
    }
    
    // Check current user's role
    const currentUserRole = appState.teammates.find(t => t.id === currentAuthUser.uid)?.role;
    console.log('Current user role:', currentUserRole);
    console.log('Attempting to promote user:', userId, 'to admin');
    
    // Check permission client-side
    if (currentUserRole !== 'owner') {
        showToast('Only owners can promote users', 'error');
        return;
    }
    
    try {
        const { doc, updateDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const teamRef = doc(db, 'teams', appState.currentTeamId);
        await updateDoc(teamRef, {
            [`members.${userId}.role`]: 'admin'
        });
        
        debugLog('âœ… Promoted user to admin:', userId);
        
        // Add activity
        addActivity({
            type: 'team',
            description: `promoted ${userName} to Admin`
        });
        
        showToast(`${userName} has been promoted to Admin`, 'success', 3000);
        
        // Reload team members to show updated role
        console.log('ðŸ”„ Reloading team members after promotion...');
        const { getDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        await loadTeammatesFromFirestore();
        
        // Refresh the team section display with updated data
        const updatedTeamData = (await getDoc(teamRef)).data();
        console.log('ðŸ“Š Updated team data:', updatedTeamData);
        if (updatedTeamData) {
            displayTeamMembers(updatedTeamData);
            console.log('âœ… Team members display refreshed');
        }
        
    } catch (error) {
        console.error('Error promoting user:', error.code || error.message);
        console.error('Full error object:', error);
        showToast('Failed to promote user. Make sure Firestore rules are deployed.', 'error');
    }
}

async function demoteToMember(userId, userName) {
    if (!db || !currentAuthUser || !appState.currentTeamId) {
        showToast('Error: Cannot demote user', 'error');
        return;
    }
    
    try {
        const { doc, updateDoc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const teamRef = doc(db, 'teams', appState.currentTeamId);
        await updateDoc(teamRef, {
            [`members.${userId}.role`]: 'member'
        });
        
        debugLog('âœ… Demoted user to member:', userId);
        
        // Add activity
        addActivity({
            type: 'team',
            description: `demoted ${userName} to Member`
        });
        
        showToast(`${userName} has been demoted to Member`, 'success', 3000);
        
        // Reload team members to show updated role
        console.log('ðŸ”„ Reloading team members after demotion...');
        await loadTeammatesFromFirestore();
        
        // Refresh the team section display with updated data
        const updatedTeamData = (await getDoc(teamRef)).data();
        console.log('ðŸ“Š Updated team data:', updatedTeamData);
        if (updatedTeamData) {
            displayTeamMembers(updatedTeamData);
            console.log('âœ… Team members display refreshed');
        }
        
    } catch (error) {
        console.error('Error demoting user:', error.code || error.message);
        debugError('Full error:', error);
        showToast('Failed to demote user. Please try again.', 'error');
    }
}

async function removeMember(userId, userName) {
    if (!db || !currentAuthUser || !appState.currentTeamId) {
        showToast('Error: Cannot remove user', 'error');
        return;
    }
    
    try {
        const { doc, updateDoc, deleteField, getDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        // Remove from team members
        const teamRef = doc(db, 'teams', appState.currentTeamId);
        await updateDoc(teamRef, {
            [`members.${userId}`]: deleteField()
        });
        
        // NOTE: User will update their own teams list when they next log in
        // We only update the team document's members map, which we have permission for
        debugLog('âœ… Removed user from team:', userId);
        
        // Add activity
        addActivity({
            type: 'team',
            description: `kicked ${userName} from the team`
        });
        
        showToast(`${userName} has been kicked from the team`, 'success', 3000);
        
        // Reload team members to show user removed
        console.log('ðŸ”„ Reloading team members after kick...');
        await loadTeammatesFromFirestore();
        
        // Refresh the team section display with updated data
        const updatedTeamData = (await getDoc(teamRef)).data();
        console.log('ðŸ“Š Updated team data:', updatedTeamData);
        if (updatedTeamData) {
            displayTeamMembers(updatedTeamData);
            console.log('âœ… Team members display refreshed');
        }
        
    } catch (error) {
        console.error('Error removing user:', error.code || error.message);
        debugError('Full error:', error);
        showToast('Failed to remove user. Please try again.', 'error');
    }
}

// Display join requests
async function displayJoinRequests() {
    if (!db || !currentAuthUser || !appState.currentTeamId) return;
    
    try {
        const { collection, getDocs, query, where } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        // Read from joinRequests subcollection instead of deprecated pendingRequests map
        const joinRequestsRef = collection(db, 'teams', appState.currentTeamId, 'joinRequests');
        const pendingQuery = query(joinRequestsRef, where('status', '==', 'pending'));
        const snapshot = await getDocs(pendingQuery);
        
        const requestsList = [];
        snapshot.forEach(doc => {
            requestsList.push({ id: doc.id, ...doc.data() });
        });
        
        const joinRequestsSection = document.getElementById('joinRequestsSection');
        const joinRequestsList = document.getElementById('joinRequestsList');
        const requestCountBadge = document.getElementById('requestCountBadge');
        
        if (requestsList.length === 0) {
            if (joinRequestsSection) joinRequestsSection.style.display = 'none';
            return;
        }
        
        // Show section
        if (joinRequestsSection) joinRequestsSection.style.display = 'block';
        if (requestCountBadge) requestCountBadge.textContent = requestsList.length;
        
        // Display requests
        if (joinRequestsList) {
            joinRequestsList.innerHTML = '';
            
            requestsList.forEach(request => {
                const userId = request.id;
                const requestItem = createJoinRequestItem(userId, request);
                joinRequestsList.appendChild(requestItem);
            });
        }
        
    } catch (error) {
        console.error('Error loading join requests:', error.code || error.message);
        debugError('Full error:', error);
    }
}

// Create join request item
function createJoinRequestItem(userId, request) {
    const item = document.createElement('div');
    item.className = 'join-request-item';
    item.id = `request-${userId}`;
    
    const avatar = generateAvatar(request.name || request.displayName || request.email);
    
    item.innerHTML = `
        <div class="join-request-info">
            <div class="join-request-avatar">${escapeHtml(avatar)}</div>
            <div class="join-request-details">
                <div class="name">${escapeHtml(request.name || request.displayName || request.email.split('@')[0])}</div>
                <div class="email">${escapeHtml(request.email)}</div>
            </div>
        </div>
        <div class="join-request-actions">
            <button class="btn-accept" onclick="approveJoinRequest('${escapeHtml(userId)}')">
                <i class="fas fa-check"></i> Accept
            </button>
            <button class="btn-reject" onclick="rejectJoinRequest('${escapeHtml(userId)}')">
                <i class="fas fa-times"></i> Reject
            </button>
        </div>
    `;
    
    return item;
}

// Copy team code
window.copyTeamCode = async function() {
    if (!db || !appState.currentTeamId) return;
    
    try {
        const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const teamRef = doc(db, 'teams', appState.currentTeamId);
        const teamDoc = await getDoc(teamRef);
        
        if (teamDoc.exists()) {
            const teamCode = teamDoc.data().teamCode;
            
            navigator.clipboard.writeText(teamCode).then(() => {
                showToast(`Team code copied: ${teamCode}`, 'success');
            }).catch(() => {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = teamCode;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showToast(`Team code copied: ${teamCode}`, 'success');
            });
        }
    } catch (error) {
        console.error('Error copying team code:', error.code || error.message);
        debugError('Full error:', error);
    }
};

// Generate shareable join link
window.generateJoinLink = function() {
    if (!appState.currentTeamData?.teamCode) {
        showToast('No team code available', 'error');
        return;
    }
    const baseUrl = window.location.origin;
    const joinUrl = `${baseUrl}/app?join=${appState.currentTeamData.teamCode}`;
    
    navigator.clipboard.writeText(joinUrl).then(() => {
        showToast('Join link copied to clipboard!', 'success');
    }).catch(() => {
        // Fallback - show the link in a toast with longer duration
        showToast('Copy this join link: ' + joinUrl, 'info', 10000);
    });
};

// Join team with code input (from no-team card)
window.joinTeamWithCodeInput = function() {
    const input = document.getElementById('joinTeamCodeInput');
    if (!input) return;
    
    const code = input.value.trim().toUpperCase();
    if (!code) {
        showToast('Please enter a team code', 'warning');
        return;
    }
    
    joinTeamByCode(code);
};

// Open join team modal (from header button)
window.openJoinTeamModal = function() {
    const modal = document.getElementById('joinTeamModal');
    if (modal) {
        modal.classList.add('active');
        document.getElementById('joinTeamCodeModalInput').focus();
    }
};

// Close join team modal
function closeJoinTeamModal() {
    const modal = document.getElementById('joinTeamModal');
    if (modal) {
        modal.classList.remove('active');
        document.getElementById('joinTeamModalForm').reset();
    }
}

// Initialize join team modal handlers
function initJoinTeamModal() {
    const modal = document.getElementById('joinTeamModal');
    const closeBtn = document.getElementById('closeJoinTeamModal');
    const cancelBtn = document.getElementById('cancelJoinTeamBtn');
    const form = document.getElementById('joinTeamModalForm');
    
    if (closeBtn) {
        closeBtn.addEventListener('click', closeJoinTeamModal);
    }
    
    if (cancelBtn) {
        cancelBtn.addEventListener('click', closeJoinTeamModal);
    }
    
    if (form) {
        form.addEventListener('submit', (e) => {
            e.preventDefault();
            const input = document.getElementById('joinTeamCodeModalInput');
            const code = input.value.trim().toUpperCase();
            
            if (!code) {
                showToast('Please enter a team code', 'warning');
                return;
            }
            
            closeJoinTeamModal();
            joinTeamByCode(code);
        });
    }
    
    // Close modal when clicking outside
    if (modal) {
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                closeJoinTeamModal();
            }
        });
    }
}

// Rate limiting helper for join team attempts
function canAttemptJoinTeam() {
    const now = Date.now();
    const raw = localStorage.getItem('joinTeamAttempts') || '[]';
    let attempts = [];

    try {
        attempts = JSON.parse(raw);
    } catch {
        attempts = [];
    }

    // Remove attempts older than 1 hour
    const oneHourAgo = now - 60 * 60 * 1000;
    attempts = attempts.filter(ts => ts > oneHourAgo);

    if (attempts.length >= 20) {
        return { allowed: false, attempts };
    }

    // Add this attempt and persist
    attempts.push(now);
    localStorage.setItem('joinTeamAttempts', JSON.stringify(attempts));

    return { allowed: true, attempts };
}

// Join team by code - creates a join request
async function joinTeamByCode(teamCode) {
    if (!db || !currentAuthUser) {
        showToast('Please sign in to join a team', 'error');
        return;
    }
    
    // Rate limit check
    const rateResult = canAttemptJoinTeam();
    if (!rateResult.allowed) {
        showToast('You have tried to join too many teams recently. Please wait before trying again.', 'warning', 6000, 'Rate Limit');
        return;
    }
    
    try {
        const { doc, getDoc, updateDoc, serverTimestamp } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        // Normalize the team code - add TEAM- prefix if not present
        let normalizedCode = teamCode.trim().toUpperCase();
        if (!normalizedCode.startsWith('TEAM-')) {
            normalizedCode = 'TEAM-' + normalizedCode;
        }
        
        if (DEBUG) console.log('ðŸ” Searching for team with code');
        
        // Look up team by code via teamJoinInfo (public collection)
        const joinInfoRef = doc(db, 'teamJoinInfo', normalizedCode);
        const joinInfoDoc = await getDoc(joinInfoRef);
        
        if (!joinInfoDoc.exists()) {
            debugLog('âŒ No team found for code');
            showToast('No team found with this code. Please check the code and try again.', 'error', 5000, 'Invalid Code');
            return;
        }
        
        const joinInfo = joinInfoDoc.data();
        const teamId = joinInfo.teamId;
        const teamName = joinInfo.teamName;
        
        debugLog('âœ… Found team:', teamName);
        
        // Use unified identity resolver for consistent name
        const identity = getIdentity(currentAuthUser.uid, currentAuthUser.email?.split('@')[0]);
        
        // Create join request in subcollection (prevents DoS via map growth)
        // Uses /teams/{teamId}/joinRequests/{userId} instead of deprecated pendingRequests map
        const { setDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        const joinRequestRef = doc(db, 'teams', teamId, 'joinRequests', currentAuthUser.uid);
        await setDoc(joinRequestRef, {
            userId: currentAuthUser.uid,
            name: identity.displayName,
            email: currentAuthUser.email,
            requestedAt: serverTimestamp(),
            status: 'pending'
        });
        
        debugLog('âœ… Join request sent successfully');
        
        showToast(`Join request sent to "${teamName}"! Wait for a team member to approve your request.`, 'success', 5000, 'Request Sent');
        closeJoinTeamModal();
        
    } catch (error) {
        console.error('Error joining team:', error.code || error.message);
        if (error.code === 'permission-denied') {
            showToast('Unable to send request. You may already be a member or have a pending request.', 'error', 5000, 'Request Failed');
        } else {
            showToast('Error sending join request. Please try again.', 'error', 5000, 'Request Failed');
        }
    }
}

// Leave team - SECURITY FIX: Use pendingLeaveRequests for non-owners
// Regular members submit a leave request; admins/owners can leave directly or approve requests
window.leaveTeam = async function() {
    if (!db || !currentAuthUser || !appState.currentTeamId) return;
    
    try {
        const { doc, getDoc, updateDoc, setDoc, collection, addDoc, serverTimestamp, deleteField } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const teamRef = doc(db, 'teams', appState.currentTeamId);
        const teamDoc = await getDoc(teamRef);
        
        if (!teamDoc.exists()) {
            showToast('Team not found', 'error');
            return;
        }
        
        const teamData = teamDoc.data();
        const members = teamData.members || {};
        const memberCount = Object.keys(members).length;
        const userRole = members[currentAuthUser.uid]?.role || 'member';
        
        // Case 1: Owner trying to leave
        if (userRole === 'owner') {
            if (memberCount > 1) {
                // Owner cannot leave without transferring ownership
                showToast('You must transfer ownership before leaving the team', 'warning', 5000, 'Cannot Leave');
                return;
            } else {
                // Owner is the last member - confirm and delete team
                const confirmed = await showConfirmModal('You are the only member. Leaving will delete this team permanently. Continue?', {
                    title: 'Delete Team',
                    confirmText: 'Delete Team',
                    type: 'danger'
                });
                if (!confirmed) return;
                // For now, just remove themselves (team will be orphaned but rules prevent access)
                // TODO: Consider full team deletion
            }
        }
        
        // Case 2: Admin can leave directly
        if (userRole === 'admin' || userRole === 'owner') {
            const confirmed = await showConfirmModal('Are you sure you want to leave this team? This action cannot be undone.', {
                title: 'Leave Team',
                confirmText: 'Leave',
                type: 'danger'
            });
            if (!confirmed) return;
            await performLeaveTeam(currentAuthUser.uid, appState.currentTeamId);
            return;
        }
        
        // Case 3: Regular member - submit leave request for admin approval
        const confirmed = await showConfirmModal('Submit a request to leave this team? An admin will need to approve it.', {
            title: 'Leave Team',
            confirmText: 'Submit Request'
        });
        if (!confirmed) return;
        
        // Use unified identity resolver for consistent name
        const identity = getIdentity(currentAuthUser.uid, currentAuthUser.email?.split('@')[0]);
        
        // Create leave request
        const leaveRequestsRef = collection(db, 'teams', appState.currentTeamId, 'pendingLeaveRequests');
        await addDoc(leaveRequestsRef, {
            userId: currentAuthUser.uid,
            userName: identity.displayName,
            userEmail: currentAuthUser.email,
            requestedAt: serverTimestamp(),
            status: 'pending'
        });
        
        showToast('Leave request submitted. An admin will review it.', 'success', 5000, 'Request Sent');
        
    } catch (error) {
        console.error('Error leaving team:', error.code || error.message);
        debugError('Full error:', error);
        
        // If permission denied, it might be a rules issue - guide the user
        if (error.code === 'permission-denied') {
            showToast('You do not have permission to leave directly. Contact an admin.', 'error', 5000, 'Permission Denied');
        } else {
            showToast('Error leaving team. Please try again.', 'error', 5000, 'Error');
        }
    }
};

// Actually perform the leave team operation (used by admins and for approved requests)
async function performLeaveTeam(userId, teamId) {
    if (!db) return;
    
    try {
        const { doc, getDoc, updateDoc, setDoc, deleteField } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const teamRef = doc(db, 'teams', teamId);
        const teamDoc = await getDoc(teamRef);
        
        if (!teamDoc.exists()) return;
        
        const members = teamDoc.data().members || {};
        
        // Use deleteField to remove the user from members map
        const updates = {};
        updates[`members.${userId}`] = deleteField();
        await updateDoc(teamRef, updates);
        
        // Update user's teams list
        const userRef = doc(db, 'users', userId);
        const userDoc = await getDoc(userRef);
        if (userDoc.exists()) {
            const userData = userDoc.data();
            const userTeams = (userData.teams || []).filter(t => t !== teamId);
            await setDoc(userRef, { teams: userTeams }, { merge: true });
        }
        
        // If this is the current user, clear local state
        if (userId === currentAuthUser?.uid) {
            appState.currentTeamId = null;
            appState.userTeams = [];
            appState.teammates = [];
            
            showToast('You have left the team successfully.', 'success');
            await initTeamSection();
        }
        
    } catch (error) {
        console.error('Error performing leave team:', error);
        throw error;
    }
}

// Approve a leave request (admin/owner only)
window.approveLeaveRequest = async function(requestId, userId, userName) {
    if (!db || !currentAuthUser || !appState.currentTeamId) return;
    
    const confirmed = await showConfirmModal(`Approve ${userName}'s request to leave the team?`, {
        title: 'Approve Leave Request',
        confirmText: 'Approve'
    });
    if (!confirmed) return;
    
    try {
        const { doc, deleteDoc } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        // Perform the leave operation
        await performLeaveTeam(userId, appState.currentTeamId);
        
        // Delete the request
        const requestRef = doc(db, 'teams', appState.currentTeamId, 'pendingLeaveRequests', requestId);
        await deleteDoc(requestRef);
        
        showToast(`${userName} has been removed from the team.`, 'success');
        
        // Refresh the members list
        if (window.loadPendingLeaveRequests) {
            await loadPendingLeaveRequests();
        }
        
    } catch (error) {
        console.error('Error approving leave request:', error);
        showToast('Error approving request. Please try again.', 'error');
    }
};

// Deny a leave request (admin/owner only)
window.denyLeaveRequest = async function(requestId, userName) {
    if (!db || !currentAuthUser || !appState.currentTeamId) return;
    
    const confirmed = await showConfirmModal(`Deny ${userName}'s request to leave?`, {
        title: 'Deny Leave Request',
        confirmText: 'Deny',
        type: 'danger'
    });
    if (!confirmed) return;
    
    try {
        const { doc, deleteDoc } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const requestRef = doc(db, 'teams', appState.currentTeamId, 'pendingLeaveRequests', requestId);
        await deleteDoc(requestRef);
        
        showToast(`Leave request denied.`, 'info');
        
        if (window.loadPendingLeaveRequests) {
            await loadPendingLeaveRequests();
        }
        
    } catch (error) {
        console.error('Error denying leave request:', error);
        showToast('Error denying request. Please try again.', 'error');
    }
};

// Load pending leave requests (admin/owner only)
window.loadPendingLeaveRequests = async function() {
    if (!db || !appState.currentTeamId) return [];
    
    try {
        const { collection, query, orderBy, getDocs } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const requestsRef = collection(db, 'teams', appState.currentTeamId, 'pendingLeaveRequests');
        const q = query(requestsRef, orderBy('requestedAt', 'desc'));
        const snapshot = await getDocs(q);
        
        const requests = [];
        snapshot.forEach(doc => {
            requests.push({ id: doc.id, ...doc.data() });
        });
        
        return requests;
        
    } catch (error) {
        console.error('Error loading leave requests:', error);
        return [];
    }
};

// ===================================
// FIREBASE FUNCTIONS (PLACEHOLDER)
// ===================================
// These functions will be used when Firebase is properly configured

// Team-scoped Firestore functions - with real-time listener
async function loadTasksFromFirestore() {
    if (!db || !currentAuthUser || !appState.currentTeamId) {
        console.log('Cannot load tasks: missing requirements');
        return;
    }
    
    try {
        const { collection, query, onSnapshot, orderBy } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const tasksRef = collection(db, 'teams', appState.currentTeamId, 'tasks');
        const q = query(tasksRef, orderBy('createdAt', 'desc'));
        
        // Real-time listener for tasks
        onSnapshot(q, (querySnapshot) => {
            const tasks = [];
            querySnapshot.forEach((doc) => {
                const taskData = { id: doc.id, ...doc.data() };
                
                // Normalize legacy status values to valid enums (todo, inprogress, done)
                if (taskData.status === 'complete') {
                    taskData.status = 'done';
                } else if (taskData.status === 'in-progress' || taskData.status === 'in progress') {
                    taskData.status = 'inprogress';
                }
                
                tasks.push(taskData);
            });
            
            appState.tasks = tasks;
            saveToLocalStorage('tasks', appState.tasks);
            
            if (window.displayTasks) {
                window.displayTasks();
            }
            
            // Update overview when tasks change
            updateOverview();
            
            // Update metrics if active
            updateMetricsIfActive();
            
            debugLog(`âœ… Loaded ${tasks.length} tasks`);
        }, (error) => {
            // Handle Firestore listener errors (network issues, timeouts, etc.)
            if (error.code === 'unavailable' || error.code === 'deadline-exceeded') {
                debugLog('âš ï¸ Tasks listener temporarily unavailable, will auto-retry');
            } else {
                console.error('âŒ Error in tasks snapshot listener:', error.code || error.message);
                debugError('Full error:', error);
            }
        });
        
    } catch (error) {
        console.error('Error setting up tasks listener:', error.code || error.message);
        debugError('Full error:', error);
    }
}

async function saveTaskToFirestore(task) {
    if (!db || !currentAuthUser || !appState.currentTeamId) return null;
    
    const path = `teams/${appState.currentTeamId}/tasks/<new>`;
    
    try {
        const { collection, addDoc, doc, getDoc, serverTimestamp, Timestamp } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        // DEBUG: Verify team membership before attempting write
        const teamRef = doc(db, 'teams', appState.currentTeamId);
        const teamSnap = await getDoc(teamRef);
        const memberData = teamSnap.data()?.members?.[currentAuthUser.uid];
        console.log('ðŸ“‹ Team membership check:', {
            teamExists: teamSnap.exists(),
            memberData: memberData,
            hasRole: !!memberData?.role
        });
        
        const tasksRef = collection(db, 'teams', appState.currentTeamId, 'tasks');
        
        // SECURITY: Only include fields allowed by rules whitelist
        // Allowed: createdBy, teamId, title, description, status, assignee, assigneeId, priority, dueAt, dueDate,
        //          createdAt, updatedAt, tags, completed, completedAt, completedBy, progress, estimatedTime,
        //          budget, spreadsheetId, showOnCalendar, isRecurring, recurrence
        // LEADS: leadName, source, value, contact, notes
        // CUSTOM FIELDS: customFields
        const allowedFields = ['title', 'description', 'status', 'assignee', 'assigneeId', 'priority', 
                               'dueAt', 'dueDate', 'tags', 'completed', 'completedAt', 'completedBy', 
                               'progress', 'estimatedTime', 'budget', 'spreadsheetId', 'showOnCalendar',
                               'isRecurring', 'recurrence',
                               // Lead-specific fields
                               'leadName', 'source', 'value', 'contact', 'notes',
                               // Custom fields
                               'customFields'];
        const taskData = {
            teamId: appState.currentTeamId,  // Required by rules
            createdBy: currentAuthUser.uid,
            createdAt: serverTimestamp(),
            updatedAt: serverTimestamp()  // Add updatedAt for CREATE too
        };
        
        // Copy allowed fields, converting dates and stripping nulls
        for (const key of allowedFields) {
            if (key in task && task[key] !== undefined && task[key] !== null) {
                // Convert dueDate from milliseconds to Firestore Timestamp
                if (key === 'dueDate' && typeof task[key] === 'number') {
                    taskData[key] = Timestamp.fromMillis(task[key]);
                } 
                // Convert dueAt from milliseconds to Firestore Timestamp
                else if (key === 'dueAt' && typeof task[key] === 'number') {
                    taskData[key] = Timestamp.fromMillis(task[key]);
                }
                // completedAt might also be a timestamp
                else if (key === 'completedAt' && typeof task[key] === 'number') {
                    taskData[key] = Timestamp.fromMillis(task[key]);
                }
                // RECURRING TASKS: Handle recurrence object with nested nextDueAt timestamp
                else if (key === 'recurrence' && task[key]) {
                    taskData[key] = {
                        ...task[key],
                        nextDueAt: task[key].nextDueAt ? Timestamp.fromMillis(task[key].nextDueAt) : null
                    };
                }
                else {
                    taskData[key] = task[key];
                }
            }
        }
        // Ensure title is set (required by rules)
        // For leads, use leadName as title if title not provided
        if (!taskData.title) {
            taskData.title = task.leadName || task.name || 'Untitled Task';
        }
        
        console.log('ðŸ“ CREATE task with data:', {
            keys: Object.keys(taskData),
            hasTeamId: 'teamId' in taskData,
            hasCreatedAt: 'createdAt' in taskData,
            hasUpdatedAt: 'updatedAt' in taskData,
            teamIdValue: taskData.teamId,
            fieldTypes: Object.fromEntries(
                Object.entries(taskData).map(([k, v]) => [
                    k, 
                    v?.constructor?.name || typeof v
                ])
            )
        });
        
        const docRef = await addDoc(tasksRef, taskData);
        
        debugLog('Task saved to team collection with ID:', docRef.id);
        return docRef.id; // Return the Firestore document ID
    } catch (error) {
        // Log the actual taskData we tried to send, not the input task object
        logFirestoreError('saveTaskToFirestore', path, taskData || task, {
            uid: currentAuthUser?.uid,
            teamId: appState.currentTeamId,
            userRole: appState.currentTeamData?.members?.[currentAuthUser?.uid]?.role,
            inputTask: task,
            attemptedTaskData: taskData
        }, error);
        return null;
    }
}

async function updateTaskInFirestore(task) {
    if (!db || !currentAuthUser || !appState.currentTeamId || !task.id) return false;
    
    const path = `teams/${appState.currentTeamId}/tasks/${task.id}`;
    
    try {
        const { doc, updateDoc, serverTimestamp } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const taskRef = doc(db, 'teams', appState.currentTeamId, 'tasks', task.id);
        
        // Remove id from the update data (Firestore doc ID shouldn't be a field)
        const { id, ...taskData } = task;
        
        // SECURITY: Only include fields allowed by rules whitelist (UPDATE - mutable fields only)
        // Allowed on UPDATE: title, description, status, assignee, assigneeId, priority, dueAt, dueDate,
        //          updatedAt, tags, completed, completedAt, completedBy, progress, estimatedTime
        // LEADS: leadName, source, value, contact, notes
        // CUSTOM FIELDS: customFields
        // NOTE: updatedBy is NOT allowed - removed to fix permission-denied
        // NOTE: createdBy, teamId, createdAt are immutable - don't send on UPDATE
        const allowedFields = ['title', 'description', 'status', 'assignee', 'assigneeId', 'priority', 
                               'dueAt', 'dueDate', 'tags', 'completed', 'completedAt', 'completedBy', 
                               'progress', 'estimatedTime',
                               // Lead-specific fields
                               'leadName', 'source', 'value', 'contact', 'notes',
                               // Custom fields
                               'customFields'];
        const filteredData = {};
        for (const key of allowedFields) {
            if (key in taskData) {
                filteredData[key] = taskData[key];
            }
        }
        
        await updateDoc(taskRef, {
            ...filteredData,
            updatedAt: serverTimestamp()
        });
        
        debugLog('Task updated in Firestore:', task.id);
        return true;
    } catch (error) {
        logFirestoreError('updateTaskInFirestore', path, filteredData, {
            uid: currentAuthUser?.uid,
            teamId: appState.currentTeamId,
            taskId: task.id,
            taskCreatedBy: task.createdBy,
            userRole: appState.currentTeamData?.members?.[currentAuthUser?.uid]?.role
        }, error);
        return false;
    }
}

async function loadMessagesFromFirestore() {
    if (!db || !currentAuthUser || !appState.currentTeamId) {
        // Clear messages if no team
        appState.messages = [];
        const chatMessages = document.getElementById('chatMessages');
        if (chatMessages) chatMessages.innerHTML = '';
        return;
    }
    
    try {
        const { collection, query, onSnapshot, orderBy } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const messagesRef = collection(db, 'teams', appState.currentTeamId, 'messages');
        const q = query(messagesRef, orderBy('timestamp', 'asc'));
        
        // Track if this is the initial load
        let isInitialLoad = true;
        
        // Real-time listener for messages
        onSnapshot(q, async (querySnapshot) => {
            const encryptedMessages = [];
            querySnapshot.forEach((doc) => {
                // Spread doc.data() first, then override with doc.id to ensure Firestore doc ID wins
                encryptedMessages.push({ ...doc.data(), id: doc.id });
            });
            
            // Decrypt all messages and format time
            const messages = await Promise.all(
                encryptedMessages.map(async (msg) => {
                    let decryptedMsg = msg;
                    
                    // CRITICAL: Map Firestore 'message' field to UI 'text' field
                    // Firestore rules require 'message', but UI expects 'text'
                    if (msg.message && !msg.text) {
                        decryptedMsg = { ...msg, text: msg.message };
                    }
                    
                    // CRITICAL: All messages are ALWAYS encrypted (no 'encrypted' flag stored in Firestore)
                    // The encryption happens in sendMessage() before saving
                    // So we ALWAYS attempt to decrypt (with error handling)
                    if (decryptedMsg.text) {
                        try {
                            const decryptedText = await decryptMessage(decryptedMsg.text, appState.currentTeamId);
                            decryptedMsg = { ...decryptedMsg, text: decryptedText };
                        } catch (error) {
                            // If decryption fails, message might be plaintext (legacy) or corrupted
                            console.warn('Failed to decrypt message, showing as-is:', error.message);
                            // Keep original text
                        }
                    }
                    
                    // Add formatted time field if timestamp exists
                    if (decryptedMsg.timestamp) {
                        const date = decryptedMsg.timestamp.seconds 
                            ? new Date(decryptedMsg.timestamp.seconds * 1000) 
                            : new Date(decryptedMsg.timestamp);
                        decryptedMsg.time = formatTime(date);
                    }
                    
                    return decryptedMsg;
                })
            );
            
            // Check for new messages from other users (skip on initial load)
            const previousMessageCount = appState.messages.length;
            const hasNewMessages = messages.length > previousMessageCount;
            
            // Get last seen timestamp from localStorage
            const lastSeenKey = `chatLastSeen_${appState.currentTeamId}`;
            const lastSeenTimestamp = parseInt(localStorage.getItem(lastSeenKey) || '0');
            
            // Only show badge if NOT initial load and there are new messages
            if (!isInitialLoad && hasNewMessages && messages.length > 0) {
                const latestMessage = messages[messages.length - 1];
                const isFromOtherUser = latestMessage.userId && latestMessage.userId !== currentAuthUser?.uid;
                const isNotOnChatSection = appState.currentSection !== 'chat';
                
                // Check if message timestamp is after last seen
                const messageTimestamp = latestMessage.timestamp?.toMillis?.() || Date.now();
                const isNewSinceLastSeen = messageTimestamp > lastSeenTimestamp;
                
                // Show badge if new message from other user, not viewing chat, and after last seen
                if (isFromOtherUser && isNotOnChatSection && isNewSinceLastSeen) {
                    const chatBadge = document.getElementById('chatNotificationBadge');
                    if (chatBadge) {
                        chatBadge.style.display = 'flex';
                        const unreadCount = parseInt(chatBadge.textContent || '0') + 1;
                        chatBadge.textContent = unreadCount.toString();
                    }
                }
            }
            
            // Mark initial load as complete
            if (isInitialLoad) {
                isInitialLoad = false;
            }
            
            // Always update state, even if empty (clears old team's messages)
            appState.messages = messages;
            displayMessages();
            
            // Update metrics if active
            updateMetricsIfActive();
            
            if (hasNewMessages && messages.length > 0) {
                debugLog(`âœ… Messages updated: ${messages.length} total`);
            }
        }, (error) => {
            // Handle Firestore listener errors (network issues, timeouts, etc.)
            if (error.code === 'unavailable' || error.code === 'deadline-exceeded') {
                debugLog('âš ï¸ Messages listener temporarily unavailable, will auto-retry');
            } else {
                console.error('Error in messages snapshot listener:', error.code || error.message);
                debugError('Full error:', error);
            }
        });
        
    } catch (error) {
        console.error('Error loading messages from Firestore:', error.code || error.message);
        debugError('Full error:', error);
    }
}

// ===================================
// ENCRYPTION UTILITIES
// ===================================
/**
 * âš ï¸ SECURITY WARNING: ENCRYPTION THEATER - NOT TRUE E2EE âš ï¸
 * 
 * The encryption implemented here provides OBFUSCATION ONLY, not true security.
 * 
 * WHY THIS IS NOT SECURE:
 * - The encryption key is derived from: teamId + hardcoded salt
 * - Both values are known/accessible to anyone with Firestore access
 * - If Firestore is compromised, messages can be trivially decrypted
 * - Server-side (Firebase) can always decrypt messages
 * 
 * WHAT THIS PROTECTS AGAINST:
 * - Casual viewing of raw database exports
 * - Accidental data exposure in logs
 * 
 * WHAT THIS DOES NOT PROTECT AGAINST:
 * - Determined attackers with database access
 * - Firebase/Google employees
 * - Legal/government data requests
 * - Any breach of Firestore security rules
 * 
 * FOR TRUE END-TO-END ENCRYPTION (E2EE), YOU NEED:
 * - User-generated secrets (passwords or passphrase)
 * - Client-side key derivation that never touches the server
 * - Key exchange protocols (e.g., Signal Protocol, ECDH)
 * - Per-user or per-conversation keys
 * 
 * DO NOT claim "end-to-end encryption" or "E2EE" in any UI or documentation.
 * This is transport-layer obfuscation, not cryptographic security.
 */
async function getTeamEncryptionKey(teamId) {
    // WARNING: This key is derived from publicly-accessible teamId + hardcoded salt
    // This provides obfuscation, NOT cryptographic security
    const encoder = new TextEncoder();
    const keyMaterial = encoder.encode(teamId + '_encryption_key_v1');
    
    // Import the key material
    const key = await crypto.subtle.importKey(
        'raw',
        keyMaterial,
        { name: 'PBKDF2' },
        false,
        ['deriveBits', 'deriveKey']
    );
    
    // Derive an AES-GCM key from the key material
    // WARNING: The salt is hardcoded, reducing security further
    const salt = encoder.encode('teamhub_salt_v1');
    return await crypto.subtle.deriveKey(
        {
            name: 'PBKDF2',
            salt: salt,
            iterations: 100000,
            hash: 'SHA-256'
        },
        key,
        { name: 'AES-GCM', length: 256 },
        false,
        ['encrypt', 'decrypt']
    );
}

async function encryptMessage(text, teamId) {
    try {
        const encoder = new TextEncoder();
        const data = encoder.encode(text);
        const key = await getTeamEncryptionKey(teamId);
        
        // Generate a random initialization vector
        const iv = crypto.getRandomValues(new Uint8Array(12));
        
        // Encrypt the data
        const encryptedData = await crypto.subtle.encrypt(
            { name: 'AES-GCM', iv: iv },
            key,
            data
        );
        
        // Combine IV and encrypted data, then convert to base64
        const combined = new Uint8Array(iv.length + encryptedData.byteLength);
        combined.set(iv, 0);
        combined.set(new Uint8Array(encryptedData), iv.length);
        
        return btoa(String.fromCharCode(...combined));
    } catch (error) {
        console.error('Encryption error:', error.code || error.message);
        debugError('Full error:', error);
        throw new Error('ENCRYPTION_FAILED');
    }
}

async function decryptMessage(encryptedText, teamId) {
    try {
        // Convert from base64
        const combined = Uint8Array.from(atob(encryptedText), c => c.charCodeAt(0));
        
        // Extract IV and encrypted data
        const iv = combined.slice(0, 12);
        const encryptedData = combined.slice(12);
        
        const key = await getTeamEncryptionKey(teamId);
        
        // Decrypt the data
        const decryptedData = await crypto.subtle.decrypt(
            { name: 'AES-GCM', iv: iv },
            key,
            encryptedData
        );
        
        // Convert back to text
        const decoder = new TextDecoder();
        return decoder.decode(decryptedData);
    } catch (error) {
        console.error('Decryption error:', error.code || error.message);
        debugError('Full error:', error);
        return '[Encrypted message - unable to decrypt]';
    }
}

async function saveMessageToFirestore(message) {
    if (!db || !currentAuthUser || !appState.currentTeamId) return;
    
    try {
        const { collection, addDoc, serverTimestamp } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const messagesRef = collection(db, 'teams', appState.currentTeamId, 'messages');
        
        // Use unified identity resolver for consistent username
        // Priority: publicProfilesById cache > teammates > team members snapshot > auth
        const identity = getIdentity(currentAuthUser.uid, currentAuthUser.email?.split('@')[0]);
        const resolvedUsername = identity.displayName;
        
        // SECURITY: Schema must match rules exactly
        // Allowed fields: userId, userName, message, timestamp, createdAt, edited, editedAt, teamId, userEmail, photoURL, mentions, repliedTo
        // SECURITY: userEmail must match request.auth.token.email if provided
        const messageDoc = {
            userId: currentAuthUser.uid,
            userName: resolvedUsername, // Use SSOT-resolved username
            message: message.text, // Already encrypted text from sendMessage
            userEmail: currentAuthUser.email, // Must match auth token
            photoURL: currentAuthUser.photoURL || null,
            teamId: appState.currentTeamId,
            timestamp: serverTimestamp(),
            createdAt: serverTimestamp()
        };
        
        // Add mentions array if present
        if (message.mentions && message.mentions.length > 0) {
            messageDoc.mentions = message.mentions;
        }
        
        // Add repliedTo data if present
        if (message.repliedTo) {
            messageDoc.repliedTo = message.repliedTo;
        }
        
        // Use addDoc to let Firestore generate the document ID
        const docRef = await addDoc(messagesRef, messageDoc);
        
        debugLog('âœ… Message saved to Firestore:', { 
            messageId: docRef.id, 
            docPath: `teams/${appState.currentTeamId}/messages/${docRef.id}`
        });
    } catch (error) {
        console.error('Error saving message to Firestore:', error);
        throw error; // Re-throw so sendMessage can handle it
    }
}

async function loadEventsFromFirestore() {
    if (!db || !currentAuthUser || !appState.currentTeamId) {
        console.log('Cannot load events: missing db, auth, or teamId');
        return;
    }
    
    try {
        const { collection, query, onSnapshot, orderBy, doc, getDoc, Timestamp } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const eventsRef = collection(db, 'teams', appState.currentTeamId, 'events');
        const q = query(eventsRef, orderBy('startTime', 'asc'));
        
        // Get user role for visibility filtering
        const teamRef = doc(db, 'teams', appState.currentTeamId);
        const teamSnap = await getDoc(teamRef);
        const teamData = teamSnap.exists() ? teamSnap.data() : null;
        const userRole = getCurrentUserRole(teamData);
        const isAdmin = userRole === 'admin' || userRole === 'owner';
        
        // Real-time listener
        onSnapshot(q, (querySnapshot) => {
            const events = [];
            querySnapshot.forEach((docSnapshot) => {
                const data = docSnapshot.data();
                
                // Check visibility permissions
                const visibility = data.visibility || 'team';
                const isCreator = data.createdBy === currentAuthUser.uid;
                
                // Filter based on visibility
                let canSee = false;
                if (visibility === 'team') {
                    canSee = true; // Everyone can see team events
                } else if (visibility === 'admins') {
                    canSee = isAdmin || isCreator; // Only admins or creator can see
                } else if (visibility === 'private') {
                    canSee = isCreator; // Only creator can see
                }
                
                if (canSee) {
                    events.push({
                        id: docSnapshot.id,
                        title: data.title,
                        description: data.description,
                        date: data.startTime?.toDate ? data.startTime.toDate() : new Date(data.startTime),
                        endDate: data.endTimeStamp?.toDate ? data.endTimeStamp.toDate() : new Date(data.endTimeStamp),
                        time: data.startTimeStr || '',
                        endTime: data.endTimeStr || '',
                        color: data.color || '#0078d4',
                        visibility: visibility,
                        // RECURRING EVENTS: Load repeat frequency and start date
                        repeat: data.repeat || 'none',
                        repeatStart: data.repeatStart?.toDate ? data.repeatStart.toDate() : (data.repeatStart ? new Date(data.repeatStart) : null),
                        teamId: data.teamId,
                        createdBy: data.createdBy,
                        createdByName: data.createdByName
                    });
                }
            });
            
            appState.events = events;
            debugLog(`âœ… Loaded ${events.length} events (filtered by visibility)`);
            debugLog('Events:', events);
            
            // Update calendar display if on calendar section
            if (typeof renderCalendar === 'function') {
                debugLog('Calling renderCalendar to update display...');
                renderCalendar();
            } else {
                debugLog('renderCalendar function not yet defined');
            }
            
            // Update overview when events change
            updateOverview();
            
            // Update metrics if active
            updateMetricsIfActive();
        }, (error) => {
            // Handle Firestore listener errors (network issues, timeouts, etc.)
            if (error.code === 'unavailable' || error.code === 'deadline-exceeded') {
                debugLog('âš ï¸ Events listener temporarily unavailable, will auto-retry');
            } else {
                console.error('Error in events snapshot listener:', error.code || error.message);
                debugError('Full error:', error);
            }
        });
        
    } catch (error) {
        console.error('Error loading events from Firestore:', error.code || error.message);
        debugError('Full error:', error);
    }
}

async function saveEventToFirestore(event) {
    debugLog('saveEventToFirestore called with:', event);
    debugLog('db:', !!db, 'auth:', !!currentAuthUser, 'teamId:', appState.currentTeamId);
    
    if (!db || !currentAuthUser || !appState.currentTeamId) {
        console.error('âŒ Cannot save event: missing db, auth, or teamId');
        showToast('Please make sure you are logged in and part of a team', 'error');
        return;
    }
    
    // RATE LIMITING: Check if user can create event
    const rateCheck = canCreateEvent();
    if (!rateCheck.allowed) {
        showToast(rateCheck.reason, 'warning', 3000);
        return;
    }
    
    try {
        const { collection, addDoc, serverTimestamp, Timestamp } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const eventsRef = collection(db, 'teams', appState.currentTeamId, 'events');
        debugLog('Events collection path:', `teams/${appState.currentTeamId}/events`);
        
        // Use unified identity resolver for consistent display name
        const identity = getIdentity(currentAuthUser.uid, currentAuthUser.email?.split('@')[0]);
        
        // Convert Date objects to Firestore Timestamps
        const eventData = {
            title: event.title,
            description: event.description || '',
            startTime: Timestamp.fromDate(event.date),
            endTimeStamp: event.endDate ? Timestamp.fromDate(event.endDate) : Timestamp.fromDate(new Date(event.date.getTime() + 60*60*1000)),
            startTimeStr: event.time,
            endTimeStr: event.endTime || '',
            color: event.color || '#0078d4',
            visibility: event.visibility || 'team',
            // RECURRING EVENTS: Store repeat frequency and start date
            repeat: event.repeat || 'none',
            repeatStart: event.repeatStart ? Timestamp.fromDate(event.repeatStart) : null,
            teamId: appState.currentTeamId,
            createdBy: currentAuthUser.uid,
            createdByName: identity.displayName,
            createdAt: serverTimestamp()
        };
        
        console.log('Saving event to Firestore for team:', event.teamId);
        const docRef = await addDoc(eventsRef, eventData);
        console.log('âœ… Event saved to Firestore with ID:', docRef.id);
        
        // RATE LIMITING: Update rate limit state after successful save
        rateLimitState.lastEventCreation = Date.now();
        rateLimitState.eventCount++;
        
    } catch (error) {
        console.error('âŒ Error saving event to Firestore:', error.code || error.message);
        showToast('Error saving event: ' + error.message, 'error', 5000, 'Save Failed');
    }
}

async function updateEventInFirestore(event) {
    debugLog('updateEventInFirestore called with:', event);
    debugLog('db:', !!db, 'auth:', !!currentAuthUser, 'teamId:', appState.currentTeamId);
    
    if (!db || !currentAuthUser || !appState.currentTeamId) {
        console.error('âŒ Cannot update event: missing db, auth, or teamId');
        showToast('Please make sure you are logged in and part of a team', 'error');
        return;
    }
    
    try {
        const { doc, updateDoc, Timestamp } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const eventRef = doc(db, 'teams', appState.currentTeamId, 'events', event.id);
        debugLog('Event document path:', `teams/${appState.currentTeamId}/events/${event.id}`);
        
        // Convert Date objects to Firestore Timestamps
        const eventData = {
            title: event.title,
            description: event.description || '',
            startTime: Timestamp.fromDate(event.date),
            endTimeStamp: event.endDate ? Timestamp.fromDate(event.endDate) : Timestamp.fromDate(new Date(event.date.getTime() + 60*60*1000)),
            startTimeStr: event.time,
            endTimeStr: event.endTime || '',
            color: event.color || '#007AFF',
            visibility: event.visibility || 'team',
            // RECURRING EVENTS: Store repeat frequency and start date
            repeat: event.repeat || 'none',
            repeatStart: event.repeatStart ? Timestamp.fromDate(event.repeatStart) : null,
            updatedAt: new Date()  // Required by rules - helps with tracking changes
        };
        
        console.log('Updating event in Firestore:', event.id);
        await updateDoc(eventRef, eventData);
        console.log('âœ… Event updated in Firestore');
        
    } catch (error) {
        console.error('âŒ Error updating event in Firestore:', error.code || error.message);
        showToast('Error updating event: ' + error.message, 'error', 5000, 'Update Failed');
    }
}

// ===================================
// LINK LOBBY SYSTEM
// ===================================
let linkLobbyGroups = [];
let linkLobbyUnsubscribe = null;
let linkGroupMenuOpen = null;

// Initialize Link Lobby
function initLinkLobby() {
    // Add button event listener
    const addGroupBtn = document.getElementById('addLinkGroupBtn');
    if (addGroupBtn) {
        addGroupBtn.addEventListener('click', openAddGroupModal);
    }
    
    // Close menus when clicking outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.link-group-menu')) {
            closeAllGroupMenus();
        }
    });
    
    // URL input preview listener
    const linkUrlInput = document.getElementById('linkUrl');
    if (linkUrlInput) {
        linkUrlInput.addEventListener('input', debounce(updateLinkPreview, 300));
    }
}

// Subscribe to Link Lobby groups
// Security: Uses split queries to avoid permission errors on private groups
async function subscribeLinkLobbyGroups() {
    if (!db || !appState.currentTeamId || !currentAuthUser) return;
    
    // Unsubscribe from previous listeners
    if (linkLobbyUnsubscribe) {
        if (typeof linkLobbyUnsubscribe === 'function') {
            linkLobbyUnsubscribe();
        } else if (Array.isArray(linkLobbyUnsubscribe)) {
            linkLobbyUnsubscribe.forEach(unsub => unsub && unsub());
        }
    }
    
    try {
        const { collection, query, where, orderBy, onSnapshot, getDocs } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const groupsRef = collection(db, 'teams', appState.currentTeamId, 'linkLobbyGroups');
        const currentUserId = currentAuthUser.uid;
        
        // SECURITY FIX: Split into two queries to avoid permission errors
        // Query 1: Public/team groups (visibility == 'team')
        // Try with orderBy first, fall back to client-side sort if indexes not ready
        let teamGroupsQuery = query(groupsRef, where('visibility', '==', 'team'), orderBy('sortOrder', 'asc'));
        let teamGroupsQueryFallback = query(groupsRef, where('visibility', '==', 'team'));
        
        // Query 2: Private groups created by current user
        let privateGroupsQuery = query(groupsRef, where('visibility', '==', 'private'), where('createdBy', '==', currentUserId), orderBy('sortOrder', 'asc'));
        let privateGroupsQueryFallback = query(groupsRef, where('visibility', '==', 'private'), where('createdBy', '==', currentUserId));
        
        // Query 3: Legacy groups without visibility field (treated as team-visible)
        const legacyGroupsQuery = query(groupsRef);
        
        // Track results from both queries
        let teamGroups = [];
        let privateGroups = [];
        let legacyGroups = [];
        let unsubscribers = [];
        
        // Helper to process group documents
        const processGroupDocs = async (snapshot) => {
            const groups = [];
            for (const docSnapshot of snapshot.docs) {
                const groupData = { id: docSnapshot.id, ...docSnapshot.data(), links: [], domainGroups: {} };
                
                // Fetch links for this group
                try {
                    const linksRef = collection(db, 'teams', appState.currentTeamId, 'linkLobbyGroups', docSnapshot.id, 'links');
                    const linksQuery = query(linksRef, orderBy('createdAt', 'desc'));
                    const linksSnapshot = await getDocs(linksQuery);
                    
                    linksSnapshot.forEach(linkDoc => {
                        const linkData = { id: linkDoc.id, ...linkDoc.data() };
                        
                        // CRITICAL: Map Firestore field names to UI field names for backward compat
                        // Firestore rules require 'title' and 'favicon', but UI expects 'label' and 'iconUrl'
                        if (linkData.title && !linkData.label) {
                            linkData.label = linkData.title;
                        }
                        if (linkData.favicon && !linkData.iconUrl) {
                            linkData.iconUrl = linkData.favicon;
                        }
                        
                        if (groupData.autoGroupDomain && linkData.domain) {
                            if (!groupData.domainGroups[linkData.domain]) {
                                groupData.domainGroups[linkData.domain] = [];
                            }
                            groupData.domainGroups[linkData.domain].push(linkData);
                        } else {
                            groupData.links.push(linkData);
                        }
                    });
                } catch (linkError) {
                    debugLog('Could not fetch links for group:', docSnapshot.id, linkError.message);
                }
                
                // Sort links: by sortOrder (if set), then favorites first, then by createdAt
                groupData.links.sort((a, b) => {
                    // First sort by sortOrder if both have it
                    const aOrder = typeof a.sortOrder === 'number' ? a.sortOrder : Infinity;
                    const bOrder = typeof b.sortOrder === 'number' ? b.sortOrder : Infinity;
                    if (aOrder !== bOrder) return aOrder - bOrder;
                    
                    // Then favorites first
                    if (a.favorite && !b.favorite) return -1;
                    if (!a.favorite && b.favorite) return 1;
                    return (b.createdAt?.toMillis?.() || 0) - (a.createdAt?.toMillis?.() || 0);
                });
                
                Object.keys(groupData.domainGroups).forEach(domain => {
                    groupData.domainGroups[domain].sort((a, b) => {
                        // First sort by sortOrder if both have it
                        const aOrder = typeof a.sortOrder === 'number' ? a.sortOrder : Infinity;
                        const bOrder = typeof b.sortOrder === 'number' ? b.sortOrder : Infinity;
                        if (aOrder !== bOrder) return aOrder - bOrder;
                        
                        if (a.favorite && !b.favorite) return -1;
                        if (!a.favorite && b.favorite) return 1;
                        return (b.createdAt?.toMillis?.() || 0) - (a.createdAt?.toMillis?.() || 0);
                    });
                });
                
                groups.push(groupData);
            }
            return groups;
        };
        
        // Merge and deduplicate groups from all queries
        const mergeAndRender = () => {
            // Combine all groups, filtering legacy groups to exclude those with explicit visibility
            const filteredLegacy = legacyGroups.filter(g => !('visibility' in g) || g.visibility === undefined);
            const allGroups = [...teamGroups, ...privateGroups, ...filteredLegacy];
            
            // Deduplicate by ID first, then by normalized title
            const seenIds = new Set();
            const seenTitles = new Map();
            const duplicatesByTitle = {};
            linkLobbyGroups = [];
            
            // Sort by sortOrder before deduplication
            allGroups.sort((a, b) => (a.sortOrder ?? Infinity) - (b.sortOrder ?? Infinity));
            
            for (const group of allGroups) {
                // Skip if already seen this exact document
                if (seenIds.has(group.id)) continue;
                seenIds.add(group.id);
                
                const normalizedTitle = normalizeGroupTitle(group.title);
                
                if (!seenTitles.has(normalizedTitle)) {
                    seenTitles.set(normalizedTitle, group);
                    linkLobbyGroups.push(group);
                } else {
                    // Track duplicates for summary
                    if (!duplicatesByTitle[normalizedTitle]) {
                        duplicatesByTitle[normalizedTitle] = [];
                    }
                    duplicatesByTitle[normalizedTitle].push(group.id);
                    
                    const existing = seenTitles.get(normalizedTitle);
                    if ((group.sortOrder ?? Infinity) < (existing.sortOrder ?? Infinity)) {
                        const idx = linkLobbyGroups.indexOf(existing);
                        if (idx !== -1) {
                            linkLobbyGroups[idx] = group;
                            seenTitles.set(normalizedTitle, group);
                        }
                    }
                }
            }
            
            // Re-sort after deduplication
            linkLobbyGroups.sort((a, b) => (a.sortOrder ?? Infinity) - (b.sortOrder ?? Infinity));
            
            // Summarize duplicates if any exist
            const dupCount = Object.keys(duplicatesByTitle).length;
            if (dupCount > 0) {
                console.log(`âš ï¸ Found ${dupCount} duplicate group titles (${Object.values(duplicatesByTitle).flat().length} hidden groups):`);
                for (const [title, ids] of Object.entries(duplicatesByTitle)) {
                    console.log(`   "${title}": ${ids.length + 1} copies (showing ${seenTitles.get(title).id}, hiding ${ids.join(', ')})`);
                }
            }
            
            renderLinkLobby();
        };
        
        // Subscribe to team groups (visibility == 'team')
        let teamGroupsUnsub;
        const subscribeTeamGroups = (useOrderBy = true) => {
            const queryToUse = useOrderBy ? teamGroupsQuery : teamGroupsQueryFallback;
            teamGroupsUnsub = onSnapshot(queryToUse, async (snapshot) => {
                teamGroups = await processGroupDocs(snapshot);
                mergeAndRender();
            }, (error) => {
                // If failed-precondition, indexes not ready - retry without orderBy
                if (error.code === 'failed-precondition' && useOrderBy) {
                    // Silently fallback to query without orderBy (client-side sorting handles it)
                    if (teamGroupsUnsub) teamGroupsUnsub();
                    subscribeTeamGroups(false);
                } else {
                    debugLog('Team groups query error:', error.code);
                    teamGroups = [];
                    mergeAndRender();
                }
            });
            unsubscribers.push(teamGroupsUnsub);
        };
        subscribeTeamGroups(true);
        
        // Subscribe to private groups (visibility == 'private' AND createdBy == currentUser)
        let privateGroupsUnsub;
        const subscribePrivateGroups = (useOrderBy = true) => {
            const queryToUse = useOrderBy ? privateGroupsQuery : privateGroupsQueryFallback;
            privateGroupsUnsub = onSnapshot(queryToUse, async (snapshot) => {
                privateGroups = await processGroupDocs(snapshot);
                mergeAndRender();
            }, (error) => {
                // If failed-precondition, indexes not ready - retry without orderBy
                if (error.code === 'failed-precondition' && useOrderBy) {
                    // Silently fallback to query without orderBy (client-side sorting handles it)
                    if (privateGroupsUnsub) privateGroupsUnsub();
                    subscribePrivateGroups(false);
                } else {
                    debugLog('Private groups query error:', error.code);
                    privateGroups = [];
                    mergeAndRender();
                }
            });
            unsubscribers.push(privateGroupsUnsub);
        };
        subscribePrivateGroups(true);
        
        // Subscribe to legacy groups (no visibility field) - filter client-side
        // This handles backward compatibility with groups created before visibility was added
        const unsub3 = onSnapshot(legacyGroupsQuery, async (snapshot) => {
            // Filter to only include groups without visibility OR where user is creator of private
            const filteredDocs = {
                docs: snapshot.docs.filter(doc => {
                    const data = doc.data();
                    // Include if no visibility field
                    if (!('visibility' in data)) return true;
                    // Already handled by other queries
                    return false;
                })
            };
            legacyGroups = await processGroupDocs(filteredDocs);
            mergeAndRender();
        }, (error) => {
            // If permission-denied, it means the rules are working correctly
            // and we shouldn't have access to some groups in this query
            if (error.code === 'permission-denied') {
                debugLog('Legacy query permission denied - using split queries only');
                legacyGroups = [];
                mergeAndRender();
            } else {
                console.error('Legacy groups query error:', error);
            }
        });
        unsubscribers.push(unsub3);
        
        // Store all unsubscribers
        linkLobbyUnsubscribe = unsubscribers;
        
    } catch (error) {
        console.error('Error setting up link lobby subscription:', error);
    }
}

// Render Link Lobby
function renderLinkLobby() {
    const container = document.getElementById('linkLobbyContainer');
    const emptyState = document.getElementById('linkLobbyEmpty');
    
    if (!container) return;
    
    // NOTE: Visibility filtering is now done at query level in subscribeLinkLobbyGroups()
    // The linkLobbyGroups array only contains groups the user has permission to see
    const visibleGroups = linkLobbyGroups;
    
    if (visibleGroups.length === 0) {
        if (emptyState) emptyState.style.display = 'block';
        // Remove any rendered groups
        container.querySelectorAll('.link-group').forEach(el => el.remove());
        return;
    }
    
    if (emptyState) emptyState.style.display = 'none';
    
    // Clear existing groups
    container.querySelectorAll('.link-group').forEach(el => el.remove());
    
    // Render each visible group
    visibleGroups.forEach((group, index) => {
        const groupEl = createGroupElement(group, index);
        container.appendChild(groupEl);
    });
    
    // Initialize drag and drop for groups and individual links
    initGroupDragAndDrop();
    initLinkDragAndDrop();
}

// Create group element
function createGroupElement(group, index) {
    const totalLinks = group.links.length + Object.values(group.domainGroups).reduce((sum, arr) => sum + arr.length, 0);
    const isPrivate = group.visibility === 'private';
    const isCreator = group.createdBy === currentAuthUser?.uid;
    
    const groupEl = document.createElement('div');
    groupEl.className = 'link-group';
    groupEl.dataset.groupId = group.id;
    groupEl.dataset.sortOrder = group.sortOrder;
    
    // Build badges HTML
    let badgesHtml = `<span class="group-count">${totalLinks}</span>`;
    if (isPrivate) {
        badgesHtml += '<span class="group-private-badge"><i class="fas fa-lock"></i> Private</span>';
    }
    if (group.autoGroupDomain) {
        badgesHtml += '<span class="auto-domain-badge">Auto-group</span>';
    }
    
    // Only show visibility toggle to creator
    const visibilityMenuItem = isCreator ? `
        <button class="link-group-menu-item" onclick="toggleGroupVisibility('${group.id}', '${isPrivate ? 'team' : 'private'}')">
            <i class="fas fa-${isPrivate ? 'users' : 'lock'}"></i> 
            ${isPrivate ? 'Make public to team' : 'Make private'}
        </button>
    ` : '';
    
    groupEl.innerHTML = `
        <div class="link-group-header">
            <div class="link-group-drag-handle" draggable="true">
                <i class="fas fa-grip-vertical"></i>
            </div>
            <div class="link-group-title">
                ${escapeHtml(group.title)}
                ${badgesHtml}
            </div>
            <div class="link-group-actions">
                <button class="link-group-btn add-link-btn" onclick="openAddLinkModal('${group.id}')" title="Add link">
                    <i class="fas fa-plus"></i>
                </button>
                <div class="link-group-menu">
                    <button class="link-group-btn" onclick="toggleGroupMenu('${group.id}')" title="More options">
                        <i class="fas fa-ellipsis-v"></i>
                    </button>
                    <div class="link-group-menu-dropdown" id="groupMenu-${group.id}">
                        <button class="link-group-menu-item" onclick="openEditGroupModal('${group.id}')">
                            <i class="fas fa-edit"></i> Rename group
                        </button>
                        ${visibilityMenuItem}
                        <button class="link-group-menu-item" onclick="toggleAutoDomain('${group.id}', ${!group.autoGroupDomain})">
                            <i class="fas fa-${group.autoGroupDomain ? 'times-circle' : 'magic'}"></i> 
                            ${group.autoGroupDomain ? 'Disable' : 'Enable'} auto-grouping
                        </button>
                        <div class="link-group-menu-divider"></div>
                        <button class="link-group-menu-item danger" onclick="openDeleteGroupModal('${group.id}', '${escapeHtml(group.title)}')">
                            <i class="fas fa-trash"></i> Delete group
                        </button>
                    </div>
                </div>
            </div>
        </div>
        <div class="link-group-content">
            ${renderGroupContent(group)}
        </div>
    `;
    
    return groupEl;
}

// Render group content (links and domain subgroups)
function renderGroupContent(group) {
    const hasDomainGroups = Object.keys(group.domainGroups).length > 0;
    const hasLinks = group.links.length > 0;
    
    if (!hasDomainGroups && !hasLinks) {
        return '<div class="link-group-empty"><i class="fas fa-link"></i> No links yet. Click + to add one.</div>';
    }
    
    let html = '';
    
    // Render domain subgroups first
    if (hasDomainGroups) {
        Object.entries(group.domainGroups).forEach(([domain, links]) => {
            const faviconUrl = `https://www.google.com/s2/favicons?domain=${domain}&sz=32`;
            html += `
                <div class="domain-subgroup" data-domain="${escapeHtml(domain)}">
                    <div class="domain-subgroup-header" onclick="toggleDomainSubgroup(this.parentElement)">
                        <img class="domain-subgroup-icon" src="${faviconUrl}" alt="" onerror="this.style.display='none'">
                        <span class="domain-subgroup-title">${escapeHtml(domain)}</span>
                        <span class="domain-subgroup-count">${links.length}</span>
                        <i class="fas fa-chevron-down domain-subgroup-toggle"></i>
                    </div>
                    <div class="domain-subgroup-content">
                        <div class="links-list">
                            ${links.map(link => renderLinkItem(link, group.id)).join('')}
                        </div>
                    </div>
                </div>
            `;
        });
    }
    
    // Render ungrouped links
    if (hasLinks) {
        html += `<div class="links-list">${group.links.map(link => renderLinkItem(link, group.id)).join('')}</div>`;
    }
    
    return html;
}

// Render individual link item - Collapsible tile: small state shows name + star, click opens link; arrow expands details
function renderLinkItem(link, groupId) {
    const faviconUrl = link.iconUrl || `https://www.google.com/s2/favicons?domain=${link.domain}&sz=32`;
    
    return `
        <div class="link-item ${link.favorite ? 'favorite' : ''}" data-link-id="${link.id}" data-group-id="${groupId}" data-url="${escapeHtml(link.url)}" draggable="true">
            <div class="link-item-drag-handle" title="Drag to reorder">
                <i class="fas fa-grip-vertical"></i>
            </div>
            <div class="link-item-collapsed" onclick="openLink('${escapeHtml(link.url)}')">
                <img class="link-favicon" src="${faviconUrl}" alt="" onerror="this.outerHTML='<div class=\\'link-favicon-fallback\\'><i class=\\'fas fa-link\\'></i></div>'">
                <span class="link-name">${escapeHtml(link.label)}</span>
            </div>
            <button class="link-collapsed-star ${link.favorite ? 'active' : ''}" onclick="event.stopPropagation(); toggleLinkFavorite('${groupId}', '${link.id}', ${!link.favorite})" title="${link.favorite ? 'Remove from favorites' : 'Add to favorites'}">
                <i class="fas fa-star"></i>
            </button>
            <button class="link-expand-btn" onclick="toggleLinkExpanded(event, this)" title="Show details">
                <i class="fas fa-chevron-down"></i>
            </button>
            <div class="link-item-expanded">
                <div class="link-expanded-content">
                    <div class="link-expanded-info">
                        <span class="link-label" data-link-id="${link.id}" data-group-id="${groupId}" onclick="startEditLinkName(event, '${groupId}', '${link.id}')">${escapeHtml(link.label)}</span>
                        <span class="link-domain">${escapeHtml(link.domain || '')}</span>
                    </div>
                    <div class="link-actions">
                        <button class="link-star-btn ${link.favorite ? 'active' : ''}" onclick="toggleLinkFavorite('${groupId}', '${link.id}', ${!link.favorite})" title="${link.favorite ? 'Remove from favorites' : 'Add to favorites'}">
                            <i class="fas fa-star"></i>
                        </button>
                        <button class="link-open-btn" onclick="openLink('${escapeHtml(link.url)}')" title="Open link">
                            Open <i class="fas fa-external-link-alt"></i>
                        </button>
                        <button class="link-delete-btn" onclick="deleteLink('${groupId}', '${link.id}')" title="Delete link">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;
}

// Toggle link item expanded/collapsed state
function toggleLinkExpanded(event, btn) {
    event.stopPropagation();
    const linkItem = btn.closest('.link-item');
    if (!linkItem) return;
    linkItem.classList.toggle('expanded');
}

// Start inline editing of link name
function startEditLinkName(event, groupId, linkId) {
    event.stopPropagation();
    
    const labelEl = event.target;
    if (labelEl.classList.contains('link-label-input')) return; // Already editing
    
    const currentName = labelEl.textContent;
    const originalHTML = labelEl.outerHTML;
    
    // Create inline input
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'link-label-input';
    input.value = currentName;
    input.dataset.groupId = groupId;
    input.dataset.linkId = linkId;
    input.dataset.originalName = currentName;
    
    // Replace label with input
    labelEl.replaceWith(input);
    input.focus();
    input.select();
    
    // Handle blur - save changes
    input.addEventListener('blur', () => saveLinkName(input));
    
    // Handle keyboard
    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            input.blur();
        } else if (e.key === 'Escape') {
            e.preventDefault();
            cancelEditLinkName(input);
        }
    });
    
    // Prevent row click when clicking input
    input.addEventListener('click', (e) => e.stopPropagation());
}

// Save edited link name to Firestore
async function saveLinkName(input) {
    const groupId = input.dataset.groupId;
    const linkId = input.dataset.linkId;
    const originalName = input.dataset.originalName;
    const newName = input.value.trim();
    
    // If empty or unchanged, revert
    if (!newName || newName === originalName) {
        revertLinkName(input, originalName);
        return;
    }
    
    // Create new label span
    const newLabel = document.createElement('span');
    newLabel.className = 'link-label';
    newLabel.dataset.linkId = linkId;
    newLabel.dataset.groupId = groupId;
    newLabel.textContent = newName;
    newLabel.onclick = (e) => startEditLinkName(e, groupId, linkId);
    
    // Replace input with label
    input.replaceWith(newLabel);
    
    // Save to Firestore
    if (!db || !appState.currentTeamId) return;
    
    try {
        const { doc, updateDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        const linkRef = doc(db, 'teams', appState.currentTeamId, 'linkLobbyGroups', groupId, 'links', linkId);
        // SECURITY: Rules use 'title' not 'label' for link names
        await updateDoc(linkRef, { title: newName, updatedAt: serverTimestamp() });
        showToast('Link renamed!', 'success');
    } catch (error) {
        console.error('Error renaming link:', error);
        showToast('Error renaming link', 'error');
        // Revert on error
        newLabel.textContent = originalName;
    }
}

// Cancel editing and revert to original name
function cancelEditLinkName(input) {
    revertLinkName(input, input.dataset.originalName);
}

// Revert link name input back to span
function revertLinkName(input, name) {
    const groupId = input.dataset.groupId;
    const linkId = input.dataset.linkId;
    
    const newLabel = document.createElement('span');
    newLabel.className = 'link-label';
    newLabel.dataset.linkId = linkId;
    newLabel.dataset.groupId = groupId;
    newLabel.textContent = name;
    newLabel.onclick = (e) => startEditLinkName(e, groupId, linkId);
    
    input.replaceWith(newLabel);
}

// Toggle domain subgroup collapse
function toggleDomainSubgroup(el) {
    el.classList.toggle('collapsed');
}

// Open link in new tab
function openLink(url) {
    window.open(url, '_blank', 'noopener,noreferrer');
}

// Toggle group menu
function toggleGroupMenu(groupId) {
    const menu = document.getElementById(`groupMenu-${groupId}`);
    if (!menu) return;
    
    const isOpen = menu.classList.contains('active');
    closeAllGroupMenus();
    
    if (!isOpen) {
        menu.classList.add('active');
        linkGroupMenuOpen = groupId;
    }
}

// Close all group menus
function closeAllGroupMenus() {
    document.querySelectorAll('.link-group-menu-dropdown.active').forEach(menu => {
        menu.classList.remove('active');
    });
    linkGroupMenuOpen = null;
}

// ===================================
// LINK LOBBY - Group CRUD Operations
// ===================================

// Open add group modal
function openAddGroupModal() {
    document.getElementById('linkGroupModalTitle').innerHTML = '<i class="fas fa-folder-plus"></i> Create Group';
    document.getElementById('linkGroupId').value = '';
    document.getElementById('linkGroupName').value = '';
    document.getElementById('linkGroupAutoDomain').checked = false;
    document.getElementById('linkGroupSubmitBtn').innerHTML = '<i class="fas fa-plus"></i> Create Group';
    document.getElementById('linkGroupModal').classList.add('active');
}

// Open edit group modal
function openEditGroupModal(groupId) {
    closeAllGroupMenus();
    const group = linkLobbyGroups.find(g => g.id === groupId);
    if (!group) return;
    
    document.getElementById('linkGroupModalTitle').innerHTML = '<i class="fas fa-edit"></i> Edit Group';
    document.getElementById('linkGroupId').value = groupId;
    document.getElementById('linkGroupName').value = group.title;
    document.getElementById('linkGroupAutoDomain').checked = group.autoGroupDomain || false;
    document.getElementById('linkGroupSubmitBtn').innerHTML = '<i class="fas fa-check"></i> Save Changes';
    document.getElementById('linkGroupModal').classList.add('active');
}

// Close group modal
function closeLinkGroupModal() {
    document.getElementById('linkGroupModal').classList.remove('active');
}

// Normalize group title for comparison (lowercase, trim whitespace)
function normalizeGroupTitle(title) {
    return title.toLowerCase().trim().replace(/\s+/g, ' ');
}

// Check if a group with the same title already exists
function groupTitleExists(title, excludeGroupId = null) {
    const normalizedTitle = normalizeGroupTitle(title);
    return linkLobbyGroups.some(g => 
        normalizeGroupTitle(g.title) === normalizedTitle && g.id !== excludeGroupId
    );
}

// Save group (create or update)
async function saveLinkGroup(event) {
    event.preventDefault();
    
    console.log('%cðŸ”µ saveLinkGroup CALLED', 'color: #0088ff; font-weight: bold; font-size: 14px');
    
    const groupId = document.getElementById('linkGroupId').value;
    const title = document.getElementById('linkGroupName').value.trim();
    const autoGroupDomain = document.getElementById('linkGroupAutoDomain').checked;
    
    console.log('%cðŸ“ Form Values:', 'color: #00aaff; font-weight: bold', { groupId, title, autoGroupDomain });
    
    if (!title) {
        console.log('%câŒ Validation Failed: Empty title', 'color: #ff0000; font-weight: bold');
        showToast('Please enter a group name', 'error');
        return;
    }
    
    // Check for duplicate group name
    if (groupTitleExists(title, groupId || null)) {
        console.log('%câŒ Validation Failed: Duplicate title', 'color: #ff0000; font-weight: bold');
        showToast('A group with this name already exists', 'warning');
        return;
    }
    
    if (!db || !appState.currentTeamId) {
        console.log('%câŒ Validation Failed: No db or teamId', 'color: #ff0000; font-weight: bold', { db: !!db, teamId: appState.currentTeamId });
        showToast('Not connected to team', 'error');
        return;
    }
    
    console.log('%câœ… Validation Passed - Proceeding to Firestore', 'color: #00ff00; font-weight: bold');
    
    try {
        const { collection, doc, addDoc, updateDoc, serverTimestamp } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        if (groupId) {
            console.log('%cðŸ”„ UPDATE Mode', 'color: #ffaa00; font-weight: bold');
            // Update existing group - only mutable fields
            const groupRef = doc(db, 'teams', appState.currentTeamId, 'linkLobbyGroups', groupId);
            const updateData = { title, autoGroupDomain, updatedAt: serverTimestamp() };
            
            // DEBUG_PERMS logging
            if (DEBUG_PERMS) {
                console.log('[DEBUG_PERMS] UPDATE linkLobbyGroup:', {
                    path: `teams/${appState.currentTeamId}/linkLobbyGroups/${groupId}`,
                    keys: Object.keys(updateData),
                    uid: currentAuthUser.uid
                });
            }
            
            console.log('%cðŸ“¤ Sending UPDATE to Firestore...', 'color: #ffaa00; font-weight: bold', updateData);
            await updateDoc(groupRef, updateData);
            console.log('%câœ… UPDATE Succeeded!', 'color: #00ff00; font-weight: bold');
            showToast('Group updated!', 'success');
        } else {
            console.log('%câž• CREATE Mode', 'color: #00ff00; font-weight: bold');
            // Create new group - full schema with immutable fields
            const groupsRef = collection(db, 'teams', appState.currentTeamId, 'linkLobbyGroups');
            const sortOrder = linkLobbyGroups.length;
            const createData = {
                title,
                autoGroupDomain,
                sortOrder,
                teamId: appState.currentTeamId,  // IMMUTABLE: set only on create
                visibility: 'team',  // Explicit visibility for query compatibility
                createdAt: serverTimestamp(),    // IMMUTABLE: set only on create
                updatedAt: serverTimestamp(),
                createdBy: currentAuthUser.uid   // IMMUTABLE: set only on create
            };
            
            // DEBUG_PERMS logging
            if (DEBUG_PERMS) {
                console.log('[DEBUG_PERMS] CREATE linkLobbyGroup:', {
                    path: `teams/${appState.currentTeamId}/linkLobbyGroups/<new>`,
                    keys: Object.keys(createData),
                    uid: currentAuthUser.uid
                });
            }
            
            console.log('%cðŸ“¤ Sending CREATE to Firestore...', 'color: #00ff00; font-weight: bold', createData);
            const docRef = await addDoc(groupsRef, createData);
            console.log('%câœ… CREATE Succeeded! New Doc ID:', 'color: #00ff00; font-weight: bold; font-size: 14px', docRef.id);
            showToast('Group created!', 'success');
        }
        
        console.log('%cðŸšª Closing modal...', 'color: #00aaff; font-weight: bold');
        closeLinkGroupModal();
        console.log('%câœ… saveLinkGroup COMPLETE', 'color: #00ff00; font-weight: bold; font-size: 14px');
        
    } catch (error) {
        console.log('%câŒ ERROR CAUGHT IN CATCH BLOCK', 'color: #ff0000; font-weight: bold; font-size: 14px', error);
        const path = groupId 
            ? `teams/${appState.currentTeamId}/linkLobbyGroups/${groupId}`
            : `teams/${appState.currentTeamId}/linkLobbyGroups/<new>`;
        await logFirestoreError('saveLinkLobbyGroup', path, { title, autoGroupDomain }, {
            uid: currentAuthUser?.uid,
            teamId: appState.currentTeamId,
            isUpdate: !!groupId,
            userRole: appState.currentTeamData?.members?.[currentAuthUser?.uid]?.role
        }, error);
        showToast('Error saving group: ' + error.message, 'error');
    }
}

// Toggle auto-domain grouping
async function toggleAutoDomain(groupId, enabled) {
    closeAllGroupMenus();
    
    if (!db || !appState.currentTeamId) return;
    
    try {
        const { doc, updateDoc, serverTimestamp } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const groupRef = doc(db, 'teams', appState.currentTeamId, 'linkLobbyGroups', groupId);
        await updateDoc(groupRef, { 
            autoGroupDomain: enabled,
            updatedAt: serverTimestamp()
        });
        showToast(enabled ? 'Auto-grouping enabled!' : 'Auto-grouping disabled!', 'success');
        
    } catch (error) {
        console.error('Error toggling auto-domain:', error);
        showToast('Error updating group', 'error');
    }
}

// Toggle group visibility (private/team)
window.toggleGroupVisibility = async function(groupId, visibility) {
    closeAllGroupMenus();
    
    if (!db || !appState.currentTeamId) return;
    
    try {
        const { doc, updateDoc, serverTimestamp } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const groupRef = doc(db, 'teams', appState.currentTeamId, 'linkLobbyGroups', groupId);
        await updateDoc(groupRef, { 
            visibility: visibility,
            updatedAt: serverTimestamp()
        });
        
        const msg = visibility === 'private' ? 'Group is now private' : 'Group is now visible to team';
        showToast(msg, 'success');
        
    } catch (error) {
        console.error('Error toggling group visibility:', error);
        showToast('Error updating group visibility', 'error');
    }
};

// Open delete group modal
function openDeleteGroupModal(groupId, groupTitle) {
    closeAllGroupMenus();
    document.getElementById('deleteGroupId').value = groupId;
    document.getElementById('deleteGroupName').textContent = groupTitle;
    document.getElementById('deleteLinkGroupModal').classList.add('active');
}

// Close delete group modal
function closeDeleteLinkGroupModal() {
    document.getElementById('deleteLinkGroupModal').classList.remove('active');
}

// Confirm delete group
async function confirmDeleteLinkGroup() {
    const groupId = document.getElementById('deleteGroupId').value;
    
    if (!db || !appState.currentTeamId || !groupId) return;
    
    console.log('ðŸ—‘ï¸ Deleting group:', groupId);
    
    try {
        const { doc, deleteDoc, collection, getDocs } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        // Delete all links in the group first
        const linksRef = collection(db, 'teams', appState.currentTeamId, 'linkLobbyGroups', groupId, 'links');
        const linksSnapshot = await getDocs(linksRef);
        
        console.log(`ðŸ—‘ï¸ Deleting ${linksSnapshot.docs.length} links from group ${groupId}`);
        
        const deletePromises = linksSnapshot.docs.map(linkDoc => 
            deleteDoc(doc(db, 'teams', appState.currentTeamId, 'linkLobbyGroups', groupId, 'links', linkDoc.id))
        );
        await Promise.all(deletePromises);
        
        // Delete the group
        const groupRef = doc(db, 'teams', appState.currentTeamId, 'linkLobbyGroups', groupId);
        await deleteDoc(groupRef);
        
        console.log('âœ… Group deleted from Firestore:', groupId);
        showToast('Group deleted!', 'success');
        closeDeleteLinkGroupModal();
        
    } catch (error) {
        console.error('âŒ Error deleting group:', error);
        showToast('Error deleting group: ' + error.message, 'error');
    }
}

// ===================================
// LINK LOBBY - Link CRUD Operations
// ===================================

// Open add link modal
function openAddLinkModal(groupId) {
    document.getElementById('linkModalTitle').innerHTML = '<i class="fas fa-link"></i> Add Link';
    document.getElementById('linkId').value = '';
    document.getElementById('linkGroupIdForLink').value = groupId;
    document.getElementById('linkUrl').value = '';
    document.getElementById('linkLabel').value = '';
    document.getElementById('linkPreview').style.display = 'none';
    document.getElementById('linkSubmitBtn').innerHTML = '<i class="fas fa-plus"></i> Add Link';
    document.getElementById('linkModal').classList.add('active');
    
    // Focus the URL input
    setTimeout(() => document.getElementById('linkUrl').focus(), 100);
}

// Close link modal
function closeLinkModal() {
    document.getElementById('linkModal').classList.remove('active');
}

// Update link preview based on URL
function updateLinkPreview() {
    const urlInput = document.getElementById('linkUrl');
    const previewEl = document.getElementById('linkPreview');
    const faviconEl = document.getElementById('linkFaviconPreview');
    const domainEl = document.getElementById('linkDomainPreview');
    
    try {
        const url = new URL(urlInput.value);
        const domain = url.hostname;
        
        faviconEl.src = `https://www.google.com/s2/favicons?domain=${domain}&sz=32`;
        domainEl.textContent = domain;
        previewEl.style.display = 'flex';
    } catch (e) {
        previewEl.style.display = 'none';
    }
}

// Save link
async function saveLink(event) {
    event.preventDefault();
    
    const groupId = document.getElementById('linkGroupIdForLink').value;
    const urlValue = document.getElementById('linkUrl').value.trim();
    const label = document.getElementById('linkLabel').value.trim();
    
    if (!urlValue || !label) {
        showToast('Please fill in all fields', 'error');
        return;
    }
    
    // Validate URL
    let url, domain;
    try {
        url = new URL(urlValue);
        domain = url.hostname;
    } catch (e) {
        showToast('Please enter a valid URL', 'error');
        return;
    }
    
    if (!db || !appState.currentTeamId || !groupId) {
        showToast('Not connected to team', 'error');
        return;
    }
    
    try {
        const { collection, addDoc, serverTimestamp } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const linksRef = collection(db, 'teams', appState.currentTeamId, 'linkLobbyGroups', groupId, 'links');
        
        // SECURITY: Only include fields allowed by Firestore rules
        // Allowed: createdBy, url, title, description, domain, favicon, favorite, createdAt, updatedAt
        const newLinkData = {
            url: url.href,
            title: label,  // Rules use 'title', not 'label'
            domain,
            favicon: `https://www.google.com/s2/favicons?domain=${domain}&sz=32`,  // Rules use 'favicon', not 'iconUrl'
            favorite: false,
            createdAt: serverTimestamp(),
            createdBy: currentAuthUser.uid
        };
        
        const docRef = await addDoc(linksRef, newLinkData);
        
        // Immediately add the new link to local state and re-render
        const newLink = {
            id: docRef.id,
            ...newLinkData,
            label: label,  // Keep label for backward compat in UI rendering
            iconUrl: newLinkData.favicon,  // Keep iconUrl for backward compat in UI rendering
            createdAt: { toMillis: () => Date.now() } // Fake timestamp for sorting
        };
        
        // Find the group and add the link
        const group = linkLobbyGroups.find(g => g.id === groupId);
        if (group) {
            if (group.autoGroupDomain && domain) {
                if (!group.domainGroups[domain]) {
                    group.domainGroups[domain] = [];
                }
                group.domainGroups[domain].unshift(newLink);
            } else {
                group.links.unshift(newLink);
            }
            renderLinkLobby();
        }
        
        showToast('Link added!', 'success');
        closeLinkModal();
        
    } catch (error) {
        console.error('Error saving link:', error);
        showToast('Error saving link: ' + error.message, 'error');
    }
}

// Toggle link favorite - with instant UI feedback
async function toggleLinkFavorite(groupId, linkId, favorite) {
    if (!db || !appState.currentTeamId) return;
    
    // Immediately update UI for instant feedback
    const linkItem = document.querySelector(`.link-item[data-link-id="${linkId}"][data-group-id="${groupId}"]`);
    if (linkItem) {
        if (favorite) {
            linkItem.classList.add('favorite');
        } else {
            linkItem.classList.remove('favorite');
        }
        
        // Update collapsed state star button
        const collapsedStar = linkItem.querySelector('.link-collapsed-star');
        if (collapsedStar) {
            collapsedStar.classList.toggle('active', favorite);
            collapsedStar.setAttribute('onclick', `event.stopPropagation(); toggleLinkFavorite('${groupId}', '${linkId}', ${!favorite})`);
            collapsedStar.title = favorite ? 'Remove from favorites' : 'Add to favorites';
        }
        
        // Update expanded state star button
        const starBtn = linkItem.querySelector('.link-star-btn');
        if (starBtn) {
            starBtn.classList.toggle('active', favorite);
            starBtn.setAttribute('onclick', `toggleLinkFavorite('${groupId}', '${linkId}', ${!favorite})`);
            starBtn.title = favorite ? 'Remove from favorites' : 'Add to favorites';
        }
    }
    
    // Update local state
    const group = linkLobbyGroups.find(g => g.id === groupId);
    if (group) {
        // Check in regular links
        let link = group.links.find(l => l.id === linkId);
        if (link) {
            link.favorite = favorite;
        } else {
            // Check in domain groups
            for (const domain of Object.keys(group.domainGroups)) {
                link = group.domainGroups[domain].find(l => l.id === linkId);
                if (link) {
                    link.favorite = favorite;
                    break;
                }
            }
        }
    }
    
    try {
        const { doc, updateDoc, serverTimestamp } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const linkRef = doc(db, 'teams', appState.currentTeamId, 'linkLobbyGroups', groupId, 'links', linkId);
        await updateDoc(linkRef, { 
            favorite,
            updatedAt: serverTimestamp()
        });
        
    } catch (error) {
        console.error('Error toggling favorite:', error);
        showToast('Error updating favorite', 'error');
        // Revert UI on error
        renderLinkLobby();
    }
}

// Delete link
async function deleteLink(groupId, linkId) {
    const confirmed = await showConfirmModal('Delete this link?', {
        title: 'Delete Link',
        confirmText: 'Delete',
        type: 'danger'
    });
    if (!confirmed) return;
    
    if (!db || !appState.currentTeamId) return;
    
    try {
        const { doc, deleteDoc } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const linkRef = doc(db, 'teams', appState.currentTeamId, 'linkLobbyGroups', groupId, 'links', linkId);
        await deleteDoc(linkRef);
        
        showToast('Link deleted!', 'success');
        
    } catch (error) {
        console.error('Error deleting link:', error);
        showToast('Error deleting link', 'error');
    }
}

// ===================================
// LINK LOBBY - Drag and Drop
// ===================================

function initGroupDragAndDrop() {
    const container = document.getElementById('linkLobbyContainer');
    if (!container) return;
    
    const groups = container.querySelectorAll('.link-group');
    let draggedGroup = null;
    
    groups.forEach(group => {
        const handle = group.querySelector('.link-group-drag-handle');
        if (!handle) return;
        
        handle.addEventListener('dragstart', (e) => {
            draggedGroup = group;
            group.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', group.dataset.groupId);
        });
        
        handle.addEventListener('dragend', () => {
            draggedGroup = null;
            group.classList.remove('dragging');
            document.querySelectorAll('.link-group.drag-over').forEach(el => el.classList.remove('drag-over'));
        });
        
        group.addEventListener('dragover', (e) => {
            e.preventDefault();
            if (draggedGroup && draggedGroup !== group) {
                group.classList.add('drag-over');
            }
        });
        
        group.addEventListener('dragleave', () => {
            group.classList.remove('drag-over');
        });
        
        group.addEventListener('drop', async (e) => {
            e.preventDefault();
            group.classList.remove('drag-over');
            
            if (!draggedGroup || draggedGroup === group) return;
            
            // Reorder in DOM
            const allGroups = [...container.querySelectorAll('.link-group')];
            const draggedIndex = allGroups.indexOf(draggedGroup);
            const dropIndex = allGroups.indexOf(group);
            
            if (draggedIndex < dropIndex) {
                group.after(draggedGroup);
            } else {
                group.before(draggedGroup);
            }
            
            // Update sort orders in Firestore
            await updateGroupSortOrders();
        });
    });
}

// Update sort orders in Firestore
async function updateGroupSortOrders() {
    const container = document.getElementById('linkLobbyContainer');
    if (!container || !db || !appState.currentTeamId) return;
    
    try {
        const { doc, updateDoc } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const groups = container.querySelectorAll('.link-group');
        const updates = [];
        
        groups.forEach((group, index) => {
            const groupId = group.dataset.groupId;
            if (groupId) {
                const groupRef = doc(db, 'teams', appState.currentTeamId, 'linkLobbyGroups', groupId);
                updates.push(updateDoc(groupRef, { sortOrder: index }));
            }
        });
        
        await Promise.all(updates);
        console.log('Group sort orders updated');
        
    } catch (error) {
        console.error('Error updating sort orders:', error);
    }
}

// ===================================
// LINK LOBBY - Individual Link Drag and Drop (within groups)
// ===================================

let draggedLink = null;

function initLinkDragAndDrop() {
    const container = document.getElementById('linkLobbyContainer');
    if (!container) return;
    
    const linkItems = container.querySelectorAll('.link-item');
    
    linkItems.forEach(linkItem => {
        const handle = linkItem.querySelector('.link-item-drag-handle');
        if (!handle) return;
        
        // Drag start on handle
        handle.addEventListener('dragstart', (e) => {
            e.stopPropagation(); // Prevent group drag
            draggedLink = linkItem;
            linkItem.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', linkItem.dataset.linkId);
            e.dataTransfer.setData('application/x-link-drag', 'true'); // Mark as link drag
        });
        
        handle.addEventListener('dragend', () => {
            draggedLink = null;
            linkItem.classList.remove('dragging');
            // Remove all drag-over classes
            container.querySelectorAll('.link-item.drag-over').forEach(el => el.classList.remove('drag-over'));
        });
        
        // Drag over link items
        linkItem.addEventListener('dragover', (e) => {
            // Only handle link drags, not group drags
            if (!draggedLink || draggedLink === linkItem) return;
            
            // Only allow drop within same group
            if (draggedLink.dataset.groupId !== linkItem.dataset.groupId) return;
            
            e.preventDefault();
            e.stopPropagation();
            linkItem.classList.add('drag-over');
        });
        
        linkItem.addEventListener('dragleave', (e) => {
            e.stopPropagation();
            linkItem.classList.remove('drag-over');
        });
        
        linkItem.addEventListener('drop', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            linkItem.classList.remove('drag-over');
            
            if (!draggedLink || draggedLink === linkItem) return;
            
            // Only allow drop within same group
            const groupId = linkItem.dataset.groupId;
            if (draggedLink.dataset.groupId !== groupId) return;
            
            // Find the links-list container
            const linksList = linkItem.closest('.links-list');
            if (!linksList) return;
            
            // Reorder in DOM
            const allLinks = [...linksList.querySelectorAll('.link-item')];
            const draggedIndex = allLinks.indexOf(draggedLink);
            const dropIndex = allLinks.indexOf(linkItem);
            
            if (draggedIndex < dropIndex) {
                linkItem.after(draggedLink);
            } else {
                linkItem.before(draggedLink);
            }
            
            // Update sort orders in Firestore
            await updateLinkSortOrders(groupId, linksList);
        });
    });
    
    // Also allow dropping on .links-list containers (for empty areas)
    container.querySelectorAll('.links-list').forEach(linksList => {
        linksList.addEventListener('dragover', (e) => {
            if (!draggedLink) return;
            const groupId = linksList.closest('.link-group')?.dataset.groupId;
            if (draggedLink.dataset.groupId !== groupId) return;
            
            e.preventDefault();
        });
        
        linksList.addEventListener('drop', async (e) => {
            if (!draggedLink) return;
            const groupId = linksList.closest('.link-group')?.dataset.groupId;
            if (draggedLink.dataset.groupId !== groupId) return;
            
            e.preventDefault();
            
            // If dropped on empty area, move to end
            const lastLink = linksList.querySelector('.link-item:last-child');
            if (lastLink && lastLink !== draggedLink) {
                lastLink.after(draggedLink);
            }
            
            await updateLinkSortOrders(groupId, linksList);
        });
    });
}

// Update link sort orders in Firestore
async function updateLinkSortOrders(groupId, linksList) {
    if (!db || !appState.currentTeamId || !groupId) return;
    
    try {
        const { doc, updateDoc } = 
            await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const links = linksList.querySelectorAll('.link-item');
        const updates = [];
        
        links.forEach((link, index) => {
            const linkId = link.dataset.linkId;
            if (linkId && link.dataset.groupId === groupId) {
                const linkRef = doc(db, 'teams', appState.currentTeamId, 'linkLobbyGroups', groupId, 'links', linkId);
                updates.push(updateDoc(linkRef, { sortOrder: index }));
            }
        });
        
        await Promise.all(updates);
        console.log('Link sort orders updated for group:', groupId);
        
    } catch (error) {
        console.error('Error updating link sort orders:', error);
    }
}

// Debounce helper
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Make functions globally accessible
window.openAddGroupModal = openAddGroupModal;
window.openEditGroupModal = openEditGroupModal;
window.closeLinkGroupModal = closeLinkGroupModal;
window.saveLinkGroup = saveLinkGroup;
window.toggleAutoDomain = toggleAutoDomain;
window.openDeleteGroupModal = openDeleteGroupModal;
window.closeDeleteLinkGroupModal = closeDeleteLinkGroupModal;
window.confirmDeleteLinkGroup = confirmDeleteLinkGroup;
window.openAddLinkModal = openAddLinkModal;
window.closeLinkModal = closeLinkModal;
window.saveLink = saveLink;
window.toggleLinkFavorite = toggleLinkFavorite;
window.deleteLink = deleteLink;
window.openLink = openLink;
window.toggleGroupMenu = toggleGroupMenu;
window.toggleDomainSubgroup = toggleDomainSubgroup;
window.toggleLinkExpanded = toggleLinkExpanded;
window.startEditLinkName = startEditLinkName;

// ===================================
// FINANCES TAB FUNCTIONALITY
// ===================================

/**
 * Transaction data model:
 * {
 *   id: string,
 *   type: 'income' | 'expense',
 *   amount: number,
 *   date: timestamp,
 *   description: string,
 *   category: string,
 *   party: string (customer/vendor name),
 *   isRecurring: boolean,
 *   frequency: 'monthly' | 'quarterly' | 'yearly' (if recurring),
 *   notes: string,
 *   createdBy: string (userId),
 *   createdAt: timestamp,
 *   updatedAt: timestamp
 * }
 */

// Category definitions
const FINANCE_CATEGORIES = {
    income: [
        { value: 'sales', label: 'Sales' },
        { value: 'services', label: 'Services' },
        { value: 'subscriptions', label: 'Subscriptions' },
        { value: 'consulting', label: 'Consulting' },
        { value: 'other-income', label: 'Other Income' }
    ],
    expense: [
        { value: 'payroll', label: 'Payroll' },
        { value: 'software', label: 'Software & Tools' },
        { value: 'marketing', label: 'Marketing' },
        { value: 'office', label: 'Office & Equipment' },
        { value: 'travel', label: 'Travel' },
        { value: 'utilities', label: 'Utilities' },
        { value: 'other-expense', label: 'Other Expense' }
    ]
};

/**
 * Initialize finances tab event listeners
 */
function initFinances() {
    // Revenue column buttons
    const addRevenueBtn = document.getElementById('addRevenueBtn');
    const addFirstRevenueBtn = document.getElementById('addFirstRevenueBtn');
    
    if (addRevenueBtn) {
        addRevenueBtn.addEventListener('click', () => openTransactionModal(null, 'income'));
    }
    if (addFirstRevenueBtn) {
        addFirstRevenueBtn.addEventListener('click', () => openTransactionModal(null, 'income'));
    }
    
    // Expense column buttons
    const addExpenseBtn = document.getElementById('addExpenseBtn');
    const addFirstExpenseBtn = document.getElementById('addFirstExpenseBtn');
    
    if (addExpenseBtn) {
        addExpenseBtn.addEventListener('click', () => openTransactionModal(null, 'expense'));
    }
    if (addFirstExpenseBtn) {
        addFirstExpenseBtn.addEventListener('click', () => openTransactionModal(null, 'expense'));
    }
    
    // Placeholder buttons (when no transactions at all)
    const addFirstTransactionBtnRevenue = document.getElementById('addFirstTransactionBtnRevenue');
    const addFirstTransactionBtnExpense = document.getElementById('addFirstTransactionBtnExpense');
    
    if (addFirstTransactionBtnRevenue) {
        addFirstTransactionBtnRevenue.addEventListener('click', () => openTransactionModal(null, 'income'));
    }
    if (addFirstTransactionBtnExpense) {
        addFirstTransactionBtnExpense.addEventListener('click', () => openTransactionModal(null, 'expense'));
    }
    
    // Modal controls
    const closeTransactionModal = document.getElementById('closeTransactionModal');
    const cancelTransactionBtn = document.getElementById('cancelTransactionBtn');
    
    if (closeTransactionModal) {
        closeTransactionModal.addEventListener('click', closeTransactionModalFn);
    }
    if (cancelTransactionBtn) {
        cancelTransactionBtn.addEventListener('click', closeTransactionModalFn);
    }
    
    // Transaction form
    const transactionForm = document.getElementById('transactionForm');
    if (transactionForm) {
        transactionForm.addEventListener('submit', handleTransactionSave);
    }
    
    // Type toggle buttons
    const typeButtons = document.querySelectorAll('.transaction-type-toggle .type-btn');
    typeButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            typeButtons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            document.getElementById('transactionType').value = btn.dataset.type;
            
            // Update party label
            const partyLabel = document.getElementById('transactionPartyLabel');
            if (partyLabel) {
                partyLabel.innerHTML = btn.dataset.type === 'income' 
                    ? '<i class="fas fa-user"></i> Customer'
                    : '<i class="fas fa-building"></i> Vendor';
            }
        });
    });
    
    // Recurring toggle
    const recurringToggle = document.getElementById('transactionRecurring');
    if (recurringToggle) {
        recurringToggle.addEventListener('change', (e) => {
            const frequencyField = document.getElementById('recurringFrequencyField');
            if (frequencyField) {
                frequencyField.style.display = e.target.checked ? 'block' : 'none';
            }
        });
    }
    
    // Delete confirmation modal
    const closeDeleteTransactionModal = document.getElementById('closeDeleteTransactionModal');
    const cancelDeleteTransaction = document.getElementById('cancelDeleteTransaction');
    const confirmDeleteTransaction = document.getElementById('confirmDeleteTransaction');
    
    if (closeDeleteTransactionModal) {
        closeDeleteTransactionModal.addEventListener('click', closeDeleteTransactionModalFn);
    }
    if (cancelDeleteTransaction) {
        cancelDeleteTransaction.addEventListener('click', closeDeleteTransactionModalFn);
    }
    if (confirmDeleteTransaction) {
        confirmDeleteTransaction.addEventListener('click', handleDeleteTransaction);
    }
    
    // Close modal on background click
    const transactionModal = document.getElementById('transactionModal');
    if (transactionModal) {
        transactionModal.addEventListener('click', (e) => {
            if (e.target === transactionModal) {
                closeTransactionModalFn();
            }
        });
    }
}

/**
 * Open transaction modal for adding or editing
 * @param {Object|null} transaction - Transaction to edit, or null for new
 * @param {string} defaultType - Default transaction type ('income' or 'expense')
 */
function openTransactionModal(transaction = null, defaultType = 'income') {
    const modal = document.getElementById('transactionModal');
    const form = document.getElementById('transactionForm');
    const title = document.getElementById('transactionModalTitle');
    const subtitle = document.getElementById('transactionModalSubtitle');
    
    if (!modal || !form) return;
    
    // Reset form
    form.reset();
    document.getElementById('transactionId').value = '';
    document.getElementById('transactionType').value = defaultType;
    
    // Reset type buttons
    const typeButtons = document.querySelectorAll('.transaction-type-toggle .type-btn');
    typeButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.type === defaultType);
    });
    
    // Reset recurring field
    const frequencyField = document.getElementById('recurringFrequencyField');
    if (frequencyField) {
        frequencyField.style.display = 'none';
    }
    
    // Set default date to today
    const dateInput = document.getElementById('transactionDate');
    if (dateInput) {
        dateInput.value = new Date().toISOString().split('T')[0];
    }
    
    // Update party label based on default type
    const partyLabel = document.getElementById('transactionPartyLabel');
    if (partyLabel) {
        partyLabel.innerHTML = defaultType === 'income'
            ? '<i class="fas fa-user"></i> Customer'
            : '<i class="fas fa-building"></i> Vendor';
    }
    
    if (transaction) {
        // Edit mode
        title.innerHTML = '<i class="fas fa-edit"></i> Edit Transaction';
        subtitle.textContent = 'Update transaction details';
        
        // Fill form with transaction data
        document.getElementById('transactionId').value = transaction.id;
        document.getElementById('transactionType').value = transaction.type;
        document.getElementById('transactionAmount').value = transaction.amount;
        document.getElementById('transactionDate').value = transaction.date?.toDate?.()?.toISOString().split('T')[0] || transaction.date;
        document.getElementById('transactionDescription').value = transaction.description || '';
        document.getElementById('transactionCategory').value = transaction.category || '';
        document.getElementById('transactionParty').value = transaction.party || '';
        document.getElementById('transactionRecurring').checked = transaction.isRecurring || false;
        document.getElementById('transactionFrequency').value = transaction.frequency || 'monthly';
        document.getElementById('transactionNotes').value = transaction.notes || '';
        
        // Update type buttons
        typeButtons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.type === transaction.type);
        });
        
        // Show frequency field if recurring
        if (transaction.isRecurring && frequencyField) {
            frequencyField.style.display = 'block';
        }
        
        // Update party label
        if (partyLabel) {
            partyLabel.innerHTML = transaction.type === 'income'
                ? '<i class="fas fa-user"></i> Customer'
                : '<i class="fas fa-building"></i> Vendor';
        }
    } else {
        // Add mode - customize title based on type
        const typeLabel = defaultType === 'income' ? 'Revenue' : 'Expense';
        title.innerHTML = `<i class="fas fa-plus-circle"></i> New ${typeLabel}`;
        subtitle.textContent = `Record a new ${typeLabel.toLowerCase()} transaction`;
    }
    
    modal.classList.add('active');
}

/**
 * Close transaction modal
 */
function closeTransactionModalFn() {
    const modal = document.getElementById('transactionModal');
    if (modal) {
        modal.classList.remove('active');
    }
}

/**
 * Handle transaction form submission
 */
async function handleTransactionSave(event) {
    event.preventDefault();
    
    if (!db || !appState.currentTeamId || !currentAuthUser) {
        showToast('Unable to save transaction. Please try again.', 'error');
        return;
    }
    
    const transactionId = document.getElementById('transactionId').value;
    const isEdit = !!transactionId;
    
    // Get form values
    const transactionData = {
        type: document.getElementById('transactionType').value,
        amount: parseFloat(document.getElementById('transactionAmount').value) || 0,
        date: new Date(document.getElementById('transactionDate').value),
        description: document.getElementById('transactionDescription').value.trim(),
        category: document.getElementById('transactionCategory').value,
        party: document.getElementById('transactionParty').value.trim(),
        isRecurring: document.getElementById('transactionRecurring').checked,
        frequency: document.getElementById('transactionFrequency').value,
        notes: document.getElementById('transactionNotes').value.trim(),
        updatedAt: new Date()
    };
    
    // Validate
    if (!transactionData.description) {
        showToast('Please enter a description', 'error');
        return;
    }
    if (transactionData.amount <= 0) {
        showToast('Please enter a valid amount', 'error');
        return;
    }
    
    try {
        const { doc, collection, addDoc, updateDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        if (isEdit) {
            // Update existing transaction
            const transactionRef = doc(db, 'teams', appState.currentTeamId, 'transactions', transactionId);
            await updateDoc(transactionRef, {
                ...transactionData,
                updatedAt: serverTimestamp()
            });
            showToast('Transaction updated successfully', 'success');
        } else {
            // Add new transaction
            const transactionsRef = collection(db, 'teams', appState.currentTeamId, 'transactions');
            await addDoc(transactionsRef, {
                ...transactionData,
                createdBy: currentAuthUser.uid,
                createdAt: serverTimestamp(),
                updatedAt: serverTimestamp()
            });
            showToast('Transaction added successfully', 'success');
        }
        
        closeTransactionModalFn();
        loadTransactions(); // Refresh the list
        
    } catch (error) {
        console.error('Error saving transaction:', error);
        showToast('Failed to save transaction', 'error');
    }
}

/**
 * Open delete transaction confirmation modal
 */
function openDeleteTransactionModal(transactionId) {
    const modal = document.getElementById('deleteTransactionModal');
    const idInput = document.getElementById('deleteTransactionId');
    
    if (modal && idInput) {
        idInput.value = transactionId;
        modal.classList.add('active');
    }
}

/**
 * Close delete transaction modal
 */
function closeDeleteTransactionModalFn() {
    const modal = document.getElementById('deleteTransactionModal');
    if (modal) {
        modal.classList.remove('active');
    }
}

/**
 * Handle transaction deletion
 */
async function handleDeleteTransaction() {
    const transactionId = document.getElementById('deleteTransactionId').value;
    
    if (!db || !appState.currentTeamId || !transactionId) {
        showToast('Unable to delete transaction', 'error');
        return;
    }
    
    try {
        const { doc, deleteDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        const transactionRef = doc(db, 'teams', appState.currentTeamId, 'transactions', transactionId);
        await deleteDoc(transactionRef);
        
        showToast('Transaction deleted', 'success');
        closeDeleteTransactionModalFn();
        loadTransactions();
        
    } catch (error) {
        console.error('Error deleting transaction:', error);
        showToast('Failed to delete transaction', 'error');
    }
}

/**
 * Load transactions from Firestore
 */
async function loadTransactions() {
    if (!db || !appState.currentTeamId) {
        appState.transactions = [];
        return;
    }
    
    try {
        const { collection, query, orderBy, getDocs } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        const transactionsRef = collection(db, 'teams', appState.currentTeamId, 'transactions');
        const q = query(transactionsRef, orderBy('date', 'desc'));
        const snapshot = await getDocs(q);
        
        appState.transactions = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
        }));
        
        debugLog('ðŸ’° Loaded transactions:', appState.transactions.length);
        renderFinances();
        
    } catch (error) {
        console.error('Error loading transactions:', error);
        appState.transactions = [];
    }
}

/**
 * Apply filters and render finances
 */
function applyFinancesFilters() {
    const typeFilter = document.getElementById('financesTypeFilter')?.value || 'all';
    const categoryFilter = document.getElementById('financesCategoryFilter')?.value || 'all';
    const dateFilter = document.getElementById('financesDateFilter')?.value || 'all';
    const searchFilter = document.getElementById('financesSearchInput')?.value?.toLowerCase() || '';
    
    appState.financesFilters = { type: typeFilter, category: categoryFilter, date: dateFilter, search: searchFilter };
    renderFinances();
}

/**
 * Filter transactions based on current filters
 */
function getFilteredTransactions() {
    const { type, category, date, search } = appState.financesFilters;
    const now = new Date();
    
    return appState.transactions.filter(t => {
        // Type filter
        if (type !== 'all' && t.type !== type) return false;
        
        // Category filter
        if (category !== 'all' && t.category !== category) return false;
        
        // Date filter
        const transactionDate = t.date?.toDate?.() || new Date(t.date);
        if (date !== 'all') {
            const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
            const startOfLastMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);
            const endOfLastMonth = new Date(now.getFullYear(), now.getMonth(), 0);
            const startOfQuarter = new Date(now.getFullYear(), Math.floor(now.getMonth() / 3) * 3, 1);
            const startOfYear = new Date(now.getFullYear(), 0, 1);
            
            switch (date) {
                case 'thisMonth':
                    if (transactionDate < startOfMonth) return false;
                    break;
                case 'lastMonth':
                    if (transactionDate < startOfLastMonth || transactionDate > endOfLastMonth) return false;
                    break;
                case 'thisQuarter':
                    if (transactionDate < startOfQuarter) return false;
                    break;
                case 'thisYear':
                case 'ytd':
                    if (transactionDate < startOfYear) return false;
                    break;
            }
        }
        
        // Search filter
        if (search) {
            const searchableText = `${t.description} ${t.party} ${t.category} ${t.notes}`.toLowerCase();
            if (!searchableText.includes(search)) return false;
        }
        
        return true;
    });
}

/**
 * Calculate finance metrics from transactions
 */
function calculateFinanceMetrics(transactions = appState.transactions) {
    const now = new Date();
    const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
    const startOfYear = new Date(now.getFullYear(), 0, 1);
    
    let totalIncome = 0;
    let totalExpenses = 0;
    let mrr = 0;
    let ytdIncome = 0;
    let ytdExpenses = 0;
    const customerTotals = {};
    
    transactions.forEach(t => {
        const amount = t.amount || 0;
        const transactionDate = t.date?.toDate?.() || new Date(t.date);
        
        if (t.type === 'income') {
            totalIncome += amount;
            
            // Track customer totals
            if (t.party) {
                customerTotals[t.party] = (customerTotals[t.party] || 0) + amount;
            }
            
            // YTD income
            if (transactionDate >= startOfYear) {
                ytdIncome += amount;
            }
            
            // MRR calculation - recurring monthly income
            if (t.isRecurring) {
                switch (t.frequency) {
                    case 'monthly':
                        mrr += amount;
                        break;
                    case 'quarterly':
                        mrr += amount / 3;
                        break;
                    case 'yearly':
                        mrr += amount / 12;
                        break;
                }
            }
        } else {
            totalExpenses += amount;
            
            // YTD expenses
            if (transactionDate >= startOfYear) {
                ytdExpenses += amount;
            }
        }
    });
    
    // Find main customer (highest total)
    let mainCustomer = null;
    let maxTotal = 0;
    for (const [customer, total] of Object.entries(customerTotals)) {
        if (total > maxTotal) {
            maxTotal = total;
            mainCustomer = customer;
        }
    }
    
    return {
        totalIncome,
        totalExpenses,
        netBalance: totalIncome - totalExpenses,
        mrr,
        ytdIncome,
        ytdExpenses,
        ytdNet: ytdIncome - ytdExpenses,
        mainCustomer,
        mainCustomerTotal: maxTotal
    };
}

/**
 * Format currency amount
 */
function formatCurrency(amount) {
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 2
    }).format(amount || 0);
}

/**
 * Get category label from value
 */
function getCategoryLabel(value) {
    const allCategories = [...FINANCE_CATEGORIES.income, ...FINANCE_CATEGORIES.expense];
    const cat = allCategories.find(c => c.value === value);
    return cat?.label || value || 'Uncategorized';
}

/**
 * Render the finances section with two-column layout
 */
function renderFinances() {
    // Inject company subscriptions as virtual expense rows (private stays hidden)
    const subscriptionExpenses = (appState.subscriptions || [])
        .filter(sub => sub.type === 'company')
        .map(sub => {
            const subDate = sub.nextPayDate?.toDate?.() || new Date(sub.nextPayDate || Date.now());
            return {
            id: `sub-${sub.id}`,
            type: 'expense',
            amount: sub.amount || 0,
            party: sub.vendor || sub.name || 'Subscription',
            description: sub.name ? `Subscription Â· ${sub.name}` : 'Subscription',
            category: sub.category || 'subscriptions',
            date: subDate,
            frequency: sub.frequency || 'monthly',
            isRecurring: true,
            notes: sub.notes || '',
            createdBy: sub.createdBy,
            createdAt: sub.createdAt,
            isSubscription: true,
            subscriptionId: sub.id
            };
        });

    const combinedTransactions = [...appState.transactions, ...subscriptionExpenses];
    const metrics = calculateFinanceMetrics(combinedTransactions);
    
    // Separate transactions by type
    const revenueTransactions = appState.transactions.filter(t => t.type === 'income');
    const expenseTransactions = combinedTransactions.filter(t => t.type === 'expense');
    
    // Sort by date descending
    revenueTransactions.sort((a, b) => {
        const dateA = a.date?.toDate?.() || new Date(a.date);
        const dateB = b.date?.toDate?.() || new Date(b.date);
        return dateB - dateA;
    });
    expenseTransactions.sort((a, b) => {
        const dateA = a.date?.toDate?.() || new Date(a.date);
        const dateB = b.date?.toDate?.() || new Date(b.date);
        return dateB - dateA;
    });
    
    // Update metrics cards
    const mrrEl = document.getElementById('mrrValue');
    const ytdIncomeEl = document.getElementById('ytdIncomeValue');
    const netBalanceEl = document.getElementById('netBalanceValue');
    const mainCustomerEl = document.getElementById('mainCustomerValue');
    const mainCustomerTotalEl = document.getElementById('mainCustomerTotal');
    
    if (mrrEl) mrrEl.textContent = formatCurrency(metrics.mrr);
    if (ytdIncomeEl) ytdIncomeEl.textContent = formatCurrency(metrics.ytdIncome);
    if (netBalanceEl) {
        netBalanceEl.textContent = formatCurrency(metrics.netBalance);
        netBalanceEl.className = 'metric-value ' + (metrics.netBalance >= 0 ? 'positive' : 'negative');
    }
    if (mainCustomerEl) {
        mainCustomerEl.textContent = metrics.mainCustomer || 'N/A';
    }
    if (mainCustomerTotalEl) {
        mainCustomerTotalEl.textContent = metrics.mainCustomer ? formatCurrency(metrics.mainCustomerTotal) : '';
    }
    
    // Update column totals
    const revenueTotalEl = document.getElementById('revenueTotalBadge');
    const expensesTotalEl = document.getElementById('expensesTotalBadge');
    
    if (revenueTotalEl) revenueTotalEl.textContent = formatCurrency(metrics.totalIncome);
    if (expensesTotalEl) expensesTotalEl.textContent = formatCurrency(metrics.totalExpenses);
    
    // Check user permissions for add buttons
    const canEditFinances = hasPermission('editFinances');
    
    // Hide/show add buttons based on permissions
    const addRevenueBtn = document.getElementById('addRevenueBtn');
    const addExpenseBtn = document.getElementById('addExpenseBtn');
    if (addRevenueBtn) addRevenueBtn.style.display = canEditFinances ? 'inline-flex' : 'none';
    if (addExpenseBtn) addExpenseBtn.style.display = canEditFinances ? 'inline-flex' : 'none';
    
    // Check if there are any transactions (including subscription expenses)
    const hasAnyTransactions = combinedTransactions.length > 0;
    const financesContent = document.getElementById('financesContent');
    const financesPlaceholder = document.getElementById('financesPlaceholder');
    
    if (!hasAnyTransactions) {
        // Show the full-page placeholder
        if (financesContent) financesContent.style.display = 'none';
        if (financesPlaceholder) {
            financesPlaceholder.style.display = 'flex';
            // Show/hide buttons based on permissions
            const placeholderBtns = financesPlaceholder.querySelectorAll('button');
            placeholderBtns.forEach(btn => {
                btn.style.display = canEditFinances ? 'inline-flex' : 'none';
            });
        }
        return;
    }
    
    // Show the two-column layout
    if (financesContent) financesContent.style.display = 'flex';
    if (financesPlaceholder) financesPlaceholder.style.display = 'none';
    
    // Render revenue column
    const revenueList = document.getElementById('revenueList');
    const revenueEmptyState = document.getElementById('revenueEmptyState');
    const revenueFooter = document.getElementById('revenueFooter');
    const MAX_VISIBLE_ROWS = 6; // Rows visible before "See All"
    
    if (revenueList) {
        if (revenueTransactions.length === 0) {
            revenueList.innerHTML = '';
            if (revenueEmptyState) {
                revenueEmptyState.style.display = 'flex';
                const addBtn = revenueEmptyState.querySelector('button');
                if (addBtn) addBtn.style.display = canEditFinances ? 'inline-flex' : 'none';
            }
            if (revenueFooter) revenueFooter.style.display = 'none';
        } else {
            if (revenueEmptyState) revenueEmptyState.style.display = 'none';
            // Show all if expanded, otherwise limit to MAX_VISIBLE_ROWS
            const isExpanded = revenueList.classList.contains('expanded');
            const visibleTransactions = isExpanded ? revenueTransactions.slice(0, 50) : revenueTransactions.slice(0, MAX_VISIBLE_ROWS);
            revenueList.innerHTML = visibleTransactions.map(t => renderTransactionRow(t, canEditFinances)).join('');
            // Show footer only if more than MAX_VISIBLE_ROWS transactions
            if (revenueFooter) {
                revenueFooter.style.display = revenueTransactions.length > MAX_VISIBLE_ROWS ? 'block' : 'none';
                const btn = revenueFooter.querySelector('.see-all-btn');
                if (btn) {
                    const remaining = revenueTransactions.length - MAX_VISIBLE_ROWS;
                    btn.innerHTML = isExpanded 
                        ? '<span>Show Less</span><i class="fas fa-chevron-up"></i>'
                        : `<span>See All (${remaining} more)</span><i class="fas fa-chevron-down"></i>`;
                    btn.classList.toggle('active', isExpanded);
                }
            }
        }
    }
    
    // Render expenses column
    const expensesList = document.getElementById('expensesList');
    const expensesEmptyState = document.getElementById('expensesEmptyState');
    const expensesFooter = document.getElementById('expensesFooter');
    
    if (expensesList) {
        if (expenseTransactions.length === 0) {
            expensesList.innerHTML = '';
            if (expensesEmptyState) {
                expensesEmptyState.style.display = 'flex';
                const addBtn = expensesEmptyState.querySelector('button');
                if (addBtn) addBtn.style.display = canEditFinances ? 'inline-flex' : 'none';
            }
            if (expensesFooter) expensesFooter.style.display = 'none';
        } else {
            if (expensesEmptyState) expensesEmptyState.style.display = 'none';
            // Show all if expanded, otherwise limit to MAX_VISIBLE_ROWS
            const isExpanded = expensesList.classList.contains('expanded');
            const visibleTransactions = isExpanded ? expenseTransactions.slice(0, 50) : expenseTransactions.slice(0, MAX_VISIBLE_ROWS);
            expensesList.innerHTML = visibleTransactions.map(t => renderTransactionRow(t, canEditFinances)).join('');
            // Show footer only if more than MAX_VISIBLE_ROWS transactions
            if (expensesFooter) {
                expensesFooter.style.display = expenseTransactions.length > MAX_VISIBLE_ROWS ? 'block' : 'none';
                const btn = expensesFooter.querySelector('.see-all-btn');
                if (btn) {
                    const remaining = expenseTransactions.length - MAX_VISIBLE_ROWS;
                    btn.innerHTML = isExpanded 
                        ? '<span>Show Less</span><i class="fas fa-chevron-up"></i>'
                        : `<span>See All (${remaining} more)</span><i class="fas fa-chevron-down"></i>`;
                    btn.classList.toggle('active', isExpanded);
                }
            }
        }
    }
    
    // Attach click handlers for expandable rows
    document.querySelectorAll('.transaction-row-main').forEach(row => {
        row.addEventListener('click', (e) => {
            // Don't expand if clicking on action buttons
            if (e.target.closest('.transaction-actions')) return;
            const parentRow = row.closest('.transaction-row');
            if (parentRow) {
                parentRow.classList.toggle('expanded');
            }
        });
    });
}

// Ensure dropdown clicks register and close properly (settings, notifications, custom selects)
function initDropdownGuards() {
    const closeDropdowns = () => {
        document.querySelectorAll('.settings-dropdown, .notifications-dropdown, .custom-dropdown-options, .mention-dropdown, .doc-format-dropdown, .global-search-dropdown')
            .forEach(dd => {
                dd.classList.remove('active', 'visible');
                dd.style.display = 'none';
            });
    };

    document.addEventListener('click', (e) => {
        const option = e.target.closest('.dropdown-item, .custom-dropdown-option, .settings-dropdown .dropdown-item, .notifications-dropdown .dropdown-item, .doc-format-option, .mention-option, .global-search-result, .dropdown-menu-option');
        if (option) {
            // Allow primary click handlers to run first
            setTimeout(closeDropdowns, 0);
        }
    });
}

/**
 * Toggle See All/Show Less for finance transaction columns
 */
window.toggleSeeAll = function(column) {
    const listId = column === 'revenue' ? 'revenueList' : 'expensesList';
    const list = document.getElementById(listId);
    if (!list) return;
    
    list.classList.toggle('expanded');
    
    // Re-render the transactions to show/hide rows
    if (typeof renderFinances === 'function') {
        renderFinances();
    }
};

/**
 * Render a single transaction row with expandable details
 * Collapsed view: Amount (left) | From â†’ To (middle) | Short date (right)
 * Expanded view: Full details including notes, created-by, timestamps
 */
function renderTransactionRow(transaction, canEdit = true) {
    const t = transaction;
    const isSubscription = t.isSubscription === true;
    const transactionDate = t.date?.toDate?.() || new Date(t.date);
    // Short date format: Dec 13
    const shortDateStr = transactionDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    // Full date for expanded view
    const fullDateStr = transactionDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
    const isIncome = t.type === 'income';
    
    // Get creator name from team members
    let addedBy = 'Unknown';
    if (t.createdBy && appState.teamMembers) {
        const creator = appState.teamMembers.find(m => m.id === t.createdBy);
        if (creator) {
            addedBy = creator.displayName || creator.email || 'Unknown';
        }
    }
    
    const createdAtDate = t.createdAt?.toDate?.() || (t.createdAt ? new Date(t.createdAt) : null);
    const createdAtStr = createdAtDate 
        ? createdAtDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })
        : '';
    
    // Build from/to display for collapsed view
    // For income: party is "from" (customer paying)
    // For expense: party is "to" (vendor being paid)
    const fromToDisplay = t.party 
        ? (isIncome ? `from ${escapeHtml(t.party)}` : `to ${escapeHtml(t.party)}`)
        : escapeHtml(t.description);
    
    return `
        <div class="transaction-row ${isSubscription ? 'transaction-row-subscription' : ''}" data-id="${t.id}">
            <div class="transaction-row-main">
                <div class="transaction-col-amount">
                    <span class="transaction-amount ${t.type}">${isIncome ? '+' : '-'}${formatCurrency(t.amount)}</span>
                    ${t.isRecurring ? `<span class="transaction-recurring-indicator" title="Recurring ${t.frequency}"><i class="fas fa-sync-alt"></i></span>` : ''}
                    ${isSubscription ? '<span class="transaction-badge">Subscription</span>' : ''}
                </div>
                <div class="transaction-col-from-to">
                    <span class="transaction-from-to">${fromToDisplay}</span>
                </div>
                <div class="transaction-col-actions">
                    <span class="expand-icon"><i class="fas fa-chevron-down"></i></span>
                </div>
            </div>
            <div class="transaction-row-details">
                <div class="transaction-detail-grid">
                    <div class="transaction-detail-item">
                        <span class="detail-label">Date</span>
                        <span class="detail-value">${fullDateStr}</span>
                    </div>
                    ${t.description ? `
                    <div class="transaction-detail-item">
                        <span class="detail-label">Description</span>
                        <span class="detail-value">${escapeHtml(t.description)}</span>
                    </div>
                    ` : ''}
                    ${t.category ? `
                    <div class="transaction-detail-item">
                        <span class="detail-label">Category</span>
                        <span class="detail-value">${getCategoryLabel(t.category)}</span>
                    </div>
                    ` : ''}
                    ${t.party ? `
                    <div class="transaction-detail-item">
                        <span class="detail-label">${isIncome ? 'Customer' : 'Vendor'}</span>
                        <span class="detail-value">${escapeHtml(t.party)}</span>
                    </div>
                    ` : ''}
                    ${t.isRecurring ? `
                    <div class="transaction-detail-item">
                        <span class="detail-label">Recurring</span>
                        <span class="detail-value">${t.frequency.charAt(0).toUpperCase() + t.frequency.slice(1)}</span>
                    </div>
                    ` : ''}
                    ${t.notes ? `
                    <div class="transaction-detail-item full-width">
                        <span class="detail-label">Notes</span>
                        <span class="detail-value">${escapeHtml(t.notes)}</span>
                    </div>
                    ` : ''}
                    <div class="transaction-detail-item">
                        <span class="detail-label">Added By</span>
                        <span class="detail-value">${escapeHtml(addedBy)}</span>
                    </div>
                    ${createdAtStr ? `
                    <div class="transaction-detail-item">
                        <span class="detail-label">Added On</span>
                        <span class="detail-value">${createdAtStr}</span>
                    </div>
                    ` : ''}
                </div>
                ${canEdit ? `
                <div class="transaction-row-actions">
                    ${isSubscription ? `
                        <button class="btn-sm btn-edit" onclick="event.stopPropagation(); editSubscription('${t.subscriptionId}')">
                            <i class="fas fa-pen"></i> Manage
                        </button>
                        <button class="btn-sm btn-delete" onclick="event.stopPropagation(); openDeleteSubscriptionModal('${t.subscriptionId}')">
                            <i class="fas fa-trash"></i> Delete
                        </button>
                    ` : `
                        <button class="btn-sm btn-edit" onclick="event.stopPropagation(); editTransaction('${t.id}')">
                            <i class="fas fa-pen"></i> Edit
                        </button>
                        <button class="btn-sm btn-delete" onclick="event.stopPropagation(); openDeleteTransactionModal('${t.id}')">
                            <i class="fas fa-trash"></i> Delete
                        </button>
                    `}
                </div>
                ` : ''}
            </div>
        </div>
    `;
}

/**
 * Update category filter options based on transaction types
 */
function updateCategoryFilterOptions() {
    const categoryFilter = document.getElementById('financesCategoryFilter');
    if (!categoryFilter) return;
    
    const typeFilter = document.getElementById('financesTypeFilter')?.value || 'all';
    const currentValue = categoryFilter.value;
    
    categoryFilter.innerHTML = '<option value="all">All Categories</option>';
    
    if (typeFilter === 'all' || typeFilter === 'income') {
        const incomeGroup = document.createElement('optgroup');
        incomeGroup.label = 'Income';
        FINANCE_CATEGORIES.income.forEach(cat => {
            const option = document.createElement('option');
            option.value = cat.value;
            option.textContent = cat.label;
            incomeGroup.appendChild(option);
        });
        categoryFilter.appendChild(incomeGroup);
    }
    
    if (typeFilter === 'all' || typeFilter === 'expense') {
        const expenseGroup = document.createElement('optgroup');
        expenseGroup.label = 'Expense';
        FINANCE_CATEGORIES.expense.forEach(cat => {
            const option = document.createElement('option');
            option.value = cat.value;
            option.textContent = cat.label;
            expenseGroup.appendChild(option);
        });
        categoryFilter.appendChild(expenseGroup);
    }
    
    // Restore previous selection if still valid
    if (currentValue && categoryFilter.querySelector(`option[value="${currentValue}"]`)) {
        categoryFilter.value = currentValue;
    }
}

/**
 * Edit transaction
 */
function editTransaction(transactionId) {
    const transaction = appState.transactions.find(t => t.id === transactionId);
    if (transaction) {
        openTransactionModal(transaction);
    }
}

/**
 * Get finance data for metrics integration
 */
function getFinanceMetricsData() {
    return calculateFinanceMetrics(appState.transactions);
}

// Expose functions to window for inline onclick handlers
window.editTransaction = editTransaction;
window.openDeleteTransactionModal = openDeleteTransactionModal;

// ===================================
// SUBSCRIPTIONS MANAGEMENT
// ===================================

// Current subscription tab filter
let currentSubscriptionTab = 'company';

/**
 * Load subscriptions from Firestore
 */
async function loadSubscriptions() {
    if (!db || !appState.currentTeamId) {
        appState.subscriptions = [];
        return;
    }
    
    try {
        const { collection, query, orderBy, getDocs } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        const subscriptionsRef = collection(db, 'teams', appState.currentTeamId, 'subscriptions');
        const q = query(subscriptionsRef, orderBy('nextPayDate', 'asc'));
        const snapshot = await getDocs(q);
        
        const rawSubs = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
        }));
        // Privacy: only show private subscriptions created by the current user
        appState.subscriptions = rawSubs.filter(sub => {
            if (sub.type !== 'private') return true;
            if (!sub.createdBy) return false; // safest default for legacy records
            return sub.createdBy === currentAuthUser?.uid;
        });
        
        debugLog('ðŸ“… Loaded subscriptions:', appState.subscriptions.length);
        renderSubscriptions();
        
    } catch (error) {
        console.error('Error loading subscriptions:', error);
        appState.subscriptions = [];
    }
}

/**
 * Render subscriptions section
 */
function renderSubscriptions() {
    const subscriptionsList = document.getElementById('subscriptionsList');
    const subscriptionsEmptyState = document.getElementById('subscriptionsEmptyState');
    const subscriptionsCount = document.getElementById('subscriptionsCount');
    const companySubsCount = document.getElementById('companySubsCount');
    const privateSubsCount = document.getElementById('privateSubsCount');
    const upcomingSubscriptions = document.getElementById('upcomingSubscriptions');
    
    if (!subscriptionsList) return;
    
    // Count subscriptions by type
    const companySubs = appState.subscriptions.filter(s => s.type === 'company');
    const privateSubs = appState.subscriptions.filter(s => s.type === 'private');
    
    // Update counts
    if (subscriptionsCount) subscriptionsCount.textContent = appState.subscriptions.length;
    if (companySubsCount) companySubsCount.textContent = companySubs.length;
    if (privateSubsCount) privateSubsCount.textContent = privateSubs.length;
    
    // Filter by current tab
    const filteredSubs = currentSubscriptionTab === 'company' ? companySubs : privateSubs;
    
    if (filteredSubs.length === 0) {
        subscriptionsList.innerHTML = '';
        if (subscriptionsEmptyState) subscriptionsEmptyState.style.display = 'flex';
    } else {
        if (subscriptionsEmptyState) subscriptionsEmptyState.style.display = 'none';
        subscriptionsList.innerHTML = filteredSubs.map(sub => renderSubscriptionRow(sub)).join('');
    }
    
    // Render upcoming subscriptions (next 7 days)
    renderUpcomingSubscriptions();
    
    // Recalculate finances (company subscriptions affect expenses)
    updateFinancesWithSubscriptions();
}

/**
 * Render a single subscription row
 */
function renderSubscriptionRow(sub) {
    const nextPayDate = sub.nextPayDate?.toDate?.() || new Date(sub.nextPayDate);
    const dateStr = nextPayDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    const isPrivate = sub.type === 'private';
    const currencySymbol = getCurrencySymbol(sub.currency || 'USD');
    const frequencyLabel = getFrequencyLabel(sub.frequency);
    
    // Get icon based on category
    const categoryIcon = getSubscriptionCategoryIcon(sub.category);
    
    return `
        <div class="subscription-row ${isPrivate ? 'private' : ''}" data-id="${sub.id}">
            <div class="subscription-info">
                <div class="subscription-logo ${sub.type}">
                    <i class="fas ${categoryIcon}"></i>
                </div>
                <div class="subscription-details">
                    <div class="subscription-name">
                        ${escapeHtml(sub.name)}
                        ${isPrivate ? '<span class="private-badge">Private</span>' : ''}
                    </div>
                    <div class="subscription-meta">
                        <span><i class="fas fa-calendar"></i> ${dateStr}</span>
                        ${sub.category ? `<span><i class="fas fa-tag"></i> ${escapeHtml(sub.category)}</span>` : ''}
                    </div>
                </div>
            </div>
            <div class="subscription-amount-col">
                <span class="subscription-amount">${currencySymbol}${formatNumber(sub.amount)}</span>
                <span class="subscription-frequency">${frequencyLabel}</span>
            </div>
            <div class="subscription-actions">
                ${sub.cancelLink ? `
                <a href="${escapeHtml(sub.cancelLink)}" target="_blank" rel="noopener noreferrer" class="subscription-action-btn link" title="Manage Subscription">
                    <i class="fas fa-external-link-alt"></i>
                </a>
                ` : ''}
                <button class="subscription-action-btn edit" onclick="editSubscription('${sub.id}')" title="Edit">
                    <i class="fas fa-pen"></i>
                </button>
                <button class="subscription-action-btn delete" onclick="openDeleteSubscriptionModal('${sub.id}')" title="Delete">
                    <i class="fas fa-trash"></i>
                </button>
            </div>
        </div>
    `;
}

/**
 * Render upcoming subscriptions (next 7 days)
 */
function renderUpcomingSubscriptions() {
    const container = document.getElementById('upcomingSubscriptions');
    if (!container) return;
    
    const now = new Date();
    const sevenDaysFromNow = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);
    
    // Get subscriptions due in next 7 days
    const upcoming = appState.subscriptions.filter(sub => {
        const nextPayDate = sub.nextPayDate?.toDate?.() || new Date(sub.nextPayDate);
        return nextPayDate >= now && nextPayDate <= sevenDaysFromNow;
    }).sort((a, b) => {
        const dateA = a.nextPayDate?.toDate?.() || new Date(a.nextPayDate);
        const dateB = b.nextPayDate?.toDate?.() || new Date(b.nextPayDate);
        return dateA - dateB;
    });
    
    if (upcoming.length === 0) {
        container.classList.remove('has-items');
        container.innerHTML = '';
        return;
    }
    
    container.classList.add('has-items');
    container.innerHTML = `
        <div class="upcoming-header">
            <i class="fas fa-bell"></i>
            <span>Upcoming in next 7 days</span>
        </div>
        <div class="upcoming-list">
            ${upcoming.map(sub => {
                const nextPayDate = sub.nextPayDate?.toDate?.() || new Date(sub.nextPayDate);
                const daysUntil = Math.ceil((nextPayDate - now) / (1000 * 60 * 60 * 24));
                const dateLabel = daysUntil === 0 ? 'Today' : daysUntil === 1 ? 'Tomorrow' : `In ${daysUntil} days`;
                const currencySymbol = getCurrencySymbol(sub.currency || 'USD');
                
                return `
                    <div class="upcoming-item">
                        <div class="upcoming-item-info">
                            <span class="upcoming-item-name">${escapeHtml(sub.name)}</span>
                            <span class="upcoming-item-date">${dateLabel}</span>
                        </div>
                        <span class="upcoming-item-amount">${currencySymbol}${formatNumber(sub.amount)}</span>
                    </div>
                `;
            }).join('')}
        </div>
    `;
}

/**
 * Update finances with company subscription data
 * Company subscriptions should appear as recurring expenses
 */
function updateFinancesWithSubscriptions() {
    // This function integrates company subscriptions into the expense totals
    // For now, we'll just recalculate MRR to include subscription costs
    const companySubs = appState.subscriptions.filter(s => s.type === 'company');
    
    let monthlySubsCost = 0;
    companySubs.forEach(sub => {
        const amount = sub.amount || 0;
        switch (sub.frequency) {
            case 'weekly':
                monthlySubsCost += amount * 4.33; // avg weeks per month
                break;
            case 'monthly':
                monthlySubsCost += amount;
                break;
            case 'quarterly':
                monthlySubsCost += amount / 3;
                break;
            case 'yearly':
                monthlySubsCost += amount / 12;
                break;
        }
    });
    
    // Store for use in metrics calculations
    appState.monthlySubscriptionCost = monthlySubsCost;
}

/**
 * Open subscription modal for adding or editing
 */
function openSubscriptionModal(subscription = null) {
    const modal = document.getElementById('subscriptionModal');
    const form = document.getElementById('subscriptionForm');
    const title = document.getElementById('subscriptionModalTitle');
    const subtitle = document.getElementById('subscriptionModalSubtitle');
    const typeHint = document.getElementById('subscriptionTypeHint');
    
    if (!modal || !form) return;
    
    // Reset form
    form.reset();
    document.getElementById('subscriptionId').value = '';
    document.getElementById('subscriptionType').value = 'company';
    
    // Reset type buttons
    const typeButtons = document.querySelectorAll('.subscription-type-toggle .type-btn');
    typeButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.type === 'company');
    });
    
    // Set default next payment date to today
    const dateInput = document.getElementById('subscriptionNextPayDate');
    if (dateInput) {
        dateInput.value = new Date().toISOString().split('T')[0];
    }
    
    // Update hint
    if (typeHint) {
        typeHint.textContent = 'Company subscriptions appear in expenses';
    }
    
    if (subscription) {
        // Edit mode
        title.innerHTML = '<i class="fas fa-edit"></i> Edit Subscription';
        subtitle.textContent = 'Update subscription details';
        
        // Fill form with subscription data
        document.getElementById('subscriptionId').value = subscription.id;
        document.getElementById('subscriptionType').value = subscription.type;
        document.getElementById('subscriptionName').value = subscription.name || '';
        document.getElementById('subscriptionAmount').value = subscription.amount || '';
        document.getElementById('subscriptionCurrency').value = subscription.currency || 'USD';
        document.getElementById('subscriptionFrequency').value = subscription.frequency || 'monthly';
        document.getElementById('subscriptionCategory').value = subscription.category || '';
        document.getElementById('subscriptionCancelLink').value = subscription.cancelLink || '';
        document.getElementById('subscriptionNotes').value = subscription.notes || '';
        
        // Set next payment date
        const nextPayDate = subscription.nextPayDate?.toDate?.() || new Date(subscription.nextPayDate);
        document.getElementById('subscriptionNextPayDate').value = nextPayDate.toISOString().split('T')[0];
        
        // Update type buttons
        typeButtons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.type === subscription.type);
        });
        
        // Update hint based on type
        if (typeHint) {
            typeHint.textContent = subscription.type === 'company' 
                ? 'Company subscriptions appear in expenses'
                : 'Private subscriptions create personal calendar reminders';
        }
    } else {
        // Add mode
        title.innerHTML = '<i class="fas fa-calendar-check"></i> New Subscription';
        subtitle.textContent = 'Track a recurring subscription';
    }
    
    modal.classList.add('active');
}

/**
 * Close subscription modal
 */
function closeSubscriptionModalFn() {
    const modal = document.getElementById('subscriptionModal');
    if (modal) {
        modal.classList.remove('active');
    }
}

/**
 * Handle subscription form submission
 */
async function handleSubscriptionSave(event) {
    event.preventDefault();
    
    if (!db || !appState.currentTeamId || !currentAuthUser) {
        showToast('Unable to save subscription. Please try again.', 'error');
        return;
    }
    
    const subscriptionId = document.getElementById('subscriptionId').value;
    const isEdit = !!subscriptionId;
    
    // Get form values
    const subscriptionData = {
        type: document.getElementById('subscriptionType').value,
        name: document.getElementById('subscriptionName').value.trim(),
        amount: parseFloat(document.getElementById('subscriptionAmount').value) || 0,
        currency: document.getElementById('subscriptionCurrency').value,
        frequency: document.getElementById('subscriptionFrequency').value,
        nextPayDate: new Date(document.getElementById('subscriptionNextPayDate').value),
        category: document.getElementById('subscriptionCategory').value,
        cancelLink: document.getElementById('subscriptionCancelLink').value.trim(),
        notes: document.getElementById('subscriptionNotes').value.trim(),
        updatedAt: new Date()
    };
    
    // Validate
    if (!subscriptionData.name) {
        showToast('Please enter a service name', 'error');
        return;
    }
    if (subscriptionData.amount <= 0) {
        showToast('Please enter a valid amount', 'error');
        return;
    }
    
    try {
        const { doc, collection, addDoc, updateDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        if (isEdit) {
            // Update existing subscription
            const subscriptionRef = doc(db, 'teams', appState.currentTeamId, 'subscriptions', subscriptionId);
            await updateDoc(subscriptionRef, {
                ...subscriptionData,
                updatedAt: serverTimestamp()
            });
            showToast('Subscription updated successfully', 'success');
        } else {
            // Add new subscription
            const subscriptionsRef = collection(db, 'teams', appState.currentTeamId, 'subscriptions');
            await addDoc(subscriptionsRef, {
                ...subscriptionData,
                createdBy: currentAuthUser.uid,
                createdAt: serverTimestamp(),
                updatedAt: serverTimestamp()
            });
            showToast('Subscription added successfully', 'success');
            
            // Create private calendar event if it's a private subscription
            if (subscriptionData.type === 'private') {
                await createSubscriptionCalendarEvent(subscriptionData);
            }
        }
        
        closeSubscriptionModalFn();
        loadSubscriptions(); // Refresh the list
        
    } catch (error) {
        console.error('Error saving subscription:', error);
        showToast('Failed to save subscription', 'error');
    }
}

/**
 * Create a private calendar event for a subscription
 */
async function createSubscriptionCalendarEvent(subscription) {
    try {
        const { collection, addDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        
        const eventData = {
            title: `ðŸ’³ ${subscription.name} payment due`,
            date: subscription.nextPayDate,
            type: 'reminder',
            visibility: 'private',
            createdBy: currentAuthUser.uid,
            isSubscriptionReminder: true,
            subscriptionName: subscription.name,
            subscriptionAmount: subscription.amount,
            subscriptionCurrency: subscription.currency,
            createdAt: serverTimestamp()
        };
        
        const eventsRef = collection(db, 'teams', appState.currentTeamId, 'events');
        await addDoc(eventsRef, eventData);
        
        debugLog('ðŸ“… Created calendar event for private subscription:', subscription.name);
    } catch (error) {
        console.error('Error creating subscription calendar event:', error);
    }
}

/**
 * Edit subscription
 */
function editSubscription(subscriptionId) {
    const subscription = appState.subscriptions.find(s => s.id === subscriptionId);
    if (subscription) {
        openSubscriptionModal(subscription);
    }
}

/**
 * Open delete subscription confirmation modal
 */
function openDeleteSubscriptionModal(subscriptionId) {
    const modal = document.getElementById('deleteSubscriptionModal');
    const idInput = document.getElementById('deleteSubscriptionId');
    
    if (modal && idInput) {
        idInput.value = subscriptionId;
        modal.classList.add('active');
    }
}

/**
 * Close delete subscription modal
 */
function closeDeleteSubscriptionModalFn() {
    const modal = document.getElementById('deleteSubscriptionModal');
    if (modal) {
        modal.classList.remove('active');
    }
}

/**
 * Delete subscription
 */
async function deleteSubscription(subscriptionId) {
    if (!db || !appState.currentTeamId) {
        showToast('Unable to delete subscription', 'error');
        return;
    }
    
    try {
        const { doc, deleteDoc } = await import('https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js');
        const subscriptionRef = doc(db, 'teams', appState.currentTeamId, 'subscriptions', subscriptionId);
        await deleteDoc(subscriptionRef);
        
        showToast('Subscription deleted', 'success');
        closeDeleteSubscriptionModalFn();
        loadSubscriptions();
        
    } catch (error) {
        console.error('Error deleting subscription:', error);
        showToast('Failed to delete subscription', 'error');
    }
}

/**
 * Initialize subscription event listeners
 */
function initSubscriptionEventListeners() {
    // Add subscription button
    const addSubscriptionBtn = document.getElementById('addSubscriptionBtn');
    const addFirstSubscriptionBtn = document.getElementById('addFirstSubscriptionBtn');
    
    if (addSubscriptionBtn) {
        addSubscriptionBtn.addEventListener('click', () => openSubscriptionModal());
    }
    if (addFirstSubscriptionBtn) {
        addFirstSubscriptionBtn.addEventListener('click', () => openSubscriptionModal());
    }
    
    // Close modal buttons
    const closeSubscriptionModal = document.getElementById('closeSubscriptionModal');
    const cancelSubscriptionBtn = document.getElementById('cancelSubscriptionBtn');
    
    if (closeSubscriptionModal) {
        closeSubscriptionModal.addEventListener('click', closeSubscriptionModalFn);
    }
    if (cancelSubscriptionBtn) {
        cancelSubscriptionBtn.addEventListener('click', closeSubscriptionModalFn);
    }
    
    // Form submission
    const subscriptionForm = document.getElementById('subscriptionForm');
    if (subscriptionForm) {
        subscriptionForm.addEventListener('submit', handleSubscriptionSave);
    }
    
    // Type toggle buttons
    const typeToggle = document.querySelector('.subscription-type-toggle');
    if (typeToggle) {
        typeToggle.querySelectorAll('.type-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                const type = btn.dataset.type;
                typeToggle.querySelectorAll('.type-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById('subscriptionType').value = type;
                
                // Update hint
                const typeHint = document.getElementById('subscriptionTypeHint');
                if (typeHint) {
                    typeHint.textContent = type === 'company' 
                        ? 'Company subscriptions appear in expenses'
                        : 'Private subscriptions create personal calendar reminders';
                }
            });
        });
    }
    
    // Tab switching
    const subscriptionsTabs = document.getElementById('subscriptionsTabs');
    if (subscriptionsTabs) {
        subscriptionsTabs.querySelectorAll('.sub-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabType = tab.dataset.tab;
                currentSubscriptionTab = tabType;
                
                subscriptionsTabs.querySelectorAll('.sub-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                renderSubscriptions();
            });
        });
    }
    
    // Delete modal
    const closeDeleteSubscriptionModal = document.getElementById('closeDeleteSubscriptionModal');
    const cancelDeleteSubscription = document.getElementById('cancelDeleteSubscription');
    const confirmDeleteSubscription = document.getElementById('confirmDeleteSubscription');
    
    if (closeDeleteSubscriptionModal) {
        closeDeleteSubscriptionModal.addEventListener('click', closeDeleteSubscriptionModalFn);
    }
    if (cancelDeleteSubscription) {
        cancelDeleteSubscription.addEventListener('click', closeDeleteSubscriptionModalFn);
    }
    if (confirmDeleteSubscription) {
        confirmDeleteSubscription.addEventListener('click', () => {
            const subscriptionId = document.getElementById('deleteSubscriptionId').value;
            if (subscriptionId) {
                deleteSubscription(subscriptionId);
            }
        });
    }
    
    // Close modal on backdrop click
    const subscriptionModal = document.getElementById('subscriptionModal');
    if (subscriptionModal) {
        subscriptionModal.addEventListener('click', (e) => {
            if (e.target === subscriptionModal) {
                closeSubscriptionModalFn();
            }
        });
    }
    
    const deleteSubModal = document.getElementById('deleteSubscriptionModal');
    if (deleteSubModal) {
        deleteSubModal.addEventListener('click', (e) => {
            if (e.target === deleteSubModal) {
                closeDeleteSubscriptionModalFn();
            }
        });
    }
}

/**
 * Get currency symbol from currency code
 */
function getCurrencySymbol(currencyCode) {
    const symbols = {
        'USD': '$',
        'EUR': 'â‚¬',
        'GBP': 'Â£',
        'CAD': '$',
        'AUD': '$',
        'JPY': 'Â¥',
        'ILS': 'â‚ª'
    };
    return symbols[currencyCode] || '$';
}

/**
 * Get frequency label
 */
function getFrequencyLabel(frequency) {
    const labels = {
        'weekly': '/week',
        'monthly': '/month',
        'quarterly': '/quarter',
        'yearly': '/year'
    };
    return labels[frequency] || '/month';
}

/**
 * Get subscription category icon
 */
function getSubscriptionCategoryIcon(category) {
    const icons = {
        'software': 'fa-code',
        'streaming': 'fa-play-circle',
        'cloud': 'fa-cloud',
        'productivity': 'fa-tasks',
        'communication': 'fa-comments',
        'design': 'fa-palette',
        'marketing': 'fa-bullhorn',
        'storage': 'fa-database',
        'security': 'fa-shield-alt',
        'other': 'fa-box'
    };
    return icons[category] || 'fa-credit-card';
}

/**
 * Format number with commas
 */
function formatNumber(num) {
    return new Intl.NumberFormat('en-US', {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    }).format(num || 0);
}

// Expose subscription functions to window for inline onclick handlers
window.editSubscription = editSubscription;
window.openDeleteSubscriptionModal = openDeleteSubscriptionModal;

// ===================================
// GLOBAL KEYBOARD SHORTCUTS
// ===================================

/**
 * Check if user is currently typing in an input/textarea or editable element
 * @returns {boolean} True if user is in a typing context
 */
function isTypingContext() {
    const activeEl = document.activeElement;
    if (!activeEl) return false;
    
    const tagName = activeEl.tagName.toLowerCase();
    
    // Check if in input or textarea
    if (tagName === 'input' || tagName === 'textarea') {
        return true;
    }
    
    // Check if contenteditable
    if (activeEl.isContentEditable || activeEl.contentEditable === 'true') {
        return true;
    }
    
    // Check for any modal being open (don't trigger shortcuts when modals are open)
    const openModals = document.querySelectorAll('.unified-modal.show, .modal.show');
    if (openModals.length > 0) {
        return true;
    }
    
    return false;
}

/**
 * Initialize global keyboard shortcuts
 * t = new task
 * e = new event  
 * m = focus chat message input
 * / = focus search
 */
function initGlobalKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
        // Skip if user is typing in an input, or if modifier keys are held
        if (isTypingContext() || e.ctrlKey || e.metaKey || e.altKey) {
            return;
        }
        
        const key = e.key.toLowerCase();
        
        switch (key) {
            case 't':
                // Open new task modal
                e.preventDefault();
                openNewTaskModal();
                break;
                
            case 'e':
                // Open new event modal
                e.preventDefault();
                openNewEventModal();
                break;
                
            case 'm':
                // Focus chat input and navigate to chat section
                e.preventDefault();
                focusChatInput();
                break;
                
            case '/':
                // Focus search input
                e.preventDefault();
                focusSearchInput();
                break;
        }
    });
    
    console.log('Global keyboard shortcuts initialized (t=task, e=event, m=chat, /=search)');
}

/**
 * Open the task modal for creating a new task
 */
function openNewTaskModal() {
    // Reset form for new task
    const taskForm = document.getElementById('taskForm');
    if (taskForm) {
        taskForm.reset();
        delete taskForm.dataset.editingTaskId;
    }
    
    // Update modal title and button
    const titleEl = document.querySelector('#taskModal .unified-modal-title h2');
    const submitBtn = document.querySelector('#taskModal .unified-btn-primary');
    if (titleEl) titleEl.innerHTML = '<i class="fas fa-plus-circle"></i> New Task';
    if (submitBtn) submitBtn.innerHTML = '<i class="fas fa-check"></i> Create Task';
    
    // Populate dropdowns
    if (typeof populateTaskAssigneeDropdown === 'function') {
        populateTaskAssigneeDropdown();
    }
    if (typeof populateTaskSpreadsheetDropdown === 'function') {
        populateTaskSpreadsheetDropdown();
    }
    if (typeof resetTaskModalDropdowns === 'function') {
        resetTaskModalDropdowns();
    }
    
    // Set minimum date to today
    const taskDueDateInput = document.getElementById('taskDueDate');
    if (taskDueDateInput) {
        const today = new Date().toISOString().split('T')[0];
        taskDueDateInput.setAttribute('min', today);
    }
    
    openModal('taskModal');
}

/**
 * Open the event modal for creating a new event
 */
function openNewEventModal() {
    openModal('eventModal');
}

/**
 * Focus the chat input and navigate to chat section if needed
 */
function focusChatInput() {
    // Navigate to chat section using switchTab
    if (typeof window.switchTab === 'function') {
        window.switchTab('chat');
    }
    
    // Focus the chat input after a short delay to allow navigation
    setTimeout(() => {
        const chatInput = document.getElementById('chatInput');
        if (chatInput) {
            chatInput.focus();
            chatInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }, 150);
}

/**
 * Focus the global search input
 */
function focusSearchInput() {
    const searchInput = document.getElementById('globalSearchInput');
    if (searchInput) {
        searchInput.focus();
        searchInput.select(); // Select existing text for easy replacement
    }
}

// ===================================
// INITIALIZATION
// ===================================
document.addEventListener('DOMContentLoaded', async () => {
    console.log('Teamster App Initializing...');
    
    // Check for join code in URL
    const urlParams = new URLSearchParams(window.location.search);
    const joinCode = urlParams.get('join');
    if (joinCode) {
        // Store the join code to process after auth
        sessionStorage.setItem('pendingJoinCode', joinCode.toUpperCase());
        // Clean the URL
        window.history.replaceState({}, document.title, window.location.pathname);
    }
    
    // Initialize Firebase Authentication first
    // Note: initializeUserTeam() is now called inside onAuthStateChanged
    await initializeFirebaseAuth();
    
    // Initialize all modules
    initNavigation();
    initChat();
    initCalendar();
    initTasks();
    initTeam();
    initActivityFeed();
    initModals();
    initSearch();
    initSettings();
    initJoinTeamModal(); // Initialize join team modal
    initLinkLobby(); // Initialize Link Lobby
    initFinances(); // Initialize Finances tab
    initSubscriptionEventListeners(); // Initialize Subscriptions
    initDropdownGuards(); // Ensure dropdown options close on selection
    initDocsModule(); // Initialize Docs feature
    initGlobalKeyboardShortcuts(); // Initialize keyboard shortcuts (t/e/m//)
    startActivityRefreshTimer(); // Start periodic refresh of activity times
    
    console.log('Teamster App Ready!');
    
    // Show welcome message
    setTimeout(() => {
        console.log('%c Welcome to Teamster! ', 'background: #0078D4; color: white; font-size: 16px; padding: 10px;');
        console.log('User authenticated. All features are ready to use.');
    }, 500);
});

// ===================================
// PUSH NOTIFICATIONS
// ===================================

/**
 * Register Service Worker for Push Notifications
 */
async function registerServiceWorker() {
    if (!('serviceWorker' in navigator)) {
        console.log('[Push] Service workers not supported');
        return null;
    }
    
    try {
        const registration = await navigator.serviceWorker.register('/sw.js', {
            scope: '/'
        });
        console.log('[Push] Service worker registered:', registration.scope);
        return registration;
    } catch (error) {
        console.error('[Push] Service worker registration failed:', error);
        return null;
    }
}

/**
 * Request push notification permission and subscribe
 */
async function requestPushPermission() {
    const statusEl = document.getElementById('pushNotifStatus');
    const btnEl = document.getElementById('enablePushBtn');
    
    // Check if push is supported
    if (!('PushManager' in window)) {
        if (statusEl) statusEl.textContent = 'Not supported';
        showToast('Push notifications are not supported in this browser', 'error');
        return;
    }
    
    try {
        // Request permission
        const permission = await Notification.requestPermission();
        
        if (permission === 'granted') {
            // Register service worker if not already
            const registration = await registerServiceWorker();
            if (!registration) {
                showToast('Failed to register service worker', 'error');
                return;
            }
            
            // Subscribe to push
            const subscription = await subscribeToPush(registration);
            if (subscription) {
                // Save subscription to Firestore
                await savePushSubscription(subscription);
                
                if (statusEl) statusEl.textContent = 'Enabled';
                if (btnEl) {
                    btnEl.innerHTML = '<i class="fas fa-check"></i> Enabled';
                    btnEl.disabled = true;
                    btnEl.classList.add('success');
                }
                showToast('Push notifications enabled!', 'success');
            }
        } else if (permission === 'denied') {
            if (statusEl) statusEl.textContent = 'Blocked';
            showToast('Notifications blocked. Please enable in browser settings.', 'error');
        } else {
            if (statusEl) statusEl.textContent = 'Not enabled';
        }
    } catch (error) {
        console.error('[Push] Error requesting permission:', error);
        showToast('Failed to enable notifications', 'error');
    }
}

/**
 * Subscribe to push notifications
 */
async function subscribeToPush(registration) {
    try {
        // Check for existing subscription
        let subscription = await registration.pushManager.getSubscription();
        
        if (subscription) {
            console.log('[Push] Already subscribed');
            return subscription;
        }
        
        // For VAPID, you need to generate keys. This is a placeholder.
        // In production, get the public key from your backend
        const vapidPublicKey = localStorage.getItem('vapidPublicKey');
        
        if (!vapidPublicKey) {
            // Without VAPID, we can still show local notifications
            console.log('[Push] No VAPID key configured, using local notifications only');
            return { endpoint: 'local', keys: {} };
        }
        
        // Convert VAPID key to Uint8Array
        const convertedVapidKey = urlBase64ToUint8Array(vapidPublicKey);
        
        subscription = await registration.pushManager.subscribe({
            userVisibleOnly: true,
            applicationServerKey: convertedVapidKey
        });
        
        console.log('[Push] Subscribed:', subscription);
        return subscription;
    } catch (error) {
        console.error('[Push] Subscription failed:', error);
        return null;
    }
}

/**
 * Convert base64 URL to Uint8Array for VAPID
 */
function urlBase64ToUint8Array(base64String) {
    const padding = '='.repeat((4 - base64String.length % 4) % 4);
    const base64 = (base64String + padding)
        .replace(/-/g, '+')
        .replace(/_/g, '/');
    
    const rawData = window.atob(base64);
    const outputArray = new Uint8Array(rawData.length);
    
    for (let i = 0; i < rawData.length; ++i) {
        outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
}

/**
 * Save push subscription to Firestore
 */
async function savePushSubscription(subscription) {
    if (!appState.currentUser || !appState.currentTeamId) {
        console.log('[Push] No user or team, skipping subscription save');
        return;
    }
    
    try {
        const subscriptionData = {
            endpoint: subscription.endpoint || 'local',
            keys: subscription.keys ? {
                p256dh: subscription.keys.p256dh || '',
                auth: subscription.keys.auth || ''
            } : {},
            userId: appState.currentUser.uid,
            teamId: appState.currentTeamId,
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            userAgent: navigator.userAgent
        };
        
        // Store in user's push subscriptions collection
        await db.collection('users')
            .doc(appState.currentUser.uid)
            .collection('pushSubscriptions')
            .doc('web')
            .set(subscriptionData, { merge: true });
        
        console.log('[Push] Subscription saved to Firestore');
    } catch (error) {
        console.error('[Push] Failed to save subscription:', error);
    }
}

/**
 * Check and update push notification UI status
 */
async function updatePushNotificationStatus() {
    const statusEl = document.getElementById('pushNotifStatus');
    const btnEl = document.getElementById('enablePushBtn');
    
    if (!statusEl || !btnEl) return;
    
    // Check if supported
    if (!('PushManager' in window) || !('serviceWorker' in navigator)) {
        statusEl.textContent = 'Not supported';
        btnEl.disabled = true;
        btnEl.innerHTML = '<i class="fas fa-times"></i> Not Supported';
        return;
    }
    
    // Check permission status
    if (Notification.permission === 'granted') {
        statusEl.textContent = 'Enabled';
        btnEl.innerHTML = '<i class="fas fa-check"></i> Enabled';
        btnEl.disabled = true;
        btnEl.classList.add('success');
    } else if (Notification.permission === 'denied') {
        statusEl.textContent = 'Blocked';
        btnEl.innerHTML = '<i class="fas fa-ban"></i> Blocked';
        btnEl.disabled = true;
    } else {
        statusEl.textContent = 'Not enabled';
        btnEl.innerHTML = '<i class="fas fa-bell"></i> Enable';
        btnEl.disabled = false;
    }
}

/**
 * Send a test push notification (local)
 */
function sendTestNotification(title = 'TeamsterX', body = 'Test notification!') {
    if (Notification.permission !== 'granted') {
        console.log('[Push] Permission not granted');
        return;
    }
    
    const options = {
        body: body,
        icon: '/img/favicon-circle.png',
        badge: '/img/favicon-circle.png',
        tag: 'teamsterx-test',
        vibrate: [100, 50, 100]
    };
    
    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
        navigator.serviceWorker.ready.then(registration => {
            registration.showNotification(title, options);
        });
    } else {
        new Notification(title, options);
    }
}

// Initialize push notifications on load
document.addEventListener('DOMContentLoaded', () => {
    // Register service worker early
    if ('serviceWorker' in navigator) {
        registerServiceWorker();
    }
    
    // Update UI status when settings tab is opened
    setTimeout(updatePushNotificationStatus, 1000);
});

// Make functions globally available
window.requestPushPermission = requestPushPermission;
window.sendTestNotification = sendTestNotification;

// ===================================
// EXPORT FOR TESTING (if needed)
// ===================================
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        appState,
        formatTime,
        getTimeAgo,
        escapeHtml
    };
}
